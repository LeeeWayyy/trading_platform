# T6.6 Web Console UI - Manual Trade Controls Plan v1.5

**Component:** Web-Console-UI
**Task:** T6.6 Manual Trade Controls
**Author:** Claude Code
**Date:** 2025-12-15
**Status:** Draft (v1.5)

## 1. Overview

This plan covers the Web Console (Streamlit) UI implementation for manual trade controls. The Backend API endpoints are already implemented in `apps/execution_gateway/api/manual_controls.py`.

### Goals
- Provide UI for canceling orders, closing/adjusting positions, and flattening all
- Integrate with existing authentication/authorization patterns
- Use existing rate limiting and audit logging infrastructure
- Follow established page patterns (performance.py, admin_users.py, etc.)

### Changes in v1.5
- [MEDIUM] Added HTTP 422 (Unprocessable Entity) handling for FastAPI Pydantic validation errors

### Changes in v1.4
- [MEDIUM] Fixed 503 error code: Backend maps mfa_misconfigured → `mfa_unavailable` in response
- [MEDIUM] Fixed 2FA token_not_yet_valid: Backend maps to `mfa_required` in response
- [MEDIUM] Added `invalid_request` (400) error code for qty validation errors
- [LOW] Verified `broker_timeout` IS used by backend (keep it)

### Changes in v1.3
- [HIGH] Fixed flatten-all request: Must include requested_by and requested_at fields
- [MEDIUM] Added missing MFA error codes: token_mismatch, token_not_yet_valid, mfa_unavailable
- [MEDIUM] Added header validation errors: missing_header, invalid_header

### Changes in v1.2
- [HIGH] Fixed JWT token type: Must use type="service" (GatewayAuthenticator requirement)
- [HIGH] Fixed session_version: Must use actual value from user session, not default
- [MEDIUM] Fixed strategy scoping: Backend returns 403, not empty list
- [MEDIUM] Extended auth error mapping to cover all backend exceptions
- [MEDIUM] Acknowledged shared private key architecture decision
- [LOW] Added display of user_strategies for effective scope visibility

## 2. Architecture

### 2.1 Communication Flow
```
Web Console (Streamlit)
    → Generate service JWT (type="service") with JWTManager
    → HTTP request with Bearer JWT + X-User-ID + X-Session-Version + X-Request-ID
    → Execution Gateway Backend API (GatewayAuthenticator validates)
    → Returns JSON response (or 403/404 for auth failures)
    → UI displays result/error
```

### 2.2 JWT Token Generation (v1.2 - Fixed)

**Critical Requirements from GatewayAuthenticator:**
1. Token must have `type="service"` (line 141-142 of gateway_auth.py)
2. Token `sub` claim must match `X-User-ID` header
3. Token must have `jti` for one-time-use enforcement
4. Token must have valid `exp`, `iss`, `aud` claims

**Note:** Role and strategies are fetched from database by GatewayAuthenticator, NOT from JWT claims.

**Implementation - Add new method to `libs/web_console_auth/jwt_manager.py`:**
```python
def generate_service_token(
    self, user_id: str, session_id: str, client_ip: str, user_agent: str
) -> str:
    """Generate service-to-service token for internal API calls.

    Unlike access tokens (for end-user sessions), service tokens are used
    for trusted service-to-service communication (Web Console → Execution Gateway).

    Args:
        user_id: User identifier (becomes sub claim)
        session_id: Session identifier for binding
        client_ip: Client IP address for binding
        user_agent: Client User-Agent for fingerprinting

    Returns:
        Signed JWT service token (RS256)
    """
    now = datetime.now(UTC)
    jti = str(uuid.uuid4())
    user_agent_hash = hashlib.sha256(user_agent.encode()).hexdigest()

    payload = {
        "sub": user_id,
        "iat": int(now.timestamp()),
        "exp": int((now + timedelta(seconds=self.config.access_token_ttl)).timestamp()),
        "jti": jti,
        "iss": self.config.jwt_issuer,
        "aud": self.config.jwt_audience,
        "type": "service",  # CRITICAL: Must be "service" for GatewayAuthenticator
        "session_id": session_id,
        "ip": client_ip,
        "user_agent_hash": user_agent_hash,
    }

    token = jwt.encode(payload, self.private_key, algorithm=self.config.jwt_algorithm)

    logger.info(
        "service_token_generated",
        extra={
            "user_id": user_id,
            "session_id": session_id,
            "jti": jti,
            "exp": payload["exp"],
        },
    )

    return token
```

**Implementation in `apps/web_console/utils/api_client.py`:**
```python
from libs.platform.web_console_auth.jwt_manager import JWTManager
from libs.platform.web_console_auth.config import AuthConfig
import redis

_jwt_manager: JWTManager | None = None

def _get_jwt_manager() -> JWTManager:
    """Return singleton JWTManager for service token generation."""
    global _jwt_manager
    if _jwt_manager is None:
        config = AuthConfig.from_env()
        redis_client = redis.Redis(
            host=os.getenv("REDIS_HOST", "localhost"),
            port=int(os.getenv("REDIS_PORT", "6379")),
            db=0,
            decode_responses=True,
        )
        _jwt_manager = JWTManager(config=config, redis_client=redis_client)
    return _jwt_manager

def generate_service_token_for_user(user: Mapping[str, Any]) -> str:
    """Generate service JWT for backend API calls on behalf of user."""
    manager = _get_jwt_manager()
    user_id = user.get("user_id") or user.get("sub")
    session_id = user.get("session_id", str(uuid.uuid4()))
    client_ip = user.get("ip", "0.0.0.0")
    user_agent = user.get("user_agent", "web-console")

    return manager.generate_service_token(
        user_id=user_id,
        session_id=session_id,
        client_ip=client_ip,
        user_agent=user_agent,
    )
```

### 2.3 Session Version Handling (v1.2 - Fixed)

**Critical:** X-Session-Version must match the user's actual session version in the database.

```python
def get_manual_controls_headers(user: Mapping[str, Any]) -> dict[str, str]:
    """Build headers for manual controls API.

    CRITICAL: session_version MUST come from user session, not defaulted.
    """
    token = generate_service_token_for_user(user)
    user_id = user.get("user_id") or user.get("sub")

    # CRITICAL: Use actual session_version from user session
    session_version = user.get("session_version")
    if session_version is None:
        raise ValueError("User session missing session_version - cannot call backend API")

    return {
        "Authorization": f"Bearer {token}",
        "X-User-ID": str(user_id),
        "X-Request-ID": str(uuid.uuid4()),
        "X-Session-Version": str(session_version),
        "Content-Type": "application/json",
    }
```

### 2.4 Shared Private Key Architecture (Acknowledged)

**Decision:** Web Console acts as a **Trusted Service** that can mint service tokens.

**Rationale:**
- Web Console is an internal application, not exposed to the internet
- Users are already authenticated via Auth0 before accessing Web Console
- Service tokens enable secure internal communication with audit trail
- Alternative (token forwarding) would require different backend architecture

**Security Controls:**
- Private key is stored securely (env var, not in code)
- Service tokens are short-lived (same TTL as access tokens)
- One-time-use JTI enforcement prevents replay attacks
- All tokens are auditable via jti

### 2.5 Key Dependencies (existing)
- `apps/web_console/auth/rate_limiter.py` - Client-side rate limiting
- `apps/web_console/auth/mfa_verification.py` - 2FA verification for flatten-all
- `apps/web_console/auth/step_up_callback.py` - Auth0 step-up callback handling
- `apps/web_console/auth/permissions.py` - Permission checks
- `apps/web_console/utils/api_client.py` - API request helpers
- `apps/web_console/config.py` - Endpoint configuration
- `libs/web_console_auth/jwt_manager.py` - JWT generation (to be extended)

## 3. Implementation Plan

### 3.1 Files to Create

#### 3.1.1 `apps/web_console/pages/manual_controls.py`
Main page with sections:
1. **Pending Orders Section**
   - Display pending orders table (filtered by user's strategies via backend)
   - Show `user_strategies` from response for effective scope visibility (v1.2)
   - Cancel single order button with reason input
   - Cancel all orders for symbol button

2. **Open Positions Section**
   - Display open positions table (filtered by user's strategies)
   - Close position button (full or partial)
   - Adjust position button

3. **Emergency Actions Section**
   - Flatten All button with 2FA requirement
   - Requires `Permission.FLATTEN_ALL`

**Pattern Reference:** Follow `pages/admin_users.py` structure for:
- Function signature: `render_manual_controls(user, db_pool, audit_logger)`
- Permission checks with `require_permission` decorator
- Error handling with `st.error()` and `st.success()`
- Use `st.rerun()` after successful actions to refresh data

#### 3.1.2 `apps/web_console/components/confirmation_dialog.py`
Reusable confirmation dialog component.

#### 3.1.3 `tests/apps/web_console/test_manual_controls.py`
Tests with JWTManager mock to avoid cryptographic key requirements.

### 3.2 Files to Modify

#### 3.2.1 `libs/web_console_auth/jwt_manager.py`
Add `generate_service_token` method (see section 2.2).

#### 3.2.2 `apps/web_console/config.py`
```python
# Manual Controls (T6.6)
EXECUTION_GATEWAY_MANUAL_CONTROLS_BASE = f"{EXECUTION_GATEWAY_URL}/api/v1"

# Feature flag (default false for controlled rollout)
FEATURE_MANUAL_CONTROLS = os.getenv("FEATURE_MANUAL_CONTROLS", "false").lower() in {
    "1", "true", "yes", "on",
}
```

#### 3.2.3 `apps/web_console/utils/api_client.py`
Add:
- `generate_service_token_for_user()` - Generate service JWT
- `get_manual_controls_headers()` - Build headers with session_version validation
- `post_manual_controls_api()` - POST with error handling
- `get_manual_controls_api()` - GET with error handling
- `ManualControlsAPIError` - Error class

#### 3.2.4 `apps/web_console/app.py`
Add navigation entry with VIEW_TRADES permission gating.

## 4. Permission Model (Aligned with Backend)

### 4.1 Permission Requirements
| Action | Required Permission | Backend Endpoint |
|--------|---------------------|------------------|
| View pending orders | VIEW_TRADES | GET /orders/pending |
| Cancel order | CANCEL_ORDER | POST /orders/{id}/cancel |
| Cancel all for symbol | CANCEL_ORDER | POST /orders/cancel-all |
| Close position | CLOSE_POSITION | POST /positions/{symbol}/close |
| Adjust position | CLOSE_POSITION | POST /positions/{symbol}/adjust |
| Flatten all | FLATTEN_ALL | POST /positions/flatten-all |

### 4.2 UI Permission Gating
```python
def render_manual_controls(user, db_pool, audit_logger):
    # Show pending orders section to all with VIEW_TRADES
    render_pending_orders_section(user)

    # Show cancel buttons only if CANCEL_ORDER
    if has_permission(user, Permission.CANCEL_ORDER):
        render_cancel_actions(user)

    # Show close/adjust buttons only if CLOSE_POSITION
    if has_permission(user, Permission.CLOSE_POSITION):
        render_position_actions(user)

    # Show flatten all only if FLATTEN_ALL
    if has_permission(user, Permission.FLATTEN_ALL):
        render_flatten_all_section(user)
```

## 5. Strategy Scoping (v1.2 - Fixed)

### 5.1 How Strategy Filtering Works
Backend enforces strategy scoping:
1. GatewayAuthenticator fetches user's strategies from `user_strategy_access` table
2. Backend filters data to user's strategies only
3. Backend returns 403 `strategy_unauthorized` if user has no authorized strategies (fail-closed)
4. Backend returns 404 `not_found` for orders/positions outside user's strategies

### 5.2 Fail-Closed Behavior (v1.2 - Corrected)
```python
def render_pending_orders_section(user):
    """Render pending orders with proper 403 handling."""
    try:
        response = get_manual_controls_api("/orders/pending", user)
        orders = response.get("orders", [])

        # Display effective scope from response (v1.2)
        user_strategies = response.get("user_strategies", [])
        if user_strategies:
            st.caption(f"Showing orders for strategies: {', '.join(user_strategies)}")

        if not orders:
            st.info("No pending orders found.")
        else:
            render_orders_table(orders)

    except ManualControlsAPIError as e:
        if e.error_code == "strategy_unauthorized":
            # 403 - user has no authorized strategies (fail-closed)
            st.warning("You don't have access to any strategies. Contact admin.")
        elif e.error_code == "permission_denied":
            st.error("You don't have permission to view orders.")
        else:
            st.error(f"Error: {e.message}")
```

## 6. 2FA Flow for Flatten All

### 6.1 Auth0 Step-Up Flow
```
1. User clicks [Flatten All]
2. Check session for recent step-up claims (auth_time within 60s)
3. If no valid step-up: redirect to Auth0 with prompt=login
4. After MFA: callback stores id_token in session
5. Show confirmation dialog (reason min 20 chars)
6. API call with complete FlattenAllRequest body
7. Backend validates via TwoFaValidator
```

### 6.2 Session Storage
```python
# After Auth0 step-up callback
st.session_state["step_up_claims"] = claims
st.session_state["step_up_id_token"] = id_token
st.session_state["step_up_time"] = datetime.now(UTC)
```

### 6.3 Complete Flatten All Request (v1.3 - Fixed)
**CRITICAL:** FlattenAllRequest requires ALL fields - missing any will cause 422 validation error.

```python
def flatten_all_positions(user: Mapping[str, Any], reason: str, id_token: str) -> dict[str, Any]:
    """Execute flatten-all with complete request body.

    FlattenAllRequest schema requires:
    - reason: str (min 20 chars) - Why flattening is needed
    - requested_by: str - User ID making the request
    - requested_at: datetime - Timestamp of request (ISO format)
    - id_token: str - Auth0 ID token proving MFA completion
    """
    user_id = user.get("user_id") or user.get("sub")

    request_body = {
        "reason": reason,  # min 20 chars validated by UI
        "requested_by": str(user_id),  # REQUIRED (v1.3)
        "requested_at": datetime.now(UTC).isoformat(),  # REQUIRED (v1.3)
        "id_token": id_token,  # From step-up callback
    }

    return post_manual_controls_api(
        "/positions/flatten-all",
        user=user,
        json_body=request_body,
    )
```

### 6.4 2FA Error Codes (v1.4 - Verified Against Backend)
**Note:** Backend maps internal error codes to response codes. UI sees response codes.

| Response Code | Internal Cause | Meaning | UI Action |
|---------------|----------------|---------|-----------|
| mfa_required | mfa_required | No MFA method in AMR claims | Trigger step-up |
| mfa_required | token_not_yet_valid | ID token nbf not reached | Trigger step-up (v1.4) |
| mfa_expired | mfa_expired | MFA completed >60s ago | Trigger step-up |
| mfa_invalid | invalid_jwt | Invalid ID token signature | Trigger step-up |
| token_mismatch | token_mismatch | ID token sub != requesting user | Error + re-auth |
| mfa_unavailable | mfa_misconfigured | Auth0 not configured on backend | Contact admin (v1.4) |

## 7. Error Handling (v1.5 - Verified Against Backend)

### 7.1 Complete API Error Mapping
| HTTP Status | Error Code | User Message | Action |
|-------------|------------|--------------|--------|
| 400 | validation_error | "Invalid request: {message}" | Fix input |
| 400 | invalid_request | "Invalid request: {message}" | Fix input (v1.4) |
| 400 | missing_header | "Missing required header. Please refresh." | Refresh page |
| 400 | invalid_header | "Invalid header format. Please refresh." | Refresh page |
| 422 | (FastAPI default) | "Invalid input: {detail}" | Fix input (v1.5) |
| 401 | invalid_token | "Invalid session. Please log in again." | Redirect to login |
| 401 | invalid_signature | "Invalid session. Please log in again." | Redirect to login |
| 401 | token_expired | "Session expired. Please log in again." | Redirect to login |
| 401 | token_not_valid_yet | "Session not yet valid. Please wait." | Retry |
| 401 | token_revoked | "Session revoked. Please log in again." | Redirect to login |
| 401 | token_replayed | "Session error. Please refresh and retry." | Refresh page |
| 403 | permission_denied | "You don't have permission for this action" | Contact admin |
| 403 | strategy_unauthorized | "You are not authorized for this strategy" | Contact admin |
| 403 | session_expired | "Session invalidated. Please log in again." | Redirect to login |
| 403 | invalid_issuer | "Authentication error. Please log in again." | Redirect to login |
| 403 | invalid_audience | "Authentication error. Please log in again." | Redirect to login |
| 403 | subject_mismatch | "Session mismatch. Please log in again." | Redirect to login |
| 403 | mfa_required | "MFA verification required." | Trigger step-up |
| 403 | mfa_expired | "MFA verification expired." | Trigger step-up |
| 403 | mfa_invalid | "MFA verification failed." | Trigger step-up |
| 403 | token_mismatch | "MFA token doesn't match user. Please re-authenticate." | Trigger step-up |
| 404 | not_found | "Order/position not found" | Refresh data |
| 429 | rate_limited | "Too many requests. Wait {retry_after}s." | Wait and retry |
| 500 | internal_error | "Server error. Please try again." | Retry |
| 502 | broker_error | "Broker error: {message}" | Retry or escalate |
| 503 | broker_unavailable | "Broker unavailable. Try again later." | Retry later |
| 503 | mfa_unavailable | "MFA service unavailable. Contact admin." | Contact admin (v1.4) |
| 504 | broker_timeout | "Broker timeout. Status may be unknown." | Check status |

### 7.2 Error Handler Implementation
```python
def handle_api_error(e: Exception, action: str):
    """Handle API errors with user-friendly messages."""
    if isinstance(e, requests.exceptions.ConnectionError):
        st.error("Unable to connect to server. Check your network.")
    elif isinstance(e, requests.exceptions.Timeout):
        st.error(f"Request timed out. {action} status may be unknown.")
    elif isinstance(e, ManualControlsAPIError):
        # Handle 422 Unprocessable Entity (FastAPI Pydantic validation) - v1.5
        if e.status_code == 422:
            detail = e.detail  # FastAPI returns {"detail": [{"loc": [...], "msg": "...", "type": "..."}]}
            if isinstance(detail, list) and detail:
                msg = detail[0].get("msg", "Invalid input")
            else:
                msg = "Invalid input"
            st.error(f"Validation error: {msg}")
            return

        msg = ERROR_MESSAGES.get(e.error_code, f"Error: {e.message}")

        # Handle auth errors that require re-login
        if e.error_code in AUTH_ERRORS_REQUIRING_LOGIN:
            st.error(msg)
            st.info("Please refresh and log in again.")
            # Optionally trigger logout
        elif e.error_code in MFA_ERRORS:
            st.warning(msg)
            trigger_step_up_auth()
        else:
            st.error(msg)
    else:
        st.error(f"Unexpected error: {e}")

AUTH_ERRORS_REQUIRING_LOGIN = {
    "invalid_token", "invalid_signature", "token_expired", "token_revoked",
    "session_expired", "invalid_issuer", "invalid_audience", "subject_mismatch",
}
MFA_ERRORS = {"mfa_required", "mfa_expired", "mfa_invalid", "token_mismatch"}  # v1.3: added token_mismatch
HEADER_ERRORS = {"missing_header", "invalid_header"}  # v1.3: added header validation errors
```

## 8. UI Design

### 8.1 Page Layout with Effective Scope (v1.2)
```
+----------------------------------------------------------+
| Manual Trade Controls                                      |
+----------------------------------------------------------+
|                                                            |
| ## Pending Orders                                          |
| Showing orders for strategies: alpha, beta                 |  <- v1.2: effective scope
| +--------------------------------------------------------+|
| | Symbol | Side | Qty | Status | Strategy | Actions       ||
| | AAPL   | buy  | 100 | pending| alpha    | [Cancel]      ||
| +--------------------------------------------------------+|
|                                                            |
| ... rest of UI ...                                         |
+----------------------------------------------------------+
```

### 8.2 State Refresh
After successful actions, use `st.rerun()` to refresh data immediately.

## 9. Testing Strategy

### 9.1 Test Fixtures
```python
@pytest.fixture
def mock_jwt_manager(monkeypatch):
    """Mock JWTManager to avoid RSA key requirements."""
    class FakeJWTManager:
        def generate_service_token(self, user_id, session_id, client_ip, user_agent):
            return "fake-service-jwt-token"

    monkeypatch.setattr(
        "apps.web_console.utils.api_client._get_jwt_manager",
        lambda: FakeJWTManager()
    )

@pytest.fixture
def user_with_session():
    """User dict with required session_version."""
    return {
        "user_id": "test-user",
        "session_id": "test-session",
        "session_version": 1,
        "role": "operator",
        "strategies": ["alpha", "beta"],
    }
```

### 9.2 Test Cases
1. Cancel order flow - success and various error responses
2. Cancel all orders flow
3. Close position flow (full and partial)
4. Adjust position flow
5. Flatten all with 2FA - valid and expired
6. Rate limiting display
7. Permission gating (viewer sees read-only)
8. Strategy scoping - 403 handling
9. Auth errors requiring re-login
10. Missing session_version raises ValueError

## 10. Implementation Order

1. **JWTManager update** - Add `generate_service_token` method
2. **Config updates** - Add base URL, feature flag
3. **API client updates** - Add JWT generation, POST support, error handling
4. **Confirmation dialog component** - Reusable component
5. **Main page** - manual_controls.py with all sections
6. **Navigation integration** - app.py updates
7. **Tests** - All test cases with JWTManager mock

## 11. Environment Requirements

### 11.1 Required Environment Variables
```bash
# RSA keys for JWT signing (must match execution_gateway)
JWT_PRIVATE_KEY_PATH=/path/to/private.pem
JWT_PUBLIC_KEY_PATH=/path/to/public.pem
JWT_ISSUER=trading-platform
JWT_AUDIENCE=execution-gateway

# Redis for token blacklist
REDIS_HOST=localhost
REDIS_PORT=6379

# Feature flag
FEATURE_MANUAL_CONTROLS=true
```

---

**Version History:**
- v1.0 (2025-12-15): Initial plan
- v1.1 (2025-12-15): Addressed initial review feedback
- v1.2 (2025-12-15): Fixed critical issues from fresh review
  - [HIGH] JWT must use type="service" for GatewayAuthenticator
  - [HIGH] session_version must come from user session, not defaulted
  - [MEDIUM] Strategy scoping returns 403, not empty list
  - [MEDIUM] Complete auth error mapping for all backend exceptions
  - [MEDIUM] Acknowledged shared private key architecture
  - [LOW] Display user_strategies from response for effective scope
- v1.3 (2025-12-15): Fixed flatten-all and error mapping completeness
  - [HIGH] FlattenAllRequest must include requested_by and requested_at fields
  - [MEDIUM] Added MFA error codes: token_mismatch, token_not_yet_valid, mfa_unavailable
  - [MEDIUM] Added header validation errors: missing_header, invalid_header
  - [MEDIUM] Added complete 2FA error code reference table in section 6.4
- v1.4 (2025-12-15): Verified error mappings against backend implementation
  - [MEDIUM] Fixed 503 error code: `mfa_misconfigured` → `mfa_unavailable` in response
  - [MEDIUM] Fixed 2FA `token_not_yet_valid` → `mfa_required` mapping in response
  - [MEDIUM] Added `invalid_request` (400) for qty validation errors
  - [LOW] Verified `broker_timeout` IS used by backend (kept)
- v1.5 (2025-12-15): Added FastAPI validation error handling
  - [MEDIUM] Added HTTP 422 (Unprocessable Entity) handling for Pydantic validation errors
  - [MEDIUM] Updated error handler to parse FastAPI's `detail` array format
