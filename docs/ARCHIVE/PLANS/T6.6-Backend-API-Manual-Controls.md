# T6.6 Component 1: Backend API - Manual Controls

## Overview

This component implements the server-side API endpoints for manual trade controls in the execution_gateway service, following the P4T3 task document specification (T6.6).

## Review History

| Version | Date | Reviewers | Status | Key Changes |
|---------|------|-----------|--------|-------------|
| v1.0 | 2024-12-14 | Gemini, Codex | Fixes Required | Initial plan |
| v1.1 | 2024-12-14 | Gemini, Codex | Gemini:Approved, Codex:Fixes | Added missing endpoints, JWT-based 2FA, session_version, headers, retry-after, error codes |
| v1.2 | 2024-12-14 | Gemini, Codex | Fixes Required | Full JWT validation, header enforcement tests, strategy scoping for bulk actions |
| v1.3 | 2024-12-14 | Gemini, Codex | Fixes Required | Service-to-service auth model, shared libs refactor, pending-orders strategy scoping |
| v1.4 | 2024-12-14 | Gemini, Codex | Gemini:Approved, Codex:Fixes | Complete libs/ refactor, jti/replay protection, full JWT error handling, isolation tests |
| v1.5 | 2024-12-14 | Gemini, Codex | Gemini:Approved, Codex:LOW | One-time-use JTI enforcement |
| v1.6 | 2024-12-14 | Gemini, Codex | Codex:Approved, Gemini:Fixes | Atomic JTI SET+TTL, exception definitions |
| v1.7 | 2024-12-14 | Gemini, Codex | Gemini:Approved, Codex:Fixes | Add JWKSValidator to libs/ refactor list |
| v1.8 | 2024-12-14 | Gemini, Codex | **APPROVED** | Add Redis to GatewayAuthenticator, add JWKSValidator to acceptance criteria |

## Dependencies Verified

- [x] Migration 0005_update_audit_log_schema.sql exists
- [x] Migration 0006_create_rbac_tables.sql exists
- [x] libs/web_console_auth/permissions.py - Role, Permission, has_permission, require_permission
- [x] libs/web_console_auth/jwt_manager.py - JWTManager with RS256 validation (iss/aud/exp/jti) + revocation

**Components to Refactor to libs/ [UPDATED v1.7]:**
- [ ] libs/web_console_auth/rate_limiter.py - Move RateLimiter from apps/web_console/auth/
- [ ] libs/web_console_auth/session_validation.py - Move validate_session_version from apps/web_console/auth/
- [ ] libs/web_console_auth/audit_logger.py - Move AuditLogger from apps/web_console/auth/
- [ ] libs/web_console_auth/jwks_validator.py - Move JWKSValidator from apps/web_console/auth/ [NEW v1.7]

**Existing in apps/ (will import from libs/ after refactor):**
- [x] apps/web_console/auth/rate_limiter.py - RateLimiter (to be moved)
- [x] apps/web_console/auth/mfa_verification.py - verify_step_up_auth, get_amr_method
- [x] apps/web_console/auth/audit_log.py - AuditLogger (to be moved)
- [x] apps/web_console/auth/session_invalidation.py - validate_session_version (to be moved)
- [x] apps/web_console/auth/jwks_validator.py - JWKSValidator (to be moved) [NEW v1.7]

---

## Authentication Model [NEW v1.3]

**Architecture Decision:** Service-to-Service Authentication (Proxy Pattern)

Per P4T3 Task Document, the Web Console acts as a trusted proxy to the Execution Gateway:

```
┌─────────────────┐      ┌─────────────────────┐      ┌─────────────────────┐
│   User Browser  │ ───► │   Web Console       │ ───► │  Execution Gateway  │
│                 │      │   (Streamlit)       │      │  (FastAPI)          │
└─────────────────┘      └─────────────────────┘      └─────────────────────┘
       │                          │                           │
       │ Session Cookie           │ Internal Service JWT      │
       │                          │ X-User-ID: user_id        │
       │                          │ X-Request-ID: uuid        │
       │                          │ X-Session-Version: int    │
```

**Why Service-to-Service (not Direct User Token):**
1. Web Console already authenticates users via OAuth2/session
2. Execution Gateway runs in internal network (not user-facing)
3. Internal JWT allows stronger control over token claims and lifetime
4. Prevents user-crafted tokens from reaching critical trade endpoints

**Internal Service Token Contract:**
- **Issuer:** `trading-platform-web-console`
- **Audience:** `execution-gateway`
- **Subject:** `user_id` (bound to X-User-ID header for verification)
- **TTL:** 60 seconds (short-lived for each request)
- **Algorithm:** RS256 (shared keys via `libs/web_console_auth/jwt_manager.py`)

**Trust Chain:**
1. Web Console validates user session (OAuth2 + session_version)
2. Web Console generates short-lived internal JWT with user claims
3. Execution Gateway verifies JWT signature + iss/aud/exp/sub
4. Execution Gateway binds JWT `sub` to `X-User-ID` (must match)
5. Execution Gateway fetches user's role/strategies from DB (not from JWT)

## Files to Create

### 1. libs/web_console_auth/gateway_auth.py [UPDATED v1.4]
**Shared library for service-to-service authentication (addresses cross-app dependency):**

```python
"""Service-to-service authentication for Execution Gateway."""
from libs.platform.web_console_auth.jwt_manager import JWTManager
from libs.platform.web_console_auth.config import AuthConfig
from libs.platform.web_console_auth.session_validation import validate_session_version
from libs.platform.web_console_auth.exceptions import (
    InvalidTokenError, TokenExpiredError, TokenRevokedError,
    InvalidSignatureError, InvalidIssuerError, InvalidAudienceError,
    ImmatureSignatureError, SubjectMismatchError, SessionExpiredError, MissingJtiError,
)

class GatewayAuthenticator:
    """Validates internal service tokens from Web Console.

    [UPDATED v1.8] Includes jti validation and replay protection via Redis.
    """

    def __init__(
        self,
        jwt_manager: JWTManager,
        db_pool: Pool,
        redis_client: redis.asyncio.Redis,  # [NEW v1.8] Required for JTI replay protection
    ) -> None:
        self.jwt_manager = jwt_manager
        self.db_pool = db_pool
        self.redis = redis_client  # [v1.8] For one-time-use JTI enforcement

    async def authenticate(
        self,
        token: str,
        x_user_id: str,
        x_request_id: str,
        x_session_version: int,
    ) -> AuthenticatedUser:
        """Validate service token and return authenticated user.

        [UPDATED v1.4] Steps with explicit error types:
        1. Verify JWT signature (raises InvalidSignatureError)
        2. Verify iss claim (raises InvalidIssuerError)
        3. Verify aud claim (raises InvalidAudienceError)
        4. Verify exp claim (raises TokenExpiredError)
        5. Verify nbf claim (raises ImmatureSignatureError)
        6. Verify jti present (raises MissingJtiError)
        7. Check jti not revoked via Redis (raises TokenRevokedError)
        8. Bind JWT sub to X-User-ID (raises SubjectMismatchError)
        9. Fetch user role from user_roles table
        10. Fetch user strategies from user_strategy_access table
        11. Validate session_version against DB (raises SessionExpiredError)

        Returns AuthenticatedUser with role, strategies, request_id.
        """
        # 1-7. JWT validation (uses JWTManager which already validates + checks revocation)
        try:
            claims = self.jwt_manager.validate_token(token, expected_type="service")
        except jwt.InvalidSignatureError:
            raise InvalidSignatureError("Token signature verification failed")
        except jwt.InvalidIssuerError:
            raise InvalidIssuerError("Token issuer not trusted")
        except jwt.InvalidAudienceError:
            raise InvalidAudienceError("Token not intended for this service")
        except jwt.ExpiredSignatureError:
            raise TokenExpiredError("Token has expired")
        except jwt.ImmatureSignatureError:
            raise ImmatureSignatureError("Token not yet valid")
        except TokenRevokedError:
            raise  # Re-raise as-is
        except jwt.InvalidTokenError as e:
            if "jti" in str(e).lower():
                raise MissingJtiError("Token missing jti claim")
            raise InvalidTokenError(str(e))

        # 8. Bind sub to X-User-ID
        if claims.get("sub") != x_user_id:
            raise SubjectMismatchError("Token subject does not match X-User-ID")

        # 9-10. Fetch role and strategies from DB
        role = await self.get_user_role(x_user_id)
        strategies = await self.get_user_strategies(x_user_id)

        # 11. Validate session_version
        if not await validate_session_version(x_user_id, x_session_version, self.db_pool):
            raise SessionExpiredError("Session invalidated")

        return AuthenticatedUser(
            user_id=x_user_id,
            role=role,
            strategies=strategies,
            session_version=x_session_version,
            request_id=x_request_id,
        )

    async def get_user_role(self, user_id: str) -> Role | None:
        """Fetch role from user_roles table."""
        ...

    async def get_user_strategies(self, user_id: str) -> list[str]:
        """Fetch authorized strategies from user_strategy_access table."""
        ...
```

**jti/Replay Protection [UPDATED v1.5]:**

**One-Time-Use Enforcement (addresses replay within TTL window):**

The revocation blacklist alone is insufficient - it only blocks explicitly revoked tokens, not replay of valid tokens within their TTL. Service tokens must be one-time-use:

```python
# libs/web_console_auth/gateway_auth.py

class GatewayAuthenticator:
    """[UPDATED v1.5] One-time-use JTI enforcement."""

    # Redis key prefix for seen JTIs (separate from revocation blacklist)
    JTI_SEEN_PREFIX = "jti_seen:"

    async def _check_jti_one_time_use(self, jti: str, exp: int) -> None:
        """Ensure JTI is used only once (one-time-use token).

        Args:
            jti: Token ID from JWT
            exp: Token expiration timestamp

        Raises:
            TokenReplayedError: If JTI was already used

        [UPDATED v1.6] Uses atomic SET NX EX to avoid orphaned keys.
        """
        key = f"{self.JTI_SEEN_PREFIX}{jti}"
        now = int(time.time())
        ttl = max(exp - now, 1)  # TTL = remaining token lifetime

        # [v1.6] Atomic SET with NX (only if not exists) and EX (expiry)
        # Single command prevents orphaned keys if process crashes between operations
        # Returns True if key was set (first use), None if already exists (replay)
        was_set = await self.redis.set(key, "1", nx=True, ex=ttl)

        if not was_set:
            # JTI already seen - this is a replay attack
            raise TokenReplayedError(f"Token already used: {jti}")

    async def authenticate(self, token: str, ...) -> AuthenticatedUser:
        # ... existing validation ...

        # After JWT validation succeeds, enforce one-time-use
        jti = claims.get("jti")
        exp = claims.get("exp")
        await self._check_jti_one_time_use(jti, exp)  # [NEW v1.5]

        # ... rest of authentication ...
```

**Protection Layers:**
1. **JWT signature verification** - Prevents token forgery
2. **iss/aud/exp/nbf validation** - Prevents cross-service and expired tokens
3. **Revocation blacklist** - Allows explicit token invalidation
4. **One-time-use JTI** [NEW v1.5] - Prevents replay within TTL window

**Redis Key Pattern:**
- `jti_seen:{jti}` - Stores "1" with TTL = token remaining lifetime
- Atomic SETNX ensures only first request succeeds
- Auto-expires after token would have expired anyway

### 2. apps/execution_gateway/api/__init__.py
Empty init file for the api subpackage.

### 3. apps/execution_gateway/api/manual_controls.py
New FastAPI router with ALL manual control endpoints:

```
POST /api/v1/orders/{order_id}/cancel         - Cancel single order
POST /api/v1/orders/cancel-all                - Cancel all orders for symbol
POST /api/v1/positions/{symbol}/close         - Close single position
POST /api/v1/positions/{symbol}/adjust        - Force position adjustment
POST /api/v1/positions/flatten-all            - Flatten all positions (2FA required)
GET  /api/v1/orders/pending                   - List pending orders (paginated)
```

### 4. apps/execution_gateway/schemas_manual_controls.py
Pydantic schemas for manual control requests/responses:
- CancelOrderRequest / CancelOrderResponse
- CancelAllOrdersRequest / CancelAllOrdersResponse
- ClosePositionRequest / ClosePositionResponse
- AdjustPositionRequest / AdjustPositionResponse
- FlattenAllRequest / FlattenAllResponse
- PendingOrdersRequest / PendingOrdersResponse
- ManualControlErrorResponse

### 5. apps/execution_gateway/api/dependencies.py [UPDATED v1.3]
Shared FastAPI dependencies using `libs/web_console_auth/gateway_auth.py`:
- get_gateway_authenticator (singleton)
- get_authenticated_user (uses GatewayAuthenticator)
- get_db_pool
- get_rate_limiter
- get_audit_logger

### 6. tests/libs/web_console_auth/test_gateway_auth.py [NEW v1.3]
Unit tests for GatewayAuthenticator:
- JWT signature validation
- Issuer/audience mismatch rejection
- Sub/X-User-ID binding enforcement
- Role/strategy fetching from DB

### 7. tests/apps/execution_gateway/api/__init__.py
Empty init file.

### 8. tests/apps/execution_gateway/api/test_manual_controls.py
Comprehensive test suite (>90% coverage target).

## File Updates

### 1. libs/web_console_auth/exceptions.py [NEW v1.6]
Add new exception classes for gateway authentication:
```python
"""Authentication exceptions for web console and gateway auth."""

class AuthError(Exception):
    """Base authentication error."""
    pass

class InvalidTokenError(AuthError):
    """Token is malformed or invalid."""
    pass

class TokenExpiredError(AuthError):
    """Token has expired."""
    pass

class TokenRevokedError(AuthError):
    """Token has been explicitly revoked."""
    pass

class TokenReplayedError(AuthError):  # [NEW v1.5]
    """Token has already been used (replay attack)."""
    pass

class InvalidSignatureError(AuthError):
    """Token signature verification failed."""
    pass

class InvalidIssuerError(AuthError):
    """Token issuer (iss) not trusted."""
    pass

class InvalidAudienceError(AuthError):
    """Token audience (aud) mismatch."""
    pass

class ImmatureSignatureError(AuthError):
    """Token not yet valid (nbf in future)."""
    pass

class SubjectMismatchError(AuthError):
    """Token subject (sub) does not match X-User-ID."""
    pass

class SessionExpiredError(AuthError):
    """Session version is stale or session invalidated."""
    pass

class MissingJtiError(AuthError):
    """Token missing required jti claim."""
    pass
```

### 2. apps/execution_gateway/main.py
Include the new router:
```python
from apps.execution_gateway.api.manual_controls import router as manual_controls_router
app.include_router(manual_controls_router, prefix="/api/v1", tags=["Manual Controls"])
```

---

## API Specifications (per P4T3 Task Document)

### Cross-Service Headers [UPDATED v1.3]

All manual control endpoints require these headers (per P4T3 Task Document):
```
Authorization: Bearer <internal_service_token>  # JWT signed by Web Console
X-User-ID: <user_id>                            # Must match JWT sub claim
X-Request-ID: <uuid>                            # For request tracing
X-Session-Version: <int>                        # For session_version validation
```

**Header Enforcement Rules [UPDATED v1.3]:**

| Header | Required | Validation | Error on Missing/Invalid |
|--------|----------|------------|-------------------------|
| Authorization | Yes | Valid RS256 JWT, verify iss/aud/exp/sub | See JWT Error Mapping below |
| X-User-ID | Yes | Non-empty, matches JWT `sub` claim | 400 `{"error": "missing_header"}` or 403 `{"error": "subject_mismatch"}` |
| X-Request-ID | Yes | Valid UUID format | 400 `{"error": "invalid_header", "message": "X-Request-ID must be valid UUID"}` |
| X-Session-Version | Yes | Positive integer, matches DB | 403 `{"error": "session_expired", "message": "Session invalidated"}` |

**JWT Error Mapping [NEW v1.3]:**

| JWT Validation Failure | HTTP Code | Error Response |
|------------------------|-----------|----------------|
| Missing/malformed token | 401 | `{"error": "invalid_token", "message": "Authorization required"}` |
| Invalid signature | 401 | `{"error": "invalid_signature", "message": "Token signature verification failed"}` |
| Wrong issuer (iss) | 403 | `{"error": "invalid_issuer", "message": "Token issuer not trusted"}` |
| Wrong audience (aud) | 403 | `{"error": "invalid_audience", "message": "Token not intended for this service"}` |
| Expired (exp) | 401 | `{"error": "token_expired", "message": "Token has expired"}` |
| Not yet valid (nbf) | 401 | `{"error": "token_not_valid_yet", "message": "Token not yet valid"}` |
| Sub != X-User-ID | 403 | `{"error": "subject_mismatch", "message": "Token subject does not match X-User-ID"}` |
| Token revoked | 401 | `{"error": "token_revoked", "message": "Token has been revoked"}` |
| Token replayed [NEW v1.5] | 401 | `{"error": "token_replayed", "message": "Token already used"}` |

**Dependency Implementation [UPDATED v1.5]:**
```python
from libs.platform.web_console_auth.gateway_auth import GatewayAuthenticator
from libs.platform.web_console_auth.exceptions import (
    InvalidTokenError, TokenExpiredError, TokenRevokedError, TokenReplayedError,  # [v1.5] Added TokenReplayedError
    InvalidSignatureError, InvalidIssuerError, InvalidAudienceError,
    ImmatureSignatureError, SubjectMismatchError, SessionExpiredError, MissingJtiError,
)

# Singleton instances (initialized on app startup)
_gateway_authenticator: GatewayAuthenticator | None = None

async def get_authenticated_user(
    request: Request,
    authenticator: GatewayAuthenticator = Depends(get_gateway_authenticator),
) -> AuthenticatedUser:
    """Extract and validate user from request headers using shared authenticator.

    [UPDATED v1.4] Complete JWT error handling with all exception types.
    """

    # 1. Extract headers
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail={"error": "invalid_token", "message": "Authorization required"})

    token = auth_header[7:]  # Remove "Bearer " prefix

    user_id = request.headers.get("X-User-ID")
    if not user_id:
        raise HTTPException(status_code=400, detail={"error": "missing_header", "message": "X-User-ID header required"})

    request_id = request.headers.get("X-Request-ID")
    if not request_id:
        raise HTTPException(status_code=400, detail={"error": "missing_header", "message": "X-Request-ID header required"})
    try:
        uuid.UUID(request_id)
    except ValueError:
        raise HTTPException(status_code=400, detail={"error": "invalid_header", "message": "X-Request-ID must be valid UUID"})

    session_version_str = request.headers.get("X-Session-Version")
    if not session_version_str:
        raise HTTPException(status_code=400, detail={"error": "missing_header", "message": "X-Session-Version header required"})
    try:
        session_version = int(session_version_str)
    except ValueError:
        raise HTTPException(status_code=400, detail={"error": "invalid_header", "message": "X-Session-Version must be integer"})

    # 2. Validate JWT and authenticate user (uses GatewayAuthenticator from libs/)
    # [UPDATED v1.4] Complete error handling matching JWT Error Mapping table
    try:
        return await authenticator.authenticate(
            token=token,
            x_user_id=user_id,
            x_request_id=request_id,
            x_session_version=session_version,
        )
    # 401 errors (authentication failures)
    except InvalidSignatureError:
        raise HTTPException(status_code=401, detail={"error": "invalid_signature", "message": "Token signature verification failed"})
    except TokenExpiredError:
        raise HTTPException(status_code=401, detail={"error": "token_expired", "message": "Token has expired"})
    except ImmatureSignatureError:
        raise HTTPException(status_code=401, detail={"error": "token_not_valid_yet", "message": "Token not yet valid"})
    except TokenRevokedError:
        raise HTTPException(status_code=401, detail={"error": "token_revoked", "message": "Token has been revoked"})
    except TokenReplayedError:  # [NEW v1.5]
        raise HTTPException(status_code=401, detail={"error": "token_replayed", "message": "Token already used"})
    except MissingJtiError:
        raise HTTPException(status_code=401, detail={"error": "invalid_token", "message": "Token missing required jti claim"})
    except InvalidTokenError as e:
        raise HTTPException(status_code=401, detail={"error": "invalid_token", "message": str(e)})
    # 403 errors (authorization failures)
    except InvalidIssuerError:
        raise HTTPException(status_code=403, detail={"error": "invalid_issuer", "message": "Token issuer not trusted"})
    except InvalidAudienceError:
        raise HTTPException(status_code=403, detail={"error": "invalid_audience", "message": "Token not intended for this service"})
    except SubjectMismatchError:
        raise HTTPException(status_code=403, detail={"error": "subject_mismatch", "message": "Token subject does not match X-User-ID"})
    except SessionExpiredError:
        raise HTTPException(status_code=403, detail={"error": "session_expired", "message": "Session invalidated. Please log in again."})
```

### Common Error Response Format [NEW v1.1]

All error responses use consistent structure (per task doc):
```json
{
    "error": "error_code",
    "message": "Human-readable message",
    "retry_after": 60,
    "timestamp": "ISO8601"
}
```

---

### POST /api/v1/orders/{order_id}/cancel

**Authorization:** `Permission.CANCEL_ORDER` + strategy access check + session_version validation

**Rate Limit:** 10 requests per 60 seconds per user (key: `cancel_order:{user_id}`)

**Request:**
```json
{
    "reason": "string (min 10 chars, required)",
    "requested_by": "user_id",
    "requested_at": "ISO8601 timestamp"
}
```

**Responses:**
- 200: `{"status": "cancelled", "order_id": "string", "cancelled_at": "ISO8601"}`
- 400: `{"error": "invalid_request", "message": "Reason must be at least 10 characters"}`
- 403 (permission): `{"error": "permission_denied", "message": "Permission CANCEL_ORDER required"}`
- 403 (strategy): `{"error": "strategy_unauthorized", "message": "User not authorized for strategy {id}"}`
- 404: `{"error": "not_found", "message": "Order {order_id} not found"}`
- 429: `{"error": "rate_limited", "message": "Rate limit exceeded", "retry_after": 60}`
- 502: `{"error": "broker_error", "message": "Broker error: {details}"}`
- 504: `{"error": "broker_timeout", "message": "Broker timeout - order may or may not be cancelled"}`

---

### POST /api/v1/orders/cancel-all [UPDATED v1.2]

**Authorization:** `Permission.CANCEL_ORDER` + strategy access check + session_version validation

**Strategy Scoping [NEW v1.2]:**
- Only cancels orders belonging to user's authorized strategies
- Orders from unauthorized strategies are silently excluded (not cancelled)
- Response includes `strategies_affected` list for audit clarity
- Admin users (VIEW_ALL_STRATEGIES) can cancel orders across all strategies

**Rate Limit:** 5 requests per 60 seconds per user (key: `cancel_all_orders:{user_id}`)

**Request:**
```json
{
    "symbol": "string (required)",
    "reason": "string (min 10 chars, required)",
    "requested_by": "user_id",
    "requested_at": "ISO8601 timestamp"
}
```

**Responses:**
- 200: `{"status": "cancelled", "symbol": "string", "cancelled_count": int, "order_ids": [...], "strategies_affected": [...]}`
- 400: `{"error": "invalid_request", "message": "..."}`
- 403: Permission/strategy errors (same as cancel single)
- 404: `{"error": "not_found", "message": "No pending orders found for {symbol} in authorized strategies"}`
- 429: `{"error": "rate_limited", "message": "Rate limit exceeded", "retry_after": 60}`
- 502/504: Broker errors (same format)

---

### POST /api/v1/positions/{symbol}/close

**Authorization:** `Permission.CLOSE_POSITION` + strategy access check + session_version validation

**Rate Limit:** 10 requests per 60 seconds per user (key: `close_position:{user_id}`)

**Request:**
```json
{
    "reason": "string (min 10 chars, required)",
    "requested_by": "user_id",
    "requested_at": "ISO8601 timestamp",
    "qty": "optional - partial close quantity"
}
```

**Responses:**
- 200: `{"status": "closing", "symbol": "string", "order_id": "string", "qty_to_close": decimal}`
- 400: `{"error": "invalid_request", "message": "..."}`
- 403: Permission/strategy errors
- 404: `{"error": "not_found", "message": "Position for {symbol} not found"}`
- 429: Rate limited
- 502/504: Broker errors

---

### POST /api/v1/positions/{symbol}/adjust [NEW v1.1]

**Authorization:** `Permission.CLOSE_POSITION` + strategy access check + session_version validation

**Rate Limit:** 10 requests per 60 seconds per user (key: `adjust_position:{user_id}`)

**Request:**
```json
{
    "target_qty": "decimal (required) - new target position quantity",
    "reason": "string (min 10 chars, required)",
    "requested_by": "user_id",
    "requested_at": "ISO8601 timestamp",
    "order_type": "market|limit (default: market)",
    "limit_price": "decimal (required if order_type=limit)"
}
```

**Responses:**
- 200: `{"status": "adjusting", "symbol": "string", "current_qty": decimal, "target_qty": decimal, "order_id": "string"}`
- 400: `{"error": "invalid_request", "message": "..."}`
- 403: Permission/strategy errors
- 404: `{"error": "not_found", "message": "Position for {symbol} not found"}`
- 429: Rate limited
- 502/504: Broker errors

---

### POST /api/v1/positions/flatten-all [UPDATED v1.2]

**Authorization:** `Permission.FLATTEN_ALL` + 2FA step-up verification (JWT-based) + session_version validation

**Strategy Scoping [NEW v1.2]:**
- Only flattens positions belonging to user's authorized strategies
- Positions from unauthorized strategies are silently excluded (not flattened)
- Response includes `strategies_affected` list for audit clarity
- Admin users (VIEW_ALL_STRATEGIES) flatten all positions across all strategies

**Rate Limit:** 1 request per 300 seconds (5 min) per user (key: `flatten_all:{user_id}`)

**2FA Verification [UPDATED v1.2]:**
- Accept raw ID Token (JWT) instead of plain JSON claims
- Gateway cryptographically verifies JWT signature via JWKS
- **Full JWT Claim Validation [NEW v1.2]:**
  - `iss` (issuer): Must match configured Auth0 domain (e.g., `https://your-tenant.auth0.com/`)
  - `aud` (audience): Must match configured client ID
  - `exp` (expiration): Token must not be expired
  - `nbf` (not before): Token must be valid now
  - `sub` (subject): **Must match `requested_by` user_id** (prevents token substitution attacks)
- Extracts and validates `amr` claim contains MFA method
- Extracts and validates `auth_time` is within 60 seconds
- Extracts `amr_method` for audit logging

**Request:**
```json
{
    "reason": "string (min 20 chars, required)",
    "requested_by": "user_id",
    "requested_at": "ISO8601 timestamp",
    "id_token": "string (JWT) - raw ID token from Auth0 step-up"
}
```

**Responses:**
- 200: `{"status": "flattening", "positions_closed": int, "orders_created": [...], "strategies_affected": [...]}`
- 400: `{"error": "invalid_request", "message": "..."}`
- 403 (permission): `{"error": "permission_denied", "message": "Permission FLATTEN_ALL required"}`
- 403 (2fa): `{"error": "mfa_required", "message": "MFA verification required. Please re-authenticate with MFA."}`
- 403 (2fa_expired): `{"error": "mfa_expired", "message": "MFA authentication expired. Please re-authenticate."}`
- 403 (2fa_invalid): `{"error": "mfa_invalid", "message": "Invalid MFA method. Ensure MFA is enabled on your account."}`
- 403 (2fa_sub_mismatch) [NEW v1.2]: `{"error": "token_mismatch", "message": "Token subject does not match requesting user"}`
- 429: `{"error": "rate_limited", "message": "Rate limit exceeded. Only 1 flatten per 5 minutes", "retry_after": 300}` + `Retry-After: 300` header
- 502/504: Broker errors

---

### GET /api/v1/orders/pending [UPDATED v1.3]

**Authorization:** `Permission.VIEW_TRADES` + **mandatory strategy scoping** + session_version validation

**Strategy Scoping [UPDATED v1.3]:**
- Results are **ALWAYS** restricted to user's authorized strategies (default behavior)
- If `strategy_id` param is provided AND user is not authorized → 403 `strategy_unauthorized`
- Admin users (VIEW_ALL_STRATEGIES) see all strategies
- **No data leakage:** unauthorized strategies are never included in results

**Query Parameters:**
- `strategy_id`: Optional - filter by specific strategy (must be in user's authorized list)
- `symbol`: Optional - filter by symbol
- `limit`: Default 100, max 1000
- `offset`: Default 0 (for pagination)
- `sort_by`: Default "created_at"
- `sort_order`: Default "desc"

**Responses:**
- 200:
```json
{
    "orders": [...],
    "total": int,
    "limit": int,
    "offset": int,
    "filtered_by_strategy": bool,
    "user_strategies": ["..."]
}
```
- 403 (strategy): `{"error": "strategy_unauthorized", "message": "User not authorized for strategy {id}"}`

---

## Implementation Pattern [UPDATED v1.4]

### Authentication & Authorization Chain

```python
from libs.platform.web_console_auth.permissions import has_permission, Permission
from libs.platform.web_console_auth.rate_limiter import RateLimiter  # [v1.4] Import from libs/
from libs.platform.web_console_auth.audit_logger import AuditLogger  # [v1.4] Import from libs/

@router.post("/orders/{order_id}/cancel")
async def cancel_order(
    order_id: str,
    request: CancelOrderRequest,
    user: AuthenticatedUser = Depends(get_authenticated_user),
    db_pool: Pool = Depends(get_db_pool),
    rate_limiter: RateLimiter = Depends(get_rate_limiter),
    audit_logger: AuditLogger = Depends(get_audit_logger),
) -> CancelOrderResponse:
    """Cancel order with full authorization chain.

    [UPDATED v1.4] Session validation done in get_authenticated_user (no redundant check).
    """

    # 1. [v1.4] Session version already validated in get_authenticated_user dependency
    # No redundant check needed here - GatewayAuthenticator handles it

    # 2. Permission check (via @require_permission or explicit)
    if not has_permission(user, Permission.CANCEL_ORDER):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail={"error": "permission_denied", "message": "Permission CANCEL_ORDER required"}
        )

    # 3. Rate limit check with retry-after header
    allowed, remaining = await rate_limiter.check_rate_limit(
        user.user_id, "cancel_order", max_requests=10, window_seconds=60
    )
    if not allowed:
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail={"error": "rate_limited", "message": "Rate limit exceeded", "retry_after": 60},
            headers={"Retry-After": "60"}
        )

    # 4. Fetch order, verify strategy access
    order = await get_order(db_pool, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail={"error": "not_found", "message": f"Order {order_id} not found"}
        )

    authorized_strategies = get_authorized_strategies(user)
    if order["strategy_id"] not in authorized_strategies:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail={"error": "strategy_unauthorized", "message": f"User not authorized for strategy {order['strategy_id']}"}
        )

    # 5. Audit log BEFORE execution
    await audit_logger.log_action(
        user_id=user.user_id,
        action="cancel_order",
        resource_type="order",
        resource_id=order_id,
        outcome="pending",
        details={"reason": request.reason, "strategy_id": order["strategy_id"]},
    )

    # 6. Execute via AlpacaExecutor
    try:
        result = await alpaca_executor.cancel_order(order["broker_order_id"])
        outcome = "success" if result.success else "failed"
    except TimeoutError:
        outcome = "timeout"
        await audit_logger.log_action(
            user_id=user.user_id,
            action="cancel_order",
            resource_type="order",
            resource_id=order_id,
            outcome="timeout",
            details={"reason": request.reason, "error": "Broker timeout"},
        )
        raise HTTPException(
            status_code=status.HTTP_504_GATEWAY_TIMEOUT,
            detail={"error": "broker_timeout", "message": "Broker timeout - order may or may not be cancelled"}
        )
    except Exception as e:
        outcome = "failed"
        await audit_logger.log_action(
            user_id=user.user_id,
            action="cancel_order",
            resource_type="order",
            resource_id=order_id,
            outcome="failed",
            details={"reason": request.reason, "error": str(e)},
        )
        raise HTTPException(
            status_code=status.HTTP_502_BAD_GATEWAY,
            detail={"error": "broker_error", "message": f"Broker error: {str(e)}"}
        )

    # 7. Audit log AFTER execution
    await audit_logger.log_action(
        user_id=user.user_id,
        action="cancel_order",
        resource_type="order",
        resource_id=order_id,
        outcome=outcome,
        details={"reason": request.reason, "strategy_id": order["strategy_id"]},
    )

    return CancelOrderResponse(status="cancelled", order_id=order_id, cancelled_at=datetime.now(UTC))
```

### 2FA Verification Pattern (JWT-based) [UPDATED v1.2]

```python
from libs.platform.web_console_auth.jwks_validator import JWKSValidator  # [v1.7] Moved to libs/
import os

# Configuration from environment
AUTH0_DOMAIN = os.getenv("AUTH0_DOMAIN", "https://your-tenant.auth0.com/")
AUTH0_CLIENT_ID = os.getenv("AUTH0_CLIENT_ID", "")

async def verify_2fa_jwt(
    id_token: str,
    requesting_user_id: str,  # The user_id from X-User-ID header
    action: str,
) -> tuple[bool, str | None, str | None]:
    """Verify 2FA via full JWT cryptographic validation.

    Returns (valid, error_code, amr_method).

    [UPDATED v1.2] Full claim validation:
    - iss/aud/exp/nbf standard claims
    - sub binding to requesting user (prevents token substitution)
    - amr for MFA method
    - auth_time for freshness
    """
    jwks_validator = JWKSValidator()

    # 1. Cryptographically verify JWT signature + standard claims
    try:
        claims = await jwks_validator.validate_id_token(
            id_token,
            audience=AUTH0_CLIENT_ID,
            issuer=AUTH0_DOMAIN,
        )
    except jwt.ExpiredSignatureError:
        return False, "token_expired", None
    except jwt.InvalidIssuerError:
        return False, "invalid_issuer", None
    except jwt.InvalidAudienceError:
        return False, "invalid_audience", None
    except jwt.ImmatureSignatureError:  # nbf check
        return False, "token_not_yet_valid", None
    except Exception as e:
        return False, "invalid_jwt", None

    # 2. [NEW v1.2] Bind token subject to requesting user (prevents token substitution)
    token_sub = claims.get("sub")
    if token_sub != requesting_user_id:
        return False, "subject_mismatch", None

    # 3. Verify amr claim contains MFA method
    amr = claims.get("amr", [])
    mfa_methods = {"mfa", "otp", "sms", "push", "webauthn", "hwk"}
    if not any(method in amr for method in mfa_methods):
        return False, "mfa_not_performed", None

    # 4. Verify auth_time is recent (within 60s)
    auth_time = claims.get("auth_time")
    if not auth_time:
        return False, "missing_auth_time", None

    auth_dt = datetime.fromtimestamp(auth_time, tz=UTC)
    age_seconds = (datetime.now(UTC) - auth_dt).total_seconds()
    if age_seconds > 60:
        return False, "auth_expired", None

    # 5. Extract amr_method for audit
    amr_method = next((m for m in ["webauthn", "hwk", "otp", "sms", "push", "mfa"] if m in amr), None)

    return True, None, amr_method
```

### Rate Limiter with Fallback [UPDATED v1.3]

**Fallback Contract [NEW v1.3]:**
When Redis is unavailable, rate limiting fails closed (deny). This must be surfaced as a proper HTTP response:

| Scenario | HTTP Code | Response | Headers |
|----------|-----------|----------|---------|
| Normal rate limit exceeded | 429 | `{"error": "rate_limited", "message": "...", "retry_after": N}` | `Retry-After: N` |
| Redis unavailable (fallback deny) | 429 | `{"error": "rate_limited", "message": "Rate limit check failed, please retry", "retry_after": 60}` | `Retry-After: 60` |

```python
async def check_rate_limit_with_fallback(
    rate_limiter: RateLimiter,
    user_id: str,
    action: str,
    max_requests: int,
    window_seconds: int,
) -> tuple[bool, int]:
    """Check rate limit with Redis fallback behavior.

    Returns (allowed, remaining) tuple.
    On Redis failure: returns (False, 0) with logged warning.
    Caller MUST return 429 with Retry-After header on denial.
    """
    try:
        return await rate_limiter.check_rate_limit(
            user_id, action, max_requests, window_seconds
        )
    except Exception as e:
        # Fallback behavior: deny (fail-closed) per task doc
        logger.warning(
            "rate_limit_fallback",
            extra={"action": action, "user_id": user_id, "error": str(e)}
        )
        return False, 0  # Caller returns 429 with retry_after=60

def raise_rate_limit_error(retry_after: int = 60) -> NoReturn:
    """Raise consistent rate limit error with Retry-After header."""
    raise HTTPException(
        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
        detail={"error": "rate_limited", "message": "Rate limit exceeded", "retry_after": retry_after},
        headers={"Retry-After": str(retry_after)}
    )
```

---

## Test Coverage Requirements (>90%) [UPDATED v1.3]

### Unit Tests Matrix

| Test Category | Test Cases |
|--------------|------------|
| Permission checks | viewer denied cancel, operator allowed cancel, admin allowed all |
| Rate limiting | under limit passes, at limit blocked, retry-after header present on ALL endpoints |
| Strategy auth | authorized strategy passes, unauthorized denied with correct error |
| Session version | valid version passes, stale version denied, missing version denied |
| Input validation | reason too short (400), missing required fields (400) |
| 2FA verification | valid JWT passes, expired auth denied, missing amr denied, invalid JWT denied |

### Header Validation Tests [UPDATED v1.3]

| Header | Test Cases |
|--------|------------|
| Authorization | missing (401), invalid format (401), expired token (401), invalid signature (401) |
| X-User-ID | missing (400), empty (400), mismatch with JWT sub (403 subject_mismatch) |
| X-Request-ID | missing (400), invalid UUID format (400) |
| X-Session-Version | missing (400), non-integer (400), stale version (403) |

### Service Token (Authorization JWT) Validation Tests [UPDATED v1.5]

| Claim | Test Cases | Expected HTTP |
|-------|------------|---------------|
| Signature | invalid signature rejected | 401 invalid_signature |
| iss (issuer) | wrong issuer rejected | 403 invalid_issuer |
| aud (audience) | wrong audience rejected | 403 invalid_audience |
| exp (expiration) | expired token rejected | 401 token_expired |
| nbf (not before) | future nbf rejected | 401 token_not_valid_yet |
| sub (subject) | sub != X-User-ID rejected | 403 subject_mismatch |
| jti | missing jti rejected | 401 invalid_token |
| revoked | revoked token rejected | 401 token_revoked |
| replayed [NEW v1.5] | same token used twice rejected | 401 token_replayed |

### Replay Attack Prevention Tests [NEW v1.5]

| Test Case | Expected |
|-----------|----------|
| First use of valid token | 200 (succeeds) |
| Immediate reuse of same token | 401 token_replayed |
| Reuse after original request completes | 401 token_replayed |
| Different token with same user | 200 (succeeds - different JTI) |
| JTI Redis key expires after token TTL | Key auto-cleaned from Redis |

### 2FA JWT Claim Validation Tests (Flatten-All only)

| Claim | Test Cases | Expected HTTP |
|-------|------------|---------------|
| amr | missing amr rejected | 403 mfa_required |
| amr | wrong method (pwd only) rejected | 403 mfa_invalid |
| auth_time | missing rejected | 403 mfa_required |
| auth_time | >60s old rejected | 403 mfa_expired |
| sub | sub != requested_by rejected | 403 token_mismatch |

### Integration Tests Matrix

| Test Category | Test Cases |
|--------------|------------|
| Cancel order flow | success, order not found, already cancelled, broker timeout (504), broker error (502) |
| Cancel all orders | success, no orders found, partial failure, strategy scoping enforced |
| Close position | success, position not found, partial close |
| Adjust position | success, position not found, invalid target_qty |
| Flatten all | success with 2FA, denied without 2FA, 2FA expired, strategy scoping enforced |
| Pending orders | pagination, strategy filter, sorting, **unauthorized strategy_id returns 403**, **default scoping to authorized strategies** |

### Pending Orders Strategy Scoping Tests [NEW v1.3]

| Test Case | Expected |
|-----------|----------|
| No strategy_id param (viewer) | Returns only orders from user's authorized strategies |
| No strategy_id param (admin) | Returns all orders (VIEW_ALL_STRATEGIES) |
| strategy_id in user's list | Returns orders filtered to that strategy |
| strategy_id NOT in user's list | 403 strategy_unauthorized |
| strategy_id for admin | Returns orders for any strategy |

### Rate Limit Fallback Tests [NEW v1.3]

| Test Case | Expected |
|-----------|----------|
| Redis available, under limit | 200 (proceed) |
| Redis available, over limit | 429 with Retry-After header |
| Redis unavailable (connection error) | 429 with Retry-After: 60 (fail-closed) |
| Redis timeout | 429 with Retry-After: 60 (fail-closed) |

### Edge Case Tests [UPDATED v1.4]

| Test Category | Test Cases |
|--------------|------------|
| Broker errors | timeout handling (504), rejection (502), partial success |
| Redis fallback | Redis down - returns 429 with Retry-After (not 500) |
| Audit logging | before/after records, failure logging, amr_method captured |
| Session | stale session denied, session_version mismatch |
| 2FA | expired JWT, invalid signature, missing amr, wrong amr method |
| Concurrency | concurrent cancel requests (idempotency) |
| Data leakage | unauthorized strategies never returned in pending orders |

### Cross-Service Isolation Tests [NEW v1.4]

| Test Case | Expected |
|-----------|----------|
| No imports from apps.web_console in apps.execution_gateway | Lint check passes |
| GatewayAuthenticator uses only libs/ dependencies | All imports from libs/web_console_auth/ |
| Service runs independently | execution_gateway starts without web_console |

**Implementation:** Add import linting rule to CI:
```python
# tests/apps/execution_gateway/test_import_isolation.py
def test_no_web_console_imports():
    """Verify execution_gateway doesn't import from web_console."""
    import ast
    from pathlib import Path

    gateway_path = Path("apps/execution_gateway")
    for py_file in gateway_path.rglob("*.py"):
        tree = ast.parse(py_file.read_text())
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    assert not alias.name.startswith("apps.web_console"), \
                        f"Forbidden import: {alias.name} in {py_file}"
            if isinstance(node, ast.ImportFrom):
                if node.module and node.module.startswith("apps.web_console"):
                    raise AssertionError(f"Forbidden import: {node.module} in {py_file}")
```

---

## Acceptance Criteria [UPDATED v1.8]

**Architecture (No Cross-App Dependencies):**
- [ ] RateLimiter moved to `libs/web_console_auth/rate_limiter.py`
- [ ] SessionValidator moved to `libs/web_console_auth/session_validation.py`
- [ ] AuditLogger moved to `libs/web_console_auth/audit_logger.py`
- [ ] JWKSValidator moved to `libs/web_console_auth/jwks_validator.py` [NEW v1.8]
- [ ] GatewayAuthenticator in `libs/web_console_auth/gateway_auth.py` with Redis client param [v1.8]
- [ ] Cross-service isolation test passes (no imports from apps.web_console)

**Authentication & Authorization:**
- [ ] Service-to-service JWT authentication via GatewayAuthenticator
- [ ] Full JWT claim validation (iss, aud, exp, nbf, sub, jti) with proper error mapping
- [ ] Subject binding: JWT `sub` must match `X-User-ID` header
- [ ] **One-time-use JTI enforcement** [NEW v1.5] - Redis SETNX stores JTI on first use, rejects duplicates
- [ ] jti validation + Redis revocation check
- [ ] Session version validation (single check in GatewayAuthenticator, no redundancy)
- [ ] Cross-service headers enforced (Authorization, X-User-ID, X-Request-ID, X-Session-Version)
- [ ] Role/strategies fetched from DB (not JWT claims)

**Endpoints:**
- [ ] All 6 endpoints implemented with server-side authorization
- [ ] Cancel-all-for-symbol endpoint (POST /orders/cancel-all) with strategy scoping
- [ ] Force position adjustment endpoint (POST /positions/{symbol}/adjust)
- [ ] Pending orders endpoint with mandatory strategy scoping (no data leakage)
- [ ] Flatten-all with 2FA JWT verification and amr_method audit

**Rate Limiting:**
- [ ] Rate limiting with retry-after headers on all endpoints
- [ ] Redis fallback returns 429 with Retry-After (fail-closed, not 500)

**Error Handling:**
- [ ] Complete JWT error mapping (11 distinct error codes including signature, nbf, jti, revoked, **replayed**)
- [ ] Proper HTTP codes (400, 401, 403, 404, 429, 502, 504)
- [ ] Consistent error response format with `retry_after` where applicable

**Audit & Logging:**
- [ ] Comprehensive audit logging (before + after with failure reasons)
- [ ] 2FA amr_method captured in audit log
- [ ] Strategy authorization on all queries (sourced from DB)

**Testing:**
- [ ] >90% test coverage with failure mode coverage
- [ ] Service token (Authorization JWT) validation tests (all 9 error types including replayed)
- [ ] **Replay attack prevention tests** [NEW v1.5] - same token twice rejected
- [ ] 2FA JWT claim validation tests
- [ ] Pending orders strategy scoping tests (unauthorized returns 403)
- [ ] Rate limit fallback tests (Redis down → 429)
- [ ] Cross-service isolation tests (lint check)
- [ ] All tests passing

**Integration:**
- [ ] Integration with existing AlpacaExecutor for actual execution
- [ ] apps/execution_gateway imports only from libs/ (verified by test)
