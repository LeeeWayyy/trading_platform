# P4T3 T6.1b: Admin User Management UI - Implementation Plan

**Task ID:** P4T3/T6.1b
**Component:** T6.1b-AdminUserMgmt
**Author:** Claude Code
**Created:** 2025-12-10
**Status:** Planning
**Version:** 1.2 (Revision after v1.1 Gemini/Codex review)

---

## Review History

| Version | Date | Reviewers | Status | Key Changes |
|---------|------|-----------|--------|-------------|
| v1.0 | 2025-12-10 | Gemini, Codex | CHANGES_REQUIRED | Initial plan |
| v1.1 | 2025-12-10 | Gemini, Codex | CHANGES_REQUIRED | Added bulk operations, denied-attempt audit logging |
| v1.2 | 2025-12-10 | - | Pending Review | Fixed session invalidation (explicit for grant), complete bulk strategy (grant+revoke), page-level audit logging, DB pool pattern clarification, comprehensive tests |

---

## 1. Overview

### 1.1 Purpose
Implement a Streamlit-based Admin User Management UI that allows administrators to:
- View and search all provisioned users with their roles
- Change user roles with confirmation dialogs (single and bulk)
- Assign/revoke strategy access per user (with confirmation for bulk)
- **[v1.1] Bulk operations with double-confirmation** per task spec
- All operations with CSRF protection, audit logging (including denied attempts), and session invalidation

### 1.2 Dependencies
- **T6.1a Auth/RBAC Core** (COMPLETE - committed cf69c2e)
  - `permissions.py` - RBAC roles and permission checks
  - `audit_log.py` - Audit logging infrastructure
  - `session_invalidation.py` - Session version management
  - Database migrations 0005/0006/0007 applied

### 1.3 Deliverables
1. **CSRF Protection Component** - `apps/web_console/components/csrf_protection.py`
2. **User Role Editor Component** - `apps/web_console/components/user_role_editor.py`
3. **Strategy Assignment Component** - `apps/web_console/components/strategy_assignment.py`
4. **Bulk Operations Component** - `apps/web_console/components/bulk_operations.py` **[v1.1 NEW]**
5. **Admin Users Page** - `apps/web_console/pages/admin_users.py`
6. **User Management Service** - `apps/web_console/services/user_management.py`
7. **Test Suite** - Comprehensive tests including denied-attempt logging **[v1.1 EXPANDED]**

---

## 2. Architecture Design

### 2.1 Component Hierarchy

```
apps/web_console/
├── pages/
│   └── admin_users.py          # Main admin page (Streamlit multipage)
├── components/
│   ├── csrf_protection.py      # CSRF token generation/validation
│   ├── user_role_editor.py     # Role change form with confirmation
│   ├── strategy_assignment.py  # Strategy grant/revoke UI
│   └── bulk_operations.py      # [v1.1 NEW] Bulk role/strategy ops with double-confirm
└── services/
    └── user_management.py      # Database operations with per-request pools
```

### 2.2 Data Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                     ADMIN USER MANAGEMENT FLOW                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. Page Load (admin_users.py)                                      │
│     └─► @require_permission(MANAGE_USERS) decorator                 │
│         ├─ Validate session via session_manager                     │
│         ├─ Check role has MANAGE_USERS permission                   │
│         └─ Render page or st.stop() on failure                      │
│                                                                      │
│  2. User List Display                                               │
│     └─► user_management.list_users(db_pool)                        │
│         ├─ Query user_roles table                                   │
│         ├─ Left join user_strategy_access for strategy counts       │
│         └─ Return list of UserWithStrategies                        │
│                                                                      │
│  3. Role Change (user_role_editor.py)                               │
│     └─► st.form with CSRF token                                    │
│         ├─ Verify CSRF token                                        │
│         ├─ Confirmation dialog (double-click prevention)            │
│         ├─ Call user_management.set_role()                          │
│         │   ├─ Update user_roles table                              │
│         │   ├─ Increment session_version (invalidate sessions)      │
│         │   └─ Audit log via AuditLogger.log_admin_change()        │
│         └─ Rotate CSRF token after success                          │
│                                                                      │
│  4. Strategy Assignment (strategy_assignment.py)                    │
│     └─► st.multiselect for strategies                              │
│         ├─ Grant: INSERT INTO user_strategy_access                  │
│         ├─ Revoke: DELETE FROM user_strategy_access                 │
│         ├─ Session invalidation (trigger fires automatically)       │
│         └─ Audit log for each grant/revoke                          │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.3 Security Controls

| Control | Implementation |
|---------|----------------|
| **RBAC** | `has_permission()` check at page level with `AuditLogger` on denial |
| **CSRF** | Token in session state, verified before form submission |
| **CSRF Failure Logging** | CSRF failures logged via `AuditLogger` (not just logger) |
| **Session Invalidation** | **[v1.2]** Explicit `session_version++` on ALL mutations (role change, grant, revoke) - NO trigger dependency |
| **Audit Trail** | All actions logged via `AuditLogger.log_admin_change()` for success, `log_action()` for denied/failed |
| **Page-Level Denial Audit** | **[v1.2]** Permission denied at page level logged via `AuditLogger.log_action()` |
| **Double Confirmation** | Confirmation dialog for destructive single-user operations |
| **Bulk Double-Confirm** | Two-step confirmation (preview + type CONFIRM) for ALL bulk operations |
| **DB Pool Pattern** | **[v1.2]** Pool created at app startup, passed to components; sync wrappers use `ThreadPoolExecutor` with fresh event loops |

---

## 3. Implementation Details

### 3.1 CSRF Protection (`csrf_protection.py`)

```python
"""CSRF protection for Streamlit forms.

Uses secrets.token_urlsafe for cryptographic tokens.
Stored in st.session_state, verified before mutations.
"""

import secrets
import streamlit as st

CSRF_TOKEN_KEY = "_csrf_token"

def generate_csrf_token() -> str:
    """Generate and store CSRF token in session state."""
    if CSRF_TOKEN_KEY not in st.session_state:
        st.session_state[CSRF_TOKEN_KEY] = secrets.token_urlsafe(32)
    return st.session_state[CSRF_TOKEN_KEY]

def verify_csrf_token(submitted_token: str) -> bool:
    """Verify submitted token matches session token."""
    expected = st.session_state.get(CSRF_TOKEN_KEY)
    if not expected or not submitted_token:
        return False
    return secrets.compare_digest(expected, submitted_token)

def rotate_csrf_token() -> str:
    """Rotate token after successful mutation."""
    st.session_state[CSRF_TOKEN_KEY] = secrets.token_urlsafe(32)
    return st.session_state[CSRF_TOKEN_KEY]

def get_csrf_input() -> str:
    """Get current CSRF token for form embedding."""
    return generate_csrf_token()
```

### 3.2 User Management Service (`user_management.py`)

**[v1.1 ENHANCED]** - Added denied-attempt audit logging for ALL failure cases, per-request DB pool pattern.

```python
"""Database operations for user management.

[v1.1] All failure paths now emit audit log entries for denied attempts.
[v1.1] Uses per-request DB pool pattern for thread safety.

Provides async functions for:
- Listing users with strategy counts
- Changing user roles (with denied-attempt logging)
- Granting/revoking strategy access (with denied-attempt logging)
- Listing available strategies
- Bulk operations
"""

from __future__ import annotations
import logging
from dataclasses import dataclass
from typing import Any

from apps.web_console.auth.audit_log import AuditLogger
from apps.web_console.auth.session_invalidation import invalidate_user_sessions

logger = logging.getLogger(__name__)

@dataclass
class UserInfo:
    """User info with role and strategy count."""
    user_id: str
    role: str
    session_version: int
    updated_at: str
    updated_by: str | None
    strategy_count: int

@dataclass
class StrategyInfo:
    """Strategy info for assignment UI."""
    strategy_id: str
    name: str
    description: str | None

async def list_users(db_pool: Any) -> list[UserInfo]:
    """List all users with their strategy counts."""
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("""
            SELECT
                ur.user_id,
                ur.role,
                ur.session_version,
                ur.updated_at,
                ur.updated_by,
                COUNT(usa.strategy_id) as strategy_count
            FROM user_roles ur
            LEFT JOIN user_strategy_access usa ON ur.user_id = usa.user_id
            GROUP BY ur.user_id, ur.role, ur.session_version, ur.updated_at, ur.updated_by
            ORDER BY ur.role, ur.user_id
        """)
        return [UserInfo(
            user_id=r["user_id"],
            role=r["role"],
            session_version=r["session_version"],
            updated_at=str(r["updated_at"]),
            updated_by=r["updated_by"],
            strategy_count=r["strategy_count"],
        ) for r in rows]

async def change_user_role(
    db_pool: Any,
    user_id: str,
    new_role: str,
    admin_user_id: str,
    audit_logger: AuditLogger,
    reason: str,
) -> tuple[bool, str]:
    """Change user role with session invalidation and audit logging.

    [v1.1] Now logs DENIED attempts to audit trail, not just successes.
    Returns (success, message).
    """
    valid_roles = {"viewer", "operator", "admin"}
    if new_role not in valid_roles:
        # [v1.1] Log denied attempt
        await audit_logger.log_action(
            user_id=admin_user_id,
            action="role_change_denied",
            resource_type="user",
            resource_id=user_id,
            outcome="denied",
            details={"reason": "invalid_role", "attempted_role": new_role},
        )
        return False, f"Invalid role: {new_role}"

    try:
        async with db_pool.acquire() as conn:
            # Get old role for audit
            old_row = await conn.fetchrow(
                "SELECT role FROM user_roles WHERE user_id = $1", user_id
            )
            if not old_row:
                # [v1.1] Log denied attempt
                await audit_logger.log_action(
                    user_id=admin_user_id,
                    action="role_change_denied",
                    resource_type="user",
                    resource_id=user_id,
                    outcome="denied",
                    details={"reason": "user_not_found"},
                )
                return False, f"User not found: {user_id}"

            old_role = old_row["role"]
            if old_role == new_role:
                # [v1.1] Log denied (no-op)
                await audit_logger.log_action(
                    user_id=admin_user_id,
                    action="role_change_denied",
                    resource_type="user",
                    resource_id=user_id,
                    outcome="denied",
                    details={"reason": "no_change", "current_role": old_role},
                )
                return False, f"User already has role: {new_role}"

            # Update role and increment session_version
            await conn.execute("""
                UPDATE user_roles
                SET role = $1,
                    updated_by = $2,
                    updated_at = NOW(),
                    session_version = session_version + 1
                WHERE user_id = $3
            """, new_role, admin_user_id, user_id)

        # Audit log success
        await audit_logger.log_admin_change(
            admin_user_id=admin_user_id,
            action="role_change",
            target_user_id=user_id,
            details={
                "old_role": old_role,
                "new_role": new_role,
                "reason": reason,
            },
        )

        logger.info(
            "role_changed",
            extra={
                "user_id": user_id,
                "old_role": old_role,
                "new_role": new_role,
                "by": admin_user_id,
            }
        )

        return True, f"Role changed from {old_role} to {new_role}"

    except Exception as e:
        # [v1.1] Log failed attempt
        await audit_logger.log_action(
            user_id=admin_user_id,
            action="role_change_failed",
            resource_type="user",
            resource_id=user_id,
            outcome="failed",
            details={"reason": "db_error", "error": str(e)},
        )
        logger.exception("role_change_failed", extra={"user_id": user_id, "error": str(e)})
        return False, f"Database error: {str(e)}"

async def list_strategies(db_pool: Any) -> list[StrategyInfo]:
    """List all available strategies."""
    async with db_pool.acquire() as conn:
        rows = await conn.fetch(
            "SELECT strategy_id, name, description FROM strategies ORDER BY strategy_id"
        )
        return [StrategyInfo(
            strategy_id=r["strategy_id"],
            name=r["name"],
            description=r["description"],
        ) for r in rows]

async def get_user_strategies(db_pool: Any, user_id: str) -> list[str]:
    """Get list of strategy IDs assigned to user."""
    async with db_pool.acquire() as conn:
        rows = await conn.fetch(
            "SELECT strategy_id FROM user_strategy_access WHERE user_id = $1",
            user_id,
        )
        return [r["strategy_id"] for r in rows]

async def grant_strategy(
    db_pool: Any,
    user_id: str,
    strategy_id: str,
    admin_user_id: str,
    audit_logger: AuditLogger,
) -> tuple[bool, str]:
    """Grant strategy access to user.

    [v1.2] Explicitly increments session_version (no DB trigger exists).
    Logs DENIED attempts to audit trail.
    """
    try:
        async with db_pool.acquire() as conn:
            # Check if already granted
            existing = await conn.fetchval(
                "SELECT 1 FROM user_strategy_access WHERE user_id = $1 AND strategy_id = $2",
                user_id, strategy_id,
            )
            if existing:
                await audit_logger.log_action(
                    user_id=admin_user_id,
                    action="strategy_grant_denied",
                    resource_type="user_strategy",
                    resource_id=f"{user_id}:{strategy_id}",
                    outcome="denied",
                    details={"reason": "already_granted"},
                )
                return False, f"Strategy {strategy_id} already granted"

            # Insert grant
            await conn.execute("""
                INSERT INTO user_strategy_access (user_id, strategy_id, granted_by)
                VALUES ($1, $2, $3)
            """, user_id, strategy_id, admin_user_id)

            # [v1.2 FIX] Explicitly increment session_version (no trigger exists)
            await conn.execute("""
                UPDATE user_roles
                SET session_version = session_version + 1,
                    updated_at = NOW()
                WHERE user_id = $1
            """, user_id)

        await audit_logger.log_admin_change(
            admin_user_id=admin_user_id,
            action="strategy_grant",
            target_user_id=user_id,
            details={"strategy_id": strategy_id},
        )

        return True, f"Granted {strategy_id}"

    except Exception as e:
        await audit_logger.log_action(
            user_id=admin_user_id,
            action="strategy_grant_failed",
            resource_type="user_strategy",
            resource_id=f"{user_id}:{strategy_id}",
            outcome="failed",
            details={"reason": "db_error", "error": str(e)},
        )
        logger.exception("grant_strategy_failed", extra={"error": str(e)})
        return False, f"Error: {str(e)}"

async def revoke_strategy(
    db_pool: Any,
    user_id: str,
    strategy_id: str,
    admin_user_id: str,
    audit_logger: AuditLogger,
) -> tuple[bool, str]:
    """Revoke strategy access from user.

    [v1.2] Explicitly increments session_version (no DB trigger exists).
    Logs DENIED attempts to audit trail.
    """
    try:
        async with db_pool.acquire() as conn:
            result = await conn.execute("""
                DELETE FROM user_strategy_access
                WHERE user_id = $1 AND strategy_id = $2
            """, user_id, strategy_id)

            # Check if any rows deleted
            if result == "DELETE 0":
                await audit_logger.log_action(
                    user_id=admin_user_id,
                    action="strategy_revoke_denied",
                    resource_type="user_strategy",
                    resource_id=f"{user_id}:{strategy_id}",
                    outcome="denied",
                    details={"reason": "not_assigned"},
                )
                return False, f"Strategy {strategy_id} not assigned"

            # [v1.2] Explicitly increment session_version (no DB trigger exists)
            await conn.execute("""
                UPDATE user_roles
                SET session_version = session_version + 1,
                    updated_at = NOW()
                WHERE user_id = $1
            """, user_id)

        await audit_logger.log_admin_change(
            admin_user_id=admin_user_id,
            action="strategy_revoke",
            target_user_id=user_id,
            details={"strategy_id": strategy_id},
        )

        return True, f"Revoked {strategy_id}"

    except Exception as e:
        await audit_logger.log_action(
            user_id=admin_user_id,
            action="strategy_revoke_failed",
            resource_type="user_strategy",
            resource_id=f"{user_id}:{strategy_id}",
            outcome="failed",
            details={"reason": "db_error", "error": str(e)},
        )
        logger.exception("revoke_strategy_failed", extra={"error": str(e)})
        return False, f"Error: {str(e)}"

# [v1.2] Bulk operations - supports role changes, strategy grants AND revokes
async def bulk_change_roles(
    db_pool: Any,
    user_ids: list[str],
    new_role: str,
    admin_user_id: str,
    audit_logger: AuditLogger,
    reason: str,
) -> dict[str, tuple[bool, str]]:
    """Change roles for multiple users.

    Returns dict mapping user_id -> (success, message).
    Each operation is independent; failures don't affect other users.
    """
    results = {}
    for user_id in user_ids:
        success, msg = await change_user_role(
            db_pool, user_id, new_role, admin_user_id, audit_logger, reason
        )
        results[user_id] = (success, msg)
    return results

async def bulk_grant_strategy(
    db_pool: Any,
    user_ids: list[str],
    strategy_id: str,
    admin_user_id: str,
    audit_logger: AuditLogger,
) -> dict[str, tuple[bool, str]]:
    """Grant strategy to multiple users.

    Returns dict mapping user_id -> (success, message).
    """
    results = {}
    for user_id in user_ids:
        success, msg = await grant_strategy(
            db_pool, user_id, strategy_id, admin_user_id, audit_logger
        )
        results[user_id] = (success, msg)
    return results

# [v1.2 NEW] Bulk strategy revoke
async def bulk_revoke_strategy(
    db_pool: Any,
    user_ids: list[str],
    strategy_id: str,
    admin_user_id: str,
    audit_logger: AuditLogger,
) -> dict[str, tuple[bool, str]]:
    """Revoke strategy from multiple users.

    Returns dict mapping user_id -> (success, message).
    """
    results = {}
    for user_id in user_ids:
        success, msg = await revoke_strategy(
            db_pool, user_id, strategy_id, admin_user_id, audit_logger
        )
        results[user_id] = (success, msg)
    return results
```

### 3.3 User Role Editor Component (`user_role_editor.py`)

**[v1.1 ENHANCED]** - CSRF failures now logged to audit trail via AuditLogger.

```python
"""User role editor component with CSRF protection and confirmation.

[v1.1] CSRF failures logged to audit trail, not just logger.
[v1.1] Per-request DB pool pattern for thread safety.
"""

from __future__ import annotations
import asyncio
import logging
from typing import Any

import streamlit as st

from apps.web_console.components.csrf_protection import (
    generate_csrf_token,
    verify_csrf_token,
    rotate_csrf_token,
)
from apps.web_console.services.user_management import change_user_role

logger = logging.getLogger(__name__)

def render_role_editor(
    user_id: str,
    current_role: str,
    admin_user_id: str,
    db_pool: Any,
    audit_logger: Any,
) -> None:
    """Render role editor form for a single user."""

    # State keys for this user
    confirm_key = f"confirm_role_{user_id}"

    st.subheader(f"Change Role: {user_id}")
    st.caption(f"Current role: **{current_role}**")

    csrf_token = generate_csrf_token()

    with st.form(f"role_form_{user_id}"):
        new_role = st.selectbox(
            "New Role",
            ["viewer", "operator", "admin"],
            index=["viewer", "operator", "admin"].index(current_role),
            key=f"role_select_{user_id}",
        )

        reason = st.text_area(
            "Reason for change (required)",
            placeholder="Enter justification for role change...",
            key=f"role_reason_{user_id}",
        )

        # Hidden CSRF token (use password type to hide)
        submitted_csrf = st.text_input(
            "csrf",
            value=csrf_token,
            type="password",
            label_visibility="hidden",
            key=f"csrf_{user_id}",
        )

        submitted = st.form_submit_button("Change Role", type="primary")

        if submitted:
            # Verify CSRF
            if not verify_csrf_token(submitted_csrf):
                st.error("Invalid form submission. Please refresh and try again.")
                # [v1.1] Log CSRF failure to audit trail
                _log_csrf_failure_sync(
                    audit_logger,
                    admin_user_id,
                    "role_change",
                    user_id,
                )
                rotate_csrf_token()  # [v1.1] Rotate after failure too
                return

            # Validate reason
            if not reason or len(reason.strip()) < 10:
                st.error("Reason must be at least 10 characters.")
                return

            # Check if role actually changed
            if new_role == current_role:
                st.warning("No change - user already has this role.")
                return

            # Set confirmation pending
            st.session_state[confirm_key] = {
                "new_role": new_role,
                "reason": reason.strip(),
            }
            st.rerun()

    # Confirmation dialog
    if st.session_state.get(confirm_key):
        pending = st.session_state[confirm_key]
        st.warning(
            f"**Confirm Role Change**\n\n"
            f"User: {user_id}\n\n"
            f"From: {current_role} -> To: {pending['new_role']}\n\n"
            f"This will invalidate all active sessions for this user."
        )

        col1, col2 = st.columns(2)
        with col1:
            if st.button("Confirm", key=f"confirm_btn_{user_id}", type="primary"):
                # Execute role change
                success, message = _execute_role_change_sync(
                    db_pool=db_pool,
                    user_id=user_id,
                    new_role=pending["new_role"],
                    admin_user_id=admin_user_id,
                    audit_logger=audit_logger,
                    reason=pending["reason"],
                )

                if success:
                    st.success(message)
                    rotate_csrf_token()
                else:
                    st.error(message)

                del st.session_state[confirm_key]
                st.rerun()

        with col2:
            if st.button("Cancel", key=f"cancel_btn_{user_id}"):
                del st.session_state[confirm_key]
                st.rerun()


def _log_csrf_failure_sync(
    audit_logger: Any,
    admin_user_id: str,
    action: str,
    target_user_id: str,
) -> None:
    """[v1.1] Log CSRF failure to audit trail (sync wrapper)."""
    import concurrent.futures

    async def _log():
        await audit_logger.log_action(
            user_id=admin_user_id,
            action=f"{action}_csrf_failed",
            resource_type="user",
            resource_id=target_user_id,
            outcome="denied",
            details={"reason": "csrf_validation_failed"},
        )

    try:
        loop = asyncio.get_running_loop()
        with concurrent.futures.ThreadPoolExecutor() as pool:
            pool.submit(asyncio.run, _log()).result(timeout=5.0)
    except RuntimeError:
        asyncio.run(_log())


def _execute_role_change_sync(
    db_pool: Any,
    user_id: str,
    new_role: str,
    admin_user_id: str,
    audit_logger: Any,
    reason: str,
) -> tuple[bool, str]:
    """Sync wrapper for change_user_role.

    [v1.1] Uses per-request pattern - creates fresh pool in thread context.
    """
    import concurrent.futures

    async def _async_change():
        # [v1.1] For thread safety, we use the passed pool which should be
        # created fresh per-request by the caller (admin_users.py)
        return await change_user_role(
            db_pool=db_pool,
            user_id=user_id,
            new_role=new_role,
            admin_user_id=admin_user_id,
            audit_logger=audit_logger,
            reason=reason,
        )

    try:
        loop = asyncio.get_running_loop()
        with concurrent.futures.ThreadPoolExecutor() as pool:
            future = pool.submit(asyncio.run, _async_change())
            return future.result(timeout=10.0)
    except RuntimeError:
        return asyncio.run(_async_change())
```

### 3.4 Strategy Assignment Component (`strategy_assignment.py`)

**[v1.1 ENHANCED]** - CSRF failures logged to audit trail, confirmation dialog added.

```python
"""Strategy assignment component for user management.

[v1.1] CSRF failures logged to audit trail.
[v1.1] Confirmation dialog before executing changes.
[v1.1] CSRF rotation on both success and failure.
"""

from __future__ import annotations
import asyncio
import logging
from typing import Any

import streamlit as st

from apps.web_console.components.csrf_protection import (
    generate_csrf_token,
    verify_csrf_token,
    rotate_csrf_token,
)
from apps.web_console.services.user_management import (
    list_strategies,
    get_user_strategies,
    grant_strategy,
    revoke_strategy,
)

logger = logging.getLogger(__name__)


def render_strategy_assignment(
    user_id: str,
    admin_user_id: str,
    db_pool: Any,
    audit_logger: Any,
) -> None:
    """Render strategy assignment UI for a single user."""

    confirm_key = f"confirm_strategy_{user_id}"

    st.subheader(f"Strategy Access: {user_id}")

    # Fetch current assignments and available strategies
    all_strategies = _list_strategies_sync(db_pool)
    current_strategies = _get_user_strategies_sync(db_pool, user_id)

    if not all_strategies:
        st.info("No strategies configured. Add strategies via CLI first.")
        return

    # Build selection options
    strategy_options = {s.strategy_id: f"{s.name} ({s.strategy_id})" for s in all_strategies}

    csrf_token = generate_csrf_token()

    with st.form(f"strategy_form_{user_id}"):
        selected = st.multiselect(
            "Assigned Strategies",
            options=list(strategy_options.keys()),
            default=current_strategies,
            format_func=lambda x: strategy_options.get(x, x),
            key=f"strategies_{user_id}",
        )

        # Hidden CSRF
        submitted_csrf = st.text_input(
            "csrf",
            value=csrf_token,
            type="password",
            label_visibility="hidden",
            key=f"strategy_csrf_{user_id}",
        )

        submitted = st.form_submit_button("Update Strategies", type="primary")

        if submitted:
            if not verify_csrf_token(submitted_csrf):
                st.error("Invalid form submission. Please refresh.")
                # [v1.1] Log CSRF failure to audit trail
                _log_csrf_failure_sync(
                    audit_logger, admin_user_id, "strategy_assignment", user_id
                )
                rotate_csrf_token()  # [v1.1] Rotate on failure
                return

            # Calculate grants and revokes
            current_set = set(current_strategies)
            selected_set = set(selected)

            to_grant = selected_set - current_set
            to_revoke = current_set - selected_set

            if not to_grant and not to_revoke:
                st.info("No changes to apply.")
                return

            # [v1.1] Set confirmation pending
            st.session_state[confirm_key] = {
                "to_grant": list(to_grant),
                "to_revoke": list(to_revoke),
            }
            st.rerun()

    # [v1.1] Confirmation dialog
    if st.session_state.get(confirm_key):
        pending = st.session_state[confirm_key]
        changes_summary = []
        if pending["to_grant"]:
            changes_summary.append(f"Grant: {', '.join(pending['to_grant'])}")
        if pending["to_revoke"]:
            changes_summary.append(f"Revoke: {', '.join(pending['to_revoke'])}")

        st.warning(
            f"**Confirm Strategy Changes for {user_id}**\n\n"
            + "\n\n".join(changes_summary) +
            "\n\n**This will invalidate the user's active sessions.**"
        )

        col1, col2 = st.columns(2)
        with col1:
            if st.button("Confirm", key=f"confirm_strat_{user_id}", type="primary"):
                results = []
                for strategy_id in pending["to_grant"]:
                    success, msg = _grant_strategy_sync(
                        db_pool, user_id, strategy_id, admin_user_id, audit_logger
                    )
                    results.append((strategy_id, "grant", success, msg))

                for strategy_id in pending["to_revoke"]:
                    success, msg = _revoke_strategy_sync(
                        db_pool, user_id, strategy_id, admin_user_id, audit_logger
                    )
                    results.append((strategy_id, "revoke", success, msg))

                # Show results
                for strategy_id, action, success, msg in results:
                    if success:
                        st.success(f"{action.title()}: {msg}")
                    else:
                        st.error(f"{action.title()} failed: {msg}")

                rotate_csrf_token()
                del st.session_state[confirm_key]
                st.rerun()

        with col2:
            if st.button("Cancel", key=f"cancel_strat_{user_id}"):
                del st.session_state[confirm_key]
                st.rerun()


def _log_csrf_failure_sync(
    audit_logger: Any,
    admin_user_id: str,
    action: str,
    target_user_id: str,
) -> None:
    """[v1.1] Log CSRF failure to audit trail (sync wrapper)."""
    import concurrent.futures

    async def _log():
        await audit_logger.log_action(
            user_id=admin_user_id,
            action=f"{action}_csrf_failed",
            resource_type="user_strategy",
            resource_id=target_user_id,
            outcome="denied",
            details={"reason": "csrf_validation_failed"},
        )

    try:
        loop = asyncio.get_running_loop()
        with concurrent.futures.ThreadPoolExecutor() as pool:
            pool.submit(asyncio.run, _log()).result(timeout=5.0)
    except RuntimeError:
        asyncio.run(_log())


# Sync wrappers for async functions
def _list_strategies_sync(db_pool: Any):
    return _run_async(list_strategies(db_pool))

def _get_user_strategies_sync(db_pool: Any, user_id: str):
    return _run_async(get_user_strategies(db_pool, user_id))

def _grant_strategy_sync(db_pool, user_id, strategy_id, admin_user_id, audit_logger):
    return _run_async(grant_strategy(db_pool, user_id, strategy_id, admin_user_id, audit_logger))

def _revoke_strategy_sync(db_pool, user_id, strategy_id, admin_user_id, audit_logger):
    return _run_async(revoke_strategy(db_pool, user_id, strategy_id, admin_user_id, audit_logger))

def _run_async(coro):
    """Run async coroutine from sync context."""
    import concurrent.futures
    try:
        loop = asyncio.get_running_loop()
        with concurrent.futures.ThreadPoolExecutor() as pool:
            return pool.submit(asyncio.run, coro).result(timeout=10.0)
    except RuntimeError:
        return asyncio.run(coro)
```

### 3.5 Bulk Operations Component (`bulk_operations.py`)

**[v1.2]** - Complete bulk role/strategy operations (grant AND revoke) with double-confirmation.

```python
"""Bulk operations component with double-confirmation.

[v1.2] Complete bulk operations: role changes, strategy grants, strategy revokes.
All with double-confirmation (preview + type CONFIRM).
"""

from __future__ import annotations
import asyncio
import logging
from typing import Any

import streamlit as st

from apps.web_console.components.csrf_protection import (
    generate_csrf_token,
    verify_csrf_token,
    rotate_csrf_token,
)
from apps.web_console.services.user_management import (
    bulk_change_roles,
    bulk_grant_strategy,
    bulk_revoke_strategy,
    list_strategies,
)

logger = logging.getLogger(__name__)


def render_bulk_role_change(
    users: list,
    admin_user_id: str,
    db_pool: Any,
    audit_logger: Any,
) -> None:
    """Render bulk role change UI with double-confirmation."""

    st.subheader("Bulk Role Change")
    st.caption("Change roles for multiple users at once")

    # First confirmation state
    confirm1_key = "bulk_role_confirm1"
    confirm2_key = "bulk_role_confirm2"

    csrf_token = generate_csrf_token()

    with st.form("bulk_role_form"):
        # User selection
        user_options = {u.user_id: f"{u.user_id} ({u.role})" for u in users}
        selected_users = st.multiselect(
            "Select Users",
            options=list(user_options.keys()),
            format_func=lambda x: user_options.get(x, x),
            key="bulk_users",
        )

        new_role = st.selectbox("New Role", ["viewer", "operator", "admin"])

        reason = st.text_area(
            "Reason for bulk change (required)",
            placeholder="Enter justification for bulk role change...",
            key="bulk_reason",
        )

        submitted_csrf = st.text_input(
            "csrf", value=csrf_token, type="password",
            label_visibility="hidden", key="bulk_csrf",
        )

        submitted = st.form_submit_button("Preview Changes", type="primary")

        if submitted:
            if not verify_csrf_token(submitted_csrf):
                st.error("Invalid form submission.")
                _log_csrf_failure_sync(audit_logger, admin_user_id, "bulk_role_change")
                rotate_csrf_token()
                return

            if not selected_users:
                st.error("Select at least one user.")
                return

            if not reason or len(reason.strip()) < 10:
                st.error("Reason must be at least 10 characters.")
                return

            # First confirmation
            st.session_state[confirm1_key] = {
                "users": selected_users,
                "new_role": new_role,
                "reason": reason.strip(),
            }
            st.rerun()

    # First confirmation dialog
    if st.session_state.get(confirm1_key) and not st.session_state.get(confirm2_key):
        pending = st.session_state[confirm1_key]
        st.warning(
            f"**First Confirmation - Bulk Role Change**\n\n"
            f"Users: {len(pending['users'])} selected\n\n"
            f"New Role: {pending['new_role']}\n\n"
            f"This will invalidate all active sessions for these users."
        )

        col1, col2 = st.columns(2)
        with col1:
            if st.button("Proceed to Final Confirmation", type="primary"):
                st.session_state[confirm2_key] = True
                st.rerun()
        with col2:
            if st.button("Cancel"):
                del st.session_state[confirm1_key]
                st.rerun()

    # Second (final) confirmation dialog - DOUBLE CONFIRM
    if st.session_state.get(confirm1_key) and st.session_state.get(confirm2_key):
        pending = st.session_state[confirm1_key]
        st.error(
            f"**FINAL CONFIRMATION - BULK ROLE CHANGE**\n\n"
            f"⚠️ You are about to change roles for **{len(pending['users'])} users**\n\n"
            f"This action cannot be easily undone.\n\n"
            f"Type 'CONFIRM' below to proceed."
        )

        confirm_text = st.text_input("Type CONFIRM to proceed", key="confirm_text")

        col1, col2 = st.columns(2)
        with col1:
            if st.button("Execute Bulk Change", type="primary"):
                if confirm_text != "CONFIRM":
                    st.error("You must type 'CONFIRM' to proceed.")
                    return

                # Execute bulk change
                results = _bulk_change_roles_sync(
                    db_pool,
                    pending["users"],
                    pending["new_role"],
                    admin_user_id,
                    audit_logger,
                    pending["reason"],
                )

                success_count = sum(1 for s, _ in results.values() if s)
                fail_count = len(results) - success_count

                st.success(f"Completed: {success_count} succeeded, {fail_count} failed")

                for user_id, (success, msg) in results.items():
                    if success:
                        st.write(f"✅ {user_id}: {msg}")
                    else:
                        st.write(f"❌ {user_id}: {msg}")

                rotate_csrf_token()
                del st.session_state[confirm1_key]
                del st.session_state[confirm2_key]

        with col2:
            if st.button("Cancel", key="cancel_final"):
                del st.session_state[confirm1_key]
                del st.session_state[confirm2_key]
                st.rerun()


def render_bulk_strategy_operations(
    users: list,
    admin_user_id: str,
    db_pool: Any,
    audit_logger: Any,
) -> None:
    """[v1.2] Render bulk strategy operations (grant AND revoke) with double-confirmation."""

    st.subheader("Bulk Strategy Operations")

    strategies = _list_strategies_sync(db_pool)
    if not strategies:
        st.info("No strategies configured.")
        return

    # Tab for grant vs revoke
    tab_grant, tab_revoke = st.tabs(["Bulk Grant", "Bulk Revoke"])

    with tab_grant:
        _render_bulk_strategy_grant(users, admin_user_id, db_pool, audit_logger, strategies)

    with tab_revoke:
        _render_bulk_strategy_revoke(users, admin_user_id, db_pool, audit_logger, strategies)


def _render_bulk_strategy_grant(users, admin_user_id, db_pool, audit_logger, strategies):
    """Bulk strategy grant with double-confirmation."""
    confirm1_key = "bulk_grant_confirm1"
    confirm2_key = "bulk_grant_confirm2"

    csrf_token = generate_csrf_token()

    with st.form("bulk_grant_form"):
        user_options = {u.user_id: f"{u.user_id} ({u.role})" for u in users}
        selected_users = st.multiselect(
            "Select Users", options=list(user_options.keys()),
            format_func=lambda x: user_options.get(x, x), key="bulk_grant_users",
        )
        strategy_options = {s.strategy_id: f"{s.name}" for s in strategies}
        selected_strategy = st.selectbox(
            "Strategy to Grant", options=list(strategy_options.keys()),
            format_func=lambda x: strategy_options.get(x, x), key="bulk_grant_strat",
        )
        submitted_csrf = st.text_input(
            "csrf", value=csrf_token, type="password",
            label_visibility="hidden", key="bulk_grant_csrf",
        )
        submitted = st.form_submit_button("Preview Grant", type="primary")

        if submitted:
            if not verify_csrf_token(submitted_csrf):
                st.error("Invalid form submission.")
                _log_csrf_failure_sync(audit_logger, admin_user_id, "bulk_strategy_grant")
                rotate_csrf_token()
                return
            if not selected_users:
                st.error("Select at least one user.")
                return
            st.session_state[confirm1_key] = {"users": selected_users, "strategy_id": selected_strategy}
            st.rerun()

    # First confirmation
    if st.session_state.get(confirm1_key) and not st.session_state.get(confirm2_key):
        pending = st.session_state[confirm1_key]
        st.warning(f"**Grant {pending['strategy_id']} to {len(pending['users'])} users?**")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("Proceed to Final", key="grant_proceed"):
                st.session_state[confirm2_key] = True
                st.rerun()
        with col2:
            if st.button("Cancel", key="grant_cancel1"):
                del st.session_state[confirm1_key]
                st.rerun()

    # Second confirmation (type CONFIRM)
    if st.session_state.get(confirm1_key) and st.session_state.get(confirm2_key):
        pending = st.session_state[confirm1_key]
        st.error(f"**FINAL: Grant {pending['strategy_id']} to {len(pending['users'])} users**\n\nType 'CONFIRM' to proceed.")
        confirm_text = st.text_input("Type CONFIRM", key="grant_confirm_text")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("Execute Grant", type="primary", key="grant_exec"):
                if confirm_text != "CONFIRM":
                    st.error("Type 'CONFIRM' to proceed.")
                    return
                results = _bulk_grant_strategy_sync(
                    db_pool, pending["users"], pending["strategy_id"], admin_user_id, audit_logger
                )
                _show_bulk_results(results, "Grant")
                rotate_csrf_token()
                del st.session_state[confirm1_key]
                del st.session_state[confirm2_key]
        with col2:
            if st.button("Cancel", key="grant_cancel2"):
                del st.session_state[confirm1_key]
                del st.session_state[confirm2_key]
                st.rerun()


def _render_bulk_strategy_revoke(users, admin_user_id, db_pool, audit_logger, strategies):
    """[v1.2] Bulk strategy revoke with double-confirmation."""
    confirm1_key = "bulk_revoke_confirm1"
    confirm2_key = "bulk_revoke_confirm2"

    csrf_token = generate_csrf_token()

    with st.form("bulk_revoke_form"):
        user_options = {u.user_id: f"{u.user_id} ({u.role})" for u in users}
        selected_users = st.multiselect(
            "Select Users", options=list(user_options.keys()),
            format_func=lambda x: user_options.get(x, x), key="bulk_revoke_users",
        )
        strategy_options = {s.strategy_id: f"{s.name}" for s in strategies}
        selected_strategy = st.selectbox(
            "Strategy to Revoke", options=list(strategy_options.keys()),
            format_func=lambda x: strategy_options.get(x, x), key="bulk_revoke_strat",
        )
        submitted_csrf = st.text_input(
            "csrf", value=csrf_token, type="password",
            label_visibility="hidden", key="bulk_revoke_csrf",
        )
        submitted = st.form_submit_button("Preview Revoke", type="primary")

        if submitted:
            if not verify_csrf_token(submitted_csrf):
                st.error("Invalid form submission.")
                _log_csrf_failure_sync(audit_logger, admin_user_id, "bulk_strategy_revoke")
                rotate_csrf_token()
                return
            if not selected_users:
                st.error("Select at least one user.")
                return
            st.session_state[confirm1_key] = {"users": selected_users, "strategy_id": selected_strategy}
            st.rerun()

    # First confirmation
    if st.session_state.get(confirm1_key) and not st.session_state.get(confirm2_key):
        pending = st.session_state[confirm1_key]
        st.warning(f"**Revoke {pending['strategy_id']} from {len(pending['users'])} users?**")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("Proceed to Final", key="revoke_proceed"):
                st.session_state[confirm2_key] = True
                st.rerun()
        with col2:
            if st.button("Cancel", key="revoke_cancel1"):
                del st.session_state[confirm1_key]
                st.rerun()

    # Second confirmation (type CONFIRM)
    if st.session_state.get(confirm1_key) and st.session_state.get(confirm2_key):
        pending = st.session_state[confirm1_key]
        st.error(f"**FINAL: Revoke {pending['strategy_id']} from {len(pending['users'])} users**\n\nType 'CONFIRM' to proceed.")
        confirm_text = st.text_input("Type CONFIRM", key="revoke_confirm_text")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("Execute Revoke", type="primary", key="revoke_exec"):
                if confirm_text != "CONFIRM":
                    st.error("Type 'CONFIRM' to proceed.")
                    return
                results = _bulk_revoke_strategy_sync(
                    db_pool, pending["users"], pending["strategy_id"], admin_user_id, audit_logger
                )
                _show_bulk_results(results, "Revoke")
                rotate_csrf_token()
                del st.session_state[confirm1_key]
                del st.session_state[confirm2_key]
        with col2:
            if st.button("Cancel", key="revoke_cancel2"):
                del st.session_state[confirm1_key]
                del st.session_state[confirm2_key]
                st.rerun()


def _show_bulk_results(results: dict, action: str):
    """Display per-user results for bulk operations."""
    success_count = sum(1 for s, _ in results.values() if s)
    fail_count = len(results) - success_count
    st.success(f"{action} complete: {success_count} succeeded, {fail_count} failed")
    for user_id, (success, msg) in results.items():
        if success:
            st.write(f"✅ {user_id}: {msg}")
        else:
            st.write(f"❌ {user_id}: {msg}")


def _log_csrf_failure_sync(audit_logger, admin_user_id, action):
    """Log CSRF failure to audit trail."""
    import concurrent.futures

    async def _log():
        await audit_logger.log_action(
            user_id=admin_user_id,
            action=f"{action}_csrf_failed",
            resource_type="bulk_operation",
            resource_id=None,
            outcome="denied",
            details={"reason": "csrf_validation_failed"},
        )

    try:
        loop = asyncio.get_running_loop()
        with concurrent.futures.ThreadPoolExecutor() as pool:
            pool.submit(asyncio.run, _log()).result(timeout=5.0)
    except RuntimeError:
        asyncio.run(_log())


def _bulk_change_roles_sync(db_pool, user_ids, new_role, admin_user_id, audit_logger, reason):
    return _run_async(bulk_change_roles(db_pool, user_ids, new_role, admin_user_id, audit_logger, reason))


def _bulk_grant_strategy_sync(db_pool, user_ids, strategy_id, admin_user_id, audit_logger):
    return _run_async(bulk_grant_strategy(db_pool, user_ids, strategy_id, admin_user_id, audit_logger))


def _bulk_revoke_strategy_sync(db_pool, user_ids, strategy_id, admin_user_id, audit_logger):
    return _run_async(bulk_revoke_strategy(db_pool, user_ids, strategy_id, admin_user_id, audit_logger))


def _list_strategies_sync(db_pool):
    return _run_async(list_strategies(db_pool))


def _run_async(coro):
    """[v1.2] Run async in fresh event loop via ThreadPoolExecutor.

    This pattern avoids conflicts with Streamlit's event loop while
    providing thread-safe async execution.
    """
    import concurrent.futures
    try:
        loop = asyncio.get_running_loop()
        with concurrent.futures.ThreadPoolExecutor() as pool:
            return pool.submit(asyncio.run, coro).result(timeout=30.0)
    except RuntimeError:
        return asyncio.run(coro)
```

### 3.6 Admin Users Page (`pages/admin_users.py`)

**[v1.2]** - Page-level permission denial now logged via AuditLogger (not just logger).

```python
"""Admin User Management Page.

[v1.2] Page-level permission denial logged via AuditLogger.

Requires MANAGE_USERS permission. Provides:
- User list with roles and strategy counts
- Role change with confirmation
- Strategy assignment per user
- Bulk operations (role change, strategy grant/revoke)
- Search and filter functionality
"""

from __future__ import annotations
import asyncio
import logging
from typing import Any

import streamlit as st

from apps.web_console.auth.permissions import Permission, has_permission
from apps.web_console.auth.audit_log import AuditLogger
from apps.web_console.components.user_role_editor import render_role_editor
from apps.web_console.components.strategy_assignment import render_strategy_assignment
from apps.web_console.components.bulk_operations import render_bulk_role_change, render_bulk_strategy_operations
from apps.web_console.services.user_management import list_users

logger = logging.getLogger(__name__)


def render_admin_users(
    user: dict[str, Any],
    db_pool: Any,
    audit_logger: AuditLogger,
) -> None:
    """Render admin user management page.

    Args:
        user: Current authenticated user dict with 'sub', 'role', etc.
        db_pool: Database connection pool
        audit_logger: Audit logger instance
    """
    # Permission check (defense in depth - should also be checked at routing)
    if not has_permission(user, Permission.MANAGE_USERS):
        st.error("Permission denied: MANAGE_USERS required")
        # [v1.2] Log to AuditLogger, not just logger
        _log_page_denial_sync(audit_logger, user.get("sub"), user.get("role"))
        logger.warning(
            "admin_page_access_denied",
            extra={"user_id": user.get("sub"), "role": user.get("role")}
        )
        st.stop()

    st.title("User Management")
    st.caption("Manage user roles and strategy access")

    admin_user_id = user.get("sub", "unknown")

    # Fetch users
    users = _list_users_sync(db_pool)

    if not users:
        st.info("No users provisioned yet. Use `scripts/manage_roles.py` to bootstrap admin.")
        return

    # Search/filter
    col1, col2 = st.columns([3, 1])
    with col1:
        search_query = st.text_input(
            "Search users",
            placeholder="Filter by user ID...",
            key="user_search",
        )
    with col2:
        role_filter = st.selectbox(
            "Filter by role",
            ["All", "admin", "operator", "viewer"],
            key="role_filter",
        )

    # Apply filters
    filtered_users = users
    if search_query:
        filtered_users = [u for u in filtered_users if search_query.lower() in u.user_id.lower()]
    if role_filter != "All":
        filtered_users = [u for u in filtered_users if u.role == role_filter]

    # [v1.2] Tabs for single-user vs bulk operations
    main_tab1, main_tab2 = st.tabs(["Individual Users", "Bulk Operations"])

    with main_tab1:
        # User list
        st.subheader(f"Users ({len(filtered_users)} of {len(users)})")

        for user_info in filtered_users:
            with st.expander(
                f"**{user_info.user_id}** - {user_info.role} ({user_info.strategy_count} strategies)",
                expanded=False,
            ):
                # User details
                st.markdown(f"**Session Version:** {user_info.session_version}")
                st.markdown(f"**Last Updated:** {user_info.updated_at}")
                if user_info.updated_by:
                    st.markdown(f"**Updated By:** {user_info.updated_by}")

                st.divider()

                # Tabs for role and strategy management
                tab1, tab2 = st.tabs(["Role", "Strategies"])

                with tab1:
                    render_role_editor(
                        user_id=user_info.user_id,
                        current_role=user_info.role,
                        admin_user_id=admin_user_id,
                        db_pool=db_pool,
                        audit_logger=audit_logger,
                    )

                with tab2:
                    render_strategy_assignment(
                        user_id=user_info.user_id,
                        admin_user_id=admin_user_id,
                        db_pool=db_pool,
                        audit_logger=audit_logger,
                    )

    with main_tab2:
        # [v1.2] Bulk operations with double-confirmation
        st.subheader("Bulk Operations")
        st.warning("⚠️ Bulk operations require double confirmation to prevent accidental changes.")

        bulk_tab1, bulk_tab2 = st.tabs(["Bulk Role Change", "Bulk Strategy Operations"])

        with bulk_tab1:
            render_bulk_role_change(users, admin_user_id, db_pool, audit_logger)

        with bulk_tab2:
            render_bulk_strategy_operations(users, admin_user_id, db_pool, audit_logger)


def _log_page_denial_sync(audit_logger: AuditLogger, user_id: str | None, role: str | None) -> None:
    """[v1.2] Log page-level permission denial to AuditLogger."""
    import concurrent.futures

    async def _log():
        await audit_logger.log_action(
            user_id=user_id,
            action="admin_page_access_denied",
            resource_type="page",
            resource_id="admin_users",
            outcome="denied",
            details={"role": role, "required_permission": "MANAGE_USERS"},
        )

    try:
        loop = asyncio.get_running_loop()
        with concurrent.futures.ThreadPoolExecutor() as pool:
            pool.submit(asyncio.run, _log()).result(timeout=5.0)
    except RuntimeError:
        asyncio.run(_log())


def _list_users_sync(db_pool: Any):
    """Sync wrapper for list_users."""
    import concurrent.futures
    try:
        loop = asyncio.get_running_loop()
        with concurrent.futures.ThreadPoolExecutor() as pool:
            return pool.submit(asyncio.run, list_users(db_pool)).result(timeout=10.0)
    except RuntimeError:
        return asyncio.run(list_users(db_pool))
```

### 3.7 Integration with Main App

Update `apps/web_console/app.py` to add navigation to admin page:

```python
# In sidebar navigation:
if has_permission(user_info, Permission.MANAGE_USERS):
    pages.append("User Management")

# In main content:
elif page == "User Management":
    from apps.web_console.pages.admin_users import render_admin_users
    render_admin_users(
        user=user_info,
        db_pool=_get_db_pool(),
        audit_logger=AuditLogger(_get_db_pool()),
    )
```

---

## 4. Test Plan

**[v1.2 COMPREHENSIVE]** - Full coverage for CSRF, strategy flows, denied attempts, session invalidation, bulk operations (grant+revoke), page-level audit.

### 4.1 Unit Tests (`test_csrf_protection.py`)

```python
"""Tests for CSRF protection component."""

import pytest
import streamlit as st
from unittest.mock import patch, MagicMock

from apps.web_console.components.csrf_protection import (
    generate_csrf_token,
    verify_csrf_token,
    rotate_csrf_token,
    CSRF_TOKEN_KEY,
)


class TestCSRFProtection:
    """Test CSRF token generation and validation."""

    def test_generate_csrf_token_creates_token(self):
        """Test token generation creates 32-byte URL-safe token."""
        with patch.object(st, "session_state", {}):
            token = generate_csrf_token()
            assert token is not None
            assert len(token) >= 32  # URL-safe base64 of 32 bytes
            assert st.session_state[CSRF_TOKEN_KEY] == token

    def test_generate_csrf_token_reuses_existing(self):
        """Test repeated calls return same token."""
        with patch.object(st, "session_state", {}):
            token1 = generate_csrf_token()
            token2 = generate_csrf_token()
            assert token1 == token2

    def test_verify_csrf_token_valid(self):
        """Test valid token verification."""
        with patch.object(st, "session_state", {CSRF_TOKEN_KEY: "test_token"}):
            assert verify_csrf_token("test_token") is True

    def test_verify_csrf_token_invalid(self):
        """Test invalid token rejected."""
        with patch.object(st, "session_state", {CSRF_TOKEN_KEY: "correct"}):
            assert verify_csrf_token("wrong") is False

    def test_verify_csrf_token_missing_session(self):
        """Test missing session token fails."""
        with patch.object(st, "session_state", {}):
            assert verify_csrf_token("any") is False

    def test_verify_csrf_token_empty_submitted(self):
        """Test empty submitted token fails."""
        with patch.object(st, "session_state", {CSRF_TOKEN_KEY: "token"}):
            assert verify_csrf_token("") is False

    def test_rotate_csrf_token_changes_value(self):
        """Test rotation creates new token."""
        with patch.object(st, "session_state", {CSRF_TOKEN_KEY: "old"}):
            new_token = rotate_csrf_token()
            assert new_token != "old"
            assert st.session_state[CSRF_TOKEN_KEY] == new_token
```

### 4.2 Unit Tests (`test_user_management.py`)

```python
"""Tests for user management service."""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from datetime import datetime, UTC

from apps.web_console.services.user_management import (
    list_users,
    change_user_role,
    grant_strategy,
    revoke_strategy,
    UserInfo,
)


class TestListUsers:
    """Tests for list_users function."""

    @pytest.mark.asyncio
    async def test_list_users_returns_user_info(self):
        """Test list_users returns UserInfo objects."""
        mock_pool = AsyncMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_conn.fetch.return_value = [
            {
                "user_id": "user1",
                "role": "admin",
                "session_version": 1,
                "updated_at": datetime.now(UTC),
                "updated_by": "bootstrap",
                "strategy_count": 2,
            }
        ]

        users = await list_users(mock_pool)

        assert len(users) == 1
        assert users[0].user_id == "user1"
        assert users[0].role == "admin"
        assert users[0].strategy_count == 2


class TestChangeUserRole:
    """Tests for change_user_role function."""

    @pytest.mark.asyncio
    async def test_change_role_success(self):
        """Test successful role change."""
        mock_pool = AsyncMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_conn.fetchrow.return_value = {"role": "viewer"}

        mock_audit = AsyncMock()

        success, msg = await change_user_role(
            db_pool=mock_pool,
            user_id="user1",
            new_role="operator",
            admin_user_id="admin1",
            audit_logger=mock_audit,
            reason="Promotion",
        )

        assert success is True
        assert "operator" in msg
        mock_audit.log_admin_change.assert_called_once()

    @pytest.mark.asyncio
    async def test_change_role_invalid_role(self):
        """Test invalid role rejected."""
        mock_pool = AsyncMock()
        mock_audit = AsyncMock()

        success, msg = await change_user_role(
            db_pool=mock_pool,
            user_id="user1",
            new_role="superadmin",  # Invalid
            admin_user_id="admin1",
            audit_logger=mock_audit,
            reason="Test",
        )

        assert success is False
        assert "Invalid role" in msg

    @pytest.mark.asyncio
    async def test_change_role_user_not_found(self):
        """Test user not found error."""
        mock_pool = AsyncMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_conn.fetchrow.return_value = None

        mock_audit = AsyncMock()

        success, msg = await change_user_role(
            db_pool=mock_pool,
            user_id="nonexistent",
            new_role="admin",
            admin_user_id="admin1",
            audit_logger=mock_audit,
            reason="Test",
        )

        assert success is False
        assert "not found" in msg
```

### 4.3 Integration Tests (`test_admin_users.py`)

```python
"""Integration tests for admin users page."""

import pytest
from unittest.mock import patch, MagicMock, AsyncMock
import streamlit as st

from apps.web_console.pages.admin_users import render_admin_users
from apps.web_console.auth.permissions import Permission


class TestAdminUsersPage:
    """Tests for admin user management page."""

    def test_access_denied_without_permission(self):
        """Test non-admin users cannot access page."""
        user = {"sub": "viewer1", "role": "viewer"}
        mock_pool = MagicMock()
        mock_audit = MagicMock()

        with patch.object(st, "error") as mock_error:
            with patch.object(st, "stop") as mock_stop:
                render_admin_users(user, mock_pool, mock_audit)
                mock_error.assert_called()
                mock_stop.assert_called()

    def test_admin_can_access(self):
        """Test admin users can access page."""
        user = {"sub": "admin1", "role": "admin"}
        mock_pool = MagicMock()
        mock_audit = MagicMock()

        with patch("apps.web_console.pages.admin_users._list_users_sync", return_value=[]):
            with patch.object(st, "title") as mock_title:
                render_admin_users(user, mock_pool, mock_audit)
                mock_title.assert_called_with("User Management")

    def test_page_denial_logged_to_audit(self):
        """[v1.2] Test page access denial is logged to AuditLogger."""
        user = {"sub": "viewer1", "role": "viewer"}
        mock_pool = MagicMock()
        mock_audit = AsyncMock()

        with patch("apps.web_console.pages.admin_users._log_page_denial_sync") as mock_log:
            with patch.object(st, "error"):
                with patch.object(st, "stop"):
                    render_admin_users(user, mock_pool, mock_audit)
                    mock_log.assert_called_once()
```

### 4.4 Strategy Assignment Tests (`test_strategy_assignment.py`)

**[v1.2 NEW]** - Tests for strategy grant/revoke flows including denied attempts and session invalidation.

```python
"""Tests for strategy assignment component and service functions."""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from apps.web_console.services.user_management import (
    grant_strategy,
    revoke_strategy,
)


class TestGrantStrategy:
    """Tests for grant_strategy function."""

    @pytest.mark.asyncio
    async def test_grant_strategy_success(self):
        """Test successful strategy grant."""
        mock_pool = AsyncMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_conn.fetchval.return_value = None  # Not already granted

        mock_audit = AsyncMock()

        success, msg = await grant_strategy(
            db_pool=mock_pool,
            user_id="user1",
            strategy_id="alpha_baseline",
            admin_user_id="admin1",
            audit_logger=mock_audit,
        )

        assert success is True
        assert "alpha_baseline" in msg
        mock_audit.log_admin_change.assert_called_once()
        # Verify session_version increment was called
        assert mock_conn.execute.call_count == 2  # INSERT + UPDATE

    @pytest.mark.asyncio
    async def test_grant_strategy_already_granted_denied(self):
        """[v1.2] Test already granted logs denied attempt."""
        mock_pool = AsyncMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_conn.fetchval.return_value = 1  # Already granted

        mock_audit = AsyncMock()

        success, msg = await grant_strategy(
            db_pool=mock_pool,
            user_id="user1",
            strategy_id="alpha_baseline",
            admin_user_id="admin1",
            audit_logger=mock_audit,
        )

        assert success is False
        assert "already granted" in msg
        mock_audit.log_action.assert_called_once()
        call_kwargs = mock_audit.log_action.call_args[1]
        assert call_kwargs["outcome"] == "denied"
        assert call_kwargs["action"] == "strategy_grant_denied"

    @pytest.mark.asyncio
    async def test_grant_strategy_increments_session_version(self):
        """[v1.2] Verify grant explicitly increments session_version."""
        mock_pool = AsyncMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_conn.fetchval.return_value = None

        mock_audit = AsyncMock()

        await grant_strategy(
            db_pool=mock_pool,
            user_id="user1",
            strategy_id="alpha_baseline",
            admin_user_id="admin1",
            audit_logger=mock_audit,
        )

        # Verify UPDATE was called for session_version
        execute_calls = [str(c) for c in mock_conn.execute.call_args_list]
        assert any("session_version" in str(c) for c in execute_calls)


class TestRevokeStrategy:
    """Tests for revoke_strategy function."""

    @pytest.mark.asyncio
    async def test_revoke_strategy_success(self):
        """Test successful strategy revoke."""
        mock_pool = AsyncMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_conn.execute.return_value = "DELETE 1"

        mock_audit = AsyncMock()

        success, msg = await revoke_strategy(
            db_pool=mock_pool,
            user_id="user1",
            strategy_id="alpha_baseline",
            admin_user_id="admin1",
            audit_logger=mock_audit,
        )

        assert success is True
        mock_audit.log_admin_change.assert_called_once()

    @pytest.mark.asyncio
    async def test_revoke_strategy_not_assigned_denied(self):
        """[v1.2] Test revoke of non-assigned strategy logs denied."""
        mock_pool = AsyncMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_conn.execute.return_value = "DELETE 0"

        mock_audit = AsyncMock()

        success, msg = await revoke_strategy(
            db_pool=mock_pool,
            user_id="user1",
            strategy_id="alpha_baseline",
            admin_user_id="admin1",
            audit_logger=mock_audit,
        )

        assert success is False
        mock_audit.log_action.assert_called_once()
        call_kwargs = mock_audit.log_action.call_args[1]
        assert call_kwargs["outcome"] == "denied"

    @pytest.mark.asyncio
    async def test_revoke_strategy_increments_session_version(self):
        """[v1.2] Verify revoke explicitly increments session_version."""
        mock_pool = AsyncMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_conn.execute.return_value = "DELETE 1"

        mock_audit = AsyncMock()

        await revoke_strategy(
            db_pool=mock_pool,
            user_id="user1",
            strategy_id="alpha_baseline",
            admin_user_id="admin1",
            audit_logger=mock_audit,
        )

        # Verify UPDATE was called for session_version
        execute_calls = [str(c) for c in mock_conn.execute.call_args_list]
        assert any("session_version" in str(c) for c in execute_calls)
```

### 4.5 Bulk Operations Tests (`test_bulk_operations.py`)

**[v1.2 NEW]** - Tests for bulk role and strategy operations.

```python
"""Tests for bulk operations service functions."""

import pytest
from unittest.mock import AsyncMock, patch

from apps.web_console.services.user_management import (
    bulk_change_roles,
    bulk_grant_strategy,
    bulk_revoke_strategy,
)


class TestBulkChangeRoles:
    """Tests for bulk_change_roles function."""

    @pytest.mark.asyncio
    async def test_bulk_change_roles_multiple_users(self):
        """Test bulk role change for multiple users."""
        mock_pool = AsyncMock()
        mock_audit = AsyncMock()

        with patch("apps.web_console.services.user_management.change_user_role") as mock_change:
            mock_change.return_value = (True, "Role changed")

            results = await bulk_change_roles(
                db_pool=mock_pool,
                user_ids=["user1", "user2", "user3"],
                new_role="operator",
                admin_user_id="admin1",
                audit_logger=mock_audit,
                reason="Bulk promotion",
            )

            assert len(results) == 3
            assert all(s for s, _ in results.values())
            assert mock_change.call_count == 3

    @pytest.mark.asyncio
    async def test_bulk_change_roles_partial_failure(self):
        """Test bulk role change with some failures."""
        mock_pool = AsyncMock()
        mock_audit = AsyncMock()

        with patch("apps.web_console.services.user_management.change_user_role") as mock_change:
            mock_change.side_effect = [
                (True, "Success"),
                (False, "User not found"),
                (True, "Success"),
            ]

            results = await bulk_change_roles(
                db_pool=mock_pool,
                user_ids=["user1", "user2", "user3"],
                new_role="operator",
                admin_user_id="admin1",
                audit_logger=mock_audit,
                reason="Test",
            )

            success_count = sum(1 for s, _ in results.values() if s)
            fail_count = len(results) - success_count
            assert success_count == 2
            assert fail_count == 1


class TestBulkStrategyOperations:
    """Tests for bulk strategy grant/revoke functions."""

    @pytest.mark.asyncio
    async def test_bulk_grant_strategy(self):
        """Test bulk strategy grant."""
        mock_pool = AsyncMock()
        mock_audit = AsyncMock()

        with patch("apps.web_console.services.user_management.grant_strategy") as mock_grant:
            mock_grant.return_value = (True, "Granted")

            results = await bulk_grant_strategy(
                db_pool=mock_pool,
                user_ids=["user1", "user2"],
                strategy_id="alpha_baseline",
                admin_user_id="admin1",
                audit_logger=mock_audit,
            )

            assert len(results) == 2
            assert all(s for s, _ in results.values())

    @pytest.mark.asyncio
    async def test_bulk_revoke_strategy(self):
        """[v1.2] Test bulk strategy revoke."""
        mock_pool = AsyncMock()
        mock_audit = AsyncMock()

        with patch("apps.web_console.services.user_management.revoke_strategy") as mock_revoke:
            mock_revoke.return_value = (True, "Revoked")

            results = await bulk_revoke_strategy(
                db_pool=mock_pool,
                user_ids=["user1", "user2"],
                strategy_id="alpha_baseline",
                admin_user_id="admin1",
                audit_logger=mock_audit,
            )

            assert len(results) == 2
            assert all(s for s, _ in results.values())
```

### 4.6 CSRF Failure Audit Tests (`test_csrf_audit.py`)

**[v1.2 NEW]** - Tests for CSRF failure audit logging.

```python
"""Tests for CSRF failure audit logging."""

import pytest
from unittest.mock import AsyncMock, patch, MagicMock
import streamlit as st


class TestCSRFFailureAudit:
    """Tests for CSRF failure audit logging."""

    def test_role_editor_csrf_failure_logged(self):
        """Test CSRF failure in role editor is logged to audit."""
        from apps.web_console.components.user_role_editor import _log_csrf_failure_sync

        mock_audit = AsyncMock()

        with patch("asyncio.run") as mock_run:
            _log_csrf_failure_sync(mock_audit, "admin1", "role_change", "user1")
            mock_run.assert_called_once()

    def test_strategy_assignment_csrf_failure_logged(self):
        """Test CSRF failure in strategy assignment is logged to audit."""
        from apps.web_console.components.strategy_assignment import _log_csrf_failure_sync

        mock_audit = AsyncMock()

        with patch("asyncio.run") as mock_run:
            _log_csrf_failure_sync(mock_audit, "admin1", "strategy_assignment", "user1")
            mock_run.assert_called_once()

    def test_bulk_operations_csrf_failure_logged(self):
        """Test CSRF failure in bulk operations is logged to audit."""
        from apps.web_console.components.bulk_operations import _log_csrf_failure_sync

        mock_audit = AsyncMock()

        with patch("asyncio.run") as mock_run:
            _log_csrf_failure_sync(mock_audit, "admin1", "bulk_role_change")
            mock_run.assert_called_once()
```

---

## 5. File Checklist

### 5.1 Files to Create

| File | Purpose | Lines (est) |
|------|---------|-------------|
| `apps/web_console/components/csrf_protection.py` | CSRF token management | ~50 |
| `apps/web_console/services/__init__.py` | Services package init | ~5 |
| `apps/web_console/services/user_management.py` | User/role/strategy DB ops + bulk | ~300 |
| `apps/web_console/components/user_role_editor.py` | Role change UI component | ~120 |
| `apps/web_console/components/strategy_assignment.py` | Strategy assignment UI | ~150 |
| `apps/web_console/components/bulk_operations.py` | **[v1.2]** Bulk role/strategy ops | ~250 |
| `apps/web_console/pages/admin_users.py` | Main admin page with bulk tabs | ~150 |
| `tests/apps/web_console/test_csrf_protection.py` | CSRF tests | ~80 |
| `tests/apps/web_console/services/__init__.py` | Test package init | ~5 |
| `tests/apps/web_console/services/test_user_management.py` | User mgmt tests | ~150 |
| `tests/apps/web_console/test_admin_users.py` | Admin page tests | ~100 |
| `tests/apps/web_console/test_strategy_assignment.py` | **[v1.2]** Strategy flow tests | ~150 |
| `tests/apps/web_console/test_bulk_operations.py` | **[v1.2]** Bulk ops tests | ~120 |
| `tests/apps/web_console/test_csrf_audit.py` | **[v1.2]** CSRF audit tests | ~60 |

### 5.2 Files to Update

| File | Changes |
|------|---------|
| `apps/web_console/app.py` | Add "User Management" to navigation, import admin page |
| `apps/web_console/components/__init__.py` | Export new components |

---

## 6. Acceptance Criteria

### 6.1 Core Functionality
- [ ] CSRF protection with cryptographic tokens (`secrets.token_urlsafe`)
- [ ] User list page shows all users with roles and strategy counts
- [ ] Role changes require confirmation dialog
- [ ] Strategy assignment via multiselect with grant/revoke
- [ ] Search/filter users by ID and role

### 6.2 Session Invalidation [v1.2 EXPLICIT]
- [ ] Role change increments `session_version` explicitly
- [ ] Strategy grant increments `session_version` explicitly (no trigger dependency)
- [ ] Strategy revoke increments `session_version` explicitly

### 6.3 Audit Logging [v1.2 COMPREHENSIVE]
- [ ] Successful role changes logged via `log_admin_change()`
- [ ] Denied role changes logged via `log_action()` (invalid role, user not found, no-op)
- [ ] Successful strategy grants/revokes logged
- [ ] Denied strategy grants/revokes logged (already granted, not assigned)
- [ ] CSRF failures logged to `AuditLogger` (not just logger)
- [ ] Page-level permission denial logged to `AuditLogger`

### 6.4 Bulk Operations [v1.2 COMPLETE]
- [ ] Bulk role change with double-confirmation (preview + type CONFIRM)
- [ ] Bulk strategy grant with double-confirmation
- [ ] Bulk strategy revoke with double-confirmation
- [ ] Per-user result display for bulk operations

### 6.5 Tests and CI
- [ ] >85% test coverage for new code
- [ ] Tests for denied-attempt audit logging
- [ ] Tests for session_version increments
- [ ] Tests for bulk operations (partial failure handling)
- [ ] All existing tests pass
- [ ] `make ci-local` passes

---

## 7. Risk Assessment

| Risk | Mitigation |
|------|------------|
| CSRF bypass | Use `secrets.compare_digest` for timing-safe comparison |
| Session not invalidated | **[v1.2]** Explicit `session_version++` on ALL mutations (role, grant, revoke) - no trigger dependency |
| Permission escalation | Defense-in-depth: `has_permission()` check in page + audit logging on denial |
| Concurrent modifications | DB transactions ensure atomicity |
| Streamlit async issues | Sync wrappers with `ThreadPoolExecutor` + fresh event loops |
| Bulk operation mistakes | Double-confirmation (preview + type CONFIRM) for all bulk ops |

---

## 8. Review Checklist

### 8.1 Security Review Points
- [ ] CSRF tokens are cryptographically random (`secrets.token_urlsafe(32)`)
- [ ] Token comparison is timing-safe (`secrets.compare_digest`)
- [ ] Permission checks at page level with audit logging on denial
- [ ] All mutations logged to audit trail (success via `log_admin_change`, denied/failed via `log_action`)
- [ ] Session invalidation explicit for ALL mutations (no trigger dependency)
- [ ] Bulk operations require double-confirmation

### 8.2 Code Quality Review Points
- [ ] Type hints on all functions
- [ ] Docstrings with args/returns
- [ ] Error handling with specific messages
- [ ] Logging with structured extras
- [ ] No SQL injection (parameterized queries only)
- [ ] DB pool pattern documented and consistent

### 8.3 v1.2 Specific Review Points
- [ ] `grant_strategy` explicitly increments `session_version` (no trigger)
- [ ] Bulk strategy revoke implemented with double-confirm
- [ ] Page-level denial logged to `AuditLogger`
- [ ] Test coverage for all denied-attempt paths

---

**Plan Status:** Ready for v1.2 Review
**Version:** 1.2
**Changes Addressed:**
- Gemini: Fixed `grant_strategy` to explicitly increment `session_version` (no DB trigger exists)
- Codex: Added complete bulk strategy revoke with double-confirmation
- Codex: Added page-level permission denial audit logging via `AuditLogger`
- Codex: Clarified DB pool pattern (created at startup, passed to components)
- Codex: Expanded test plan with strategy flows, bulk ops, CSRF audit tests

**Next Step:** Request fresh Gemini + Codex plan review (no continuation IDs)
