# T6.3 Risk Analytics Dashboard - Implementation Plan

**Component:** T6.3-Risk-Analytics-Dashboard
**Branch:** feature/P4T3-T6.3-risk-analytics-dashboard
**Author:** Claude Code
**Date:** 2025-12-13
**Status:** Revision 4 - Addressing Async/Data Path Issues
**Review History:**
- v1: Gemini + Codex - APPROVED WITH MODIFICATIONS
- v2: Addressing all HIGH/MEDIUM/LOW issues
- v3: Addressing second round review feedback (real data path, integration tests, DRY)
- v4: Addressing async/sync bridge, data path consistency, RiskService contracts

---

## 1. Overview

This plan covers the implementation of the Risk Analytics Dashboard for the trading platform web console. The dashboard will display factor exposures, VaR/CVaR metrics, stress test results, and risk budget monitoring using the existing `libs/risk/` infrastructure from T2.3.

### 1.1 Requirements (from P4T3_TASK.md)

**Deliverables:**
- Factor exposure display (uses T2.3 `libs/risk/`)
- VaR/CVaR visualization
- Stress test results
- Risk budget monitoring

**Files to Create:**
- `apps/web_console/pages/risk.py`
- `apps/web_console/components/factor_exposure_chart.py`
- `apps/web_console/components/var_chart.py`
- `apps/web_console/components/stress_test_results.py`
- `apps/web_console/utils/api_client.py` **(NEW - per Gemini LOW)**
- `tests/apps/web_console/test_risk_dashboard.py`
- `docs/CONCEPTS/risk-dashboard.md`

### 1.2 Dependencies

| Dependency | Status | Notes |
|------------|--------|-------|
| T6.1a Auth/RBAC Core | Implemented | `libs/web_console_auth/permissions.py` exists |
| T6.2 Performance Dashboard | Implemented | Pattern reference at `apps/web_console/pages/performance.py` |
| T2.3 Portfolio Risk Analytics | Implemented | `libs/risk/` module with VaR, stress testing |
| T2.7 Factor Attribution | Implemented | `libs/risk/risk_decomposition.py` |

### 1.3 Scope Clarification (per Codex HIGH v3 - Unified Data Path)

**IMPORTANT - Single Data Path via RiskService:**
- This task implements **frontend UI with direct access to libs/risk/** analytics
- **NO HTTP/mock data** - dashboard uses RiskService → libs/risk/ exclusively
- **NO fetch_api usage** in risk.py - removed to avoid dual-path confusion (per Gemini LOW)
- Feature flag `FEATURE_RISK_DASHBOARD` gates access until fully tested

**Unified Data Path (per Codex HIGH):**
```
risk.py → RiskService (sync wrapper) → StrategyScopedDataAccess (async) → libs/risk/
```

**Real Data Integration:**
- Position data: `StrategyScopedDataAccess.get_positions()` → strategy-scoped positions
- Factor exposures: `libs/risk/risk_decomposition.py` → `PortfolioRiskEngine.decompose()`
- VaR/CVaR: `libs/risk/risk_decomposition.py` → `PortfolioRiskResult.var_95, var_99, cvar_95`
- Stress tests: `libs/risk/stress_testing.py` → `StressTestRunner.run_scenarios()`

**Data Sources for libs/risk (per Codex HIGH - Contract Defined):**
- Returns data: From feature store via `libs/feature_store/` (historical prices)
- Factor loadings: From `libs/risk/factor_model.py` using canonical 5 factors
- Covariance matrix: Computed from returns in `PortfolioRiskEngine`
- Stress scenarios: Predefined in `StressScenario` enum (GFC_2008, COVID_2020, etc.)

---

## 2. Architecture

### 2.1 Data Flow (per Codex MEDIUM - Using StrategyScopedDataAccess)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    RISK DASHBOARD DATA FLOW                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. User Request                                                     │
│     └─► @require_auth decorator validates session                    │
│         └─► has_permission(user, Permission.VIEW_PNL) check         │
│             └─► get_authorized_strategies(user) for scoping         │
│                 └─► Early exit if no strategies (Codex LOW)         │
│                                                                      │
│  2. Data Fetching (via StrategyScopedDataAccess + libs/risk)        │
│     └─► StrategyScopedDataAccess for position data (strategy-scoped)│
│         └─► Encrypted caching with user_id + strategy hash          │
│     └─► libs/risk/ for risk analytics (direct call, no HTTP)        │
│         ├─ PortfolioRiskEngine.decompose() → factor exposures       │
│         ├─ PortfolioRiskEngine → VaR/CVaR metrics                   │
│         └─ StressTestRunner.run_scenarios() → stress results        │
│                                                                      │
│  3. Schema Validation (per Codex LOW)                               │
│     └─► Validate required keys before rendering                     │
│         ├─ risk_metrics: total_risk, var_95, var_99, cvar_95        │
│         ├─ exposures: factor_name, exposure                         │
│         └─ stress_tests: scenario_name, portfolio_pnl               │
│                                                                      │
│  4. Rendering                                                        │
│     └─► Plotly charts via st.plotly_chart()                         │
│         ├─ factor_exposure_chart.py (bar chart)                     │
│         ├─ var_chart.py (VaR/CVaR gauge + history)                  │
│         └─ stress_test_results.py (table + waterfall)               │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 Permission Model (per Codex MEDIUM - Confirmed)

Using existing RBAC from `libs/web_console_auth/permissions.py`:

| Role | Access |
|------|--------|
| VIEWER | View risk metrics for assigned strategies |
| OPERATOR | View risk metrics for assigned strategies |
| ADMIN | View all strategies (`VIEW_ALL_STRATEGIES`) |

**Permission Check:** `Permission.VIEW_PNL`

**Rationale (Confirmed):**
- Risk dashboard is read-only analytics, similar to performance dashboard
- Both performance.py and risk.py use `VIEW_PNL` for consistency
- Creating a separate `VIEW_RISK` permission would fragment access without security benefit
- All roles (VIEWER, OPERATOR, ADMIN) already have `VIEW_PNL` permission
- **Decision:** Confirmed - use `VIEW_PNL`, no new permission needed

### 2.3 Caching Strategy (per Codex LOW - Fixed)

Following `performance.py` pattern with enhanced isolation:

```python
@st.cache_data(ttl=300)
def fetch_risk_metrics(
    strategies: tuple[str, ...],  # Tuple for hashability
    user_id: str | None,
) -> dict[str, Any]:
    """Fetch risk metrics with proper cache isolation.

    Cache key includes:
    - user_id: Prevents cross-user data leakage
    - strategies: Prevents cross-strategy data leakage (sorted tuple)
    """
    if user_id is None:
        raise RuntimeError("Missing user_id; refuse to cache or fetch risk data")
    # ... fetch logic
```

**Cache Key Components:**
- `user_id` - Required, refuse to cache if missing
- `strategies` - Sorted tuple of authorized strategy IDs
- Both parameters included to prevent any data leakage

### 2.4 Async/Sync Bridge (per Gemini MEDIUM v3 + Codex MEDIUM v3)

**Problem:** `RiskService` and `StrategyScopedDataAccess` are async, but Streamlit runs synchronously.

**Solution:** Use `concurrent.futures.ThreadPoolExecutor` pattern (proven in codebase):

```python
"""Async execution helpers for Streamlit pages."""

from __future__ import annotations

import asyncio
from concurrent.futures import ThreadPoolExecutor
from typing import Any, Callable, TypeVar

T = TypeVar("T")

# Module-level executor for reuse
_executor = ThreadPoolExecutor(max_workers=4)


def run_async(coro: Callable[..., Any], *args: Any, **kwargs: Any) -> T:
    """Execute async coroutine from sync Streamlit context.

    Uses ThreadPoolExecutor to avoid event loop conflicts in Streamlit.
    Pattern from permissions.py validate_session_sync.
    """
    def _run() -> T:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(coro(*args, **kwargs))
        finally:
            loop.close()

    future = _executor.submit(_run)
    return future.result(timeout=30)  # 30s timeout
```

**Usage in risk.py:**
```python
from apps.web_console.utils.async_helpers import run_async

def fetch_risk_data() -> RiskDashboardData:
    user = safe_current_user()
    scoped_access = get_scoped_data_access(db_pool, redis_client, user)
    service = RiskService(scoped_access)
    return run_async(service.get_risk_dashboard_data)
```

**Cache Boundaries:**
- `@st.cache_data(ttl=300)` wraps the sync `fetch_risk_data()` function
- Cache key includes `user_id` + `strategies` tuple (from function args)
- Async execution happens INSIDE the cached function, not at cache boundary

### 2.5 Risk Budget Configuration (per Gemini MEDIUM - Resolved)

**Decision:** Static configuration in `config.py` for MVP.

```python
# apps/web_console/config.py
# Risk budget limits (daily VaR as fraction)
RISK_BUDGET_VAR_LIMIT = float(os.getenv("RISK_BUDGET_VAR_LIMIT", "0.05"))  # 5% daily VaR limit
RISK_BUDGET_WARNING_THRESHOLD = 0.8  # Show warning at 80% utilization
```

**Rationale:**
- Simple static limit sufficient for MVP
- Per-strategy limits can be added later via database if needed
- Environment variable allows runtime configuration

---

## 3. Implementation Details

### 3.1 Risk Service Layer: `apps/web_console/services/risk_service.py` (per Codex HIGH)

**NEW FILE** - Service layer that integrates with libs/risk/ for real data:

```python
"""Risk analytics service layer using libs/risk/ infrastructure."""

from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Any

import numpy as np

from apps.web_console.data.strategy_scoped_queries import StrategyScopedDataAccess
from libs.risk.risk_decomposition import PortfolioRiskEngine, PortfolioRiskResult
from libs.risk.stress_testing import StressTestRunner, StressScenario, StressTestResult

logger = logging.getLogger(__name__)


@dataclass
class RiskDashboardData:
    """Container for risk dashboard data."""
    risk_metrics: dict[str, float]
    factor_exposures: list[dict[str, Any]]
    stress_tests: list[dict[str, Any]]
    var_history: list[dict[str, Any]]


class RiskService:
    """Service for fetching and computing risk analytics.

    Uses StrategyScopedDataAccess for position data and libs/risk/ for analytics.
    """

    def __init__(self, scoped_access: StrategyScopedDataAccess):
        self._scoped_access = scoped_access

    async def get_risk_dashboard_data(self) -> RiskDashboardData:
        """Fetch all risk data for dashboard.

        Returns:
            RiskDashboardData with metrics, exposures, stress tests, history

        Raises:
            PermissionError: If user has no strategy access
        """
        # Get positions via strategy-scoped access
        positions = await self._scoped_access.get_positions(limit=1000)

        if not positions:
            return RiskDashboardData(
                risk_metrics={},
                factor_exposures=[],
                stress_tests=[],
                var_history=[],
            )

        # Build portfolio weights from positions
        weights = self._build_weights(positions)

        # Compute risk metrics via libs/risk/
        risk_result = await self._compute_risk_metrics(weights)

        # Run stress tests
        stress_results = await self._run_stress_tests(weights)

        # Get VaR history (per Codex v4 - defined source)
        var_history = await self._get_var_history()

        return RiskDashboardData(
            risk_metrics=self._format_risk_metrics(risk_result),
            factor_exposures=self._format_factor_exposures(risk_result),
            stress_tests=self._format_stress_tests(stress_results),
            var_history=var_history,
        )

    async def _get_var_history(self, days: int = 30) -> list[dict[str, Any]]:
        """Get 30-day rolling VaR history from pnl_daily table.

        Data Source (per Codex v4 - Contract Defined):
        - Source: StrategyScopedDataAccess.get_pnl_summary()
        - Computation: Daily VaR from realized returns
        """
        from datetime import date, timedelta
        end_date = date.today()
        start_date = end_date - timedelta(days=days)

        pnl_data = await self._scoped_access.get_pnl_summary(start_date, end_date)

        if not pnl_data:
            return []

        # Compute rolling VaR from daily P&L
        var_history = []
        for record in pnl_data:
            var_history.append({
                "date": record.get("trade_date"),
                "var_95": abs(record.get("daily_pnl", 0) * 1.65),  # Simplified
            })
        return var_history

    def _build_weights(self, positions: list[dict[str, Any]]) -> dict[str, float]:
        """Build portfolio weights from positions."""
        total_value = sum(abs(p.get("market_value", 0)) for p in positions)
        if total_value == 0:
            return {}
        return {
            p["symbol"]: p.get("market_value", 0) / total_value
            for p in positions
            if p.get("symbol")
        }

    async def _compute_risk_metrics(self, weights: dict[str, float]) -> PortfolioRiskResult | None:
        """Compute risk decomposition using libs/risk/.

        Data Sources (per Codex HIGH v3 - Contract Defined):
        - Returns: libs/feature_store/ → 252-day historical returns
        - Factor loadings: libs/risk/factor_model.py → 5 canonical factors
        - Covariance: Computed from returns in PortfolioRiskEngine
        """
        if not weights:
            return None

        symbols = list(weights.keys())
        weight_array = np.array([weights[s] for s in symbols])

        # Get historical returns from feature store
        from libs.feature_store.online_store import OnlineFeatureStore
        feature_store = OnlineFeatureStore()
        returns_df = await feature_store.get_returns(symbols, lookback_days=252)

        # Compute risk decomposition
        engine = PortfolioRiskEngine(returns_df)
        return engine.decompose(weight_array)

    async def _run_stress_tests(self, weights: dict[str, float]) -> list[StressTestResult]:
        """Run predefined stress scenarios.

        Data Sources (per Codex HIGH v3 - Contract Defined):
        - Scenarios: Predefined in StressScenario enum with factor shocks
        - Factor sensitivities: From PortfolioRiskEngine decomposition
        """
        if not weights:
            return []

        scenarios = [
            StressScenario.GFC_2008,
            StressScenario.COVID_2020,
            StressScenario.RATE_HIKE_2022,
            StressScenario.RATE_SHOCK,
        ]

        symbols = list(weights.keys())
        weight_array = np.array([weights[s] for s in symbols])

        runner = StressTestRunner(scenarios)
        return runner.run_scenarios(weight_array, symbols)
```

### 3.2 Shared API Client: `apps/web_console/utils/api_client.py` (per Gemini LOW)

**NEW FILE** - Extract common API client logic and `safe_current_user()` to reduce duplication:

```python
"""Shared API client and helpers for web console pages."""

from __future__ import annotations

from collections.abc import Mapping
from typing import Any, cast

import requests

from apps.web_console.auth.permissions import get_authorized_strategies
from apps.web_console.auth.session_manager import get_current_user
from apps.web_console.config import API_REQUEST_TIMEOUT, ENDPOINTS


def safe_current_user() -> Mapping[str, Any]:
    """Return current user when session context exists (per Gemini LOW - centralized).

    Streamlit tests render components without an authenticated session; in those cases
    fall back to an empty mapping so pages can still render in isolation.

    Returns:
        User dict from session or empty dict if no session
    """
    try:
        user = get_current_user()
    except RuntimeError:
        return {}
    return user if isinstance(user, Mapping) else {}


def get_auth_headers(user: Mapping[str, Any]) -> dict[str, str]:
    """Build X-User-* headers for API requests.

    Args:
        user: User dict from session (must have role, user_id)

    Returns:
        Headers dict with X-User-Role, X-User-Id, X-User-Strategies
    """
    headers: dict[str, str] = {}
    role = user.get("role")
    user_id = user.get("user_id")
    strategies = get_authorized_strategies(user)

    if role:
        headers["X-User-Role"] = str(role)
    if user_id:
        headers["X-User-Id"] = str(user_id)
    if strategies:
        headers["X-User-Strategies"] = ",".join(sorted(strategies))

    return headers


def fetch_api(
    endpoint: str,
    user: Mapping[str, Any],
    params: dict[str, Any] | None = None,
) -> dict[str, Any]:
    """Fetch from API endpoint with auth headers.

    Args:
        endpoint: Key from ENDPOINTS dict
        user: User dict from session
        params: Optional query parameters

    Returns:
        JSON response as dict

    Raises:
        requests.RequestException: On network/HTTP errors
        requests.HTTPError: On 4xx/5xx responses
        ValueError: On JSON decode failure
    """
    url = ENDPOINTS[endpoint]
    headers = get_auth_headers(user)

    response = requests.get(url, params=params, headers=headers, timeout=API_REQUEST_TIMEOUT)
    response.raise_for_status()  # Raises HTTPError for 4xx/5xx

    try:
        return cast(dict[str, Any], response.json())
    except ValueError as e:
        raise ValueError(f"Invalid JSON response from {endpoint}: {e}") from e
```

### 3.3 Main Page: `apps/web_console/pages/risk.py` (per Codex HIGH v3 - Unified Path)

```python
"""Risk Analytics Dashboard page.

NOTE: This page uses RiskService directly - NO fetch_api/HTTP calls (per Gemini LOW).
Data flows: risk.py → RiskService (sync wrapper) → StrategyScopedDataAccess → libs/risk/
"""

from __future__ import annotations

import os
from typing import Any

import streamlit as st

from apps.web_console.auth.permissions import Permission, get_authorized_strategies, has_permission
from apps.web_console.auth.session_manager import require_auth
from apps.web_console.components.factor_exposure_chart import render_factor_exposure
from apps.web_console.components.var_chart import render_var_metrics
from apps.web_console.components.stress_test_results import render_stress_tests
from apps.web_console.config import RISK_BUDGET_VAR_LIMIT
from apps.web_console.data.strategy_scoped_queries import get_scoped_data_access
from apps.web_console.services.risk_service import RiskService, RiskDashboardData
from apps.web_console.utils.api_client import safe_current_user
from apps.web_console.utils.async_helpers import run_async
from apps.web_console.utils.db import get_db_pool, get_redis_client

FEATURE_RISK_DASHBOARD = os.getenv("FEATURE_RISK_DASHBOARD", "false").lower() in {
    "1", "true", "yes", "on",
}


@st.cache_data(ttl=300)
def fetch_risk_data(user_id: str, strategies: tuple[str, ...]) -> RiskDashboardData:
    """Fetch risk data via RiskService with caching.

    Args:
        user_id: Required for cache isolation
        strategies: Tuple of authorized strategies (hashable for cache)

    Returns:
        RiskDashboardData from RiskService
    """
    if not user_id:
        raise RuntimeError("Missing user_id; refuse to fetch risk data")

    user = safe_current_user()
    db_pool = get_db_pool()
    redis_client = get_redis_client()
    scoped_access = get_scoped_data_access(db_pool, redis_client, user)
    service = RiskService(scoped_access)

    # Sync wrapper for async RiskService (per Gemini MEDIUM v3)
    return run_async(service.get_risk_dashboard_data)
```

**Key Functions:**
- `safe_current_user()` - From shared api_client.py (per Gemini LOW)
- `fetch_risk_data(user_id, strategies)` - Cached sync wrapper for async RiskService
- `render_risk_overview()` - VaR/CVaR metrics display
- `render_factor_section()` - Factor exposure visualization
- `render_stress_section()` - Stress test results

**Zero-Strategy Handling (per Codex LOW v3):**
```python
@require_auth
def main() -> None:
    # ... permission checks ...

    authorized_strategies = get_authorized_strategies(user)
    if not authorized_strategies:
        st.warning("You don't have access to any strategies. Contact administrator.")
        st.stop()  # Early exit - no API calls
```

### 3.4 Component: `factor_exposure_chart.py`

Horizontal bar chart showing factor loadings:

```python
"""Factor exposure visualization component."""

from __future__ import annotations

from collections.abc import Sequence
from typing import Any

import plotly.graph_objects as go
import streamlit as st

CANONICAL_FACTORS = [
    "momentum_12_1", "book_to_market", "roe",
    "log_market_cap", "realized_vol"
]

def render_factor_exposure(exposures: Sequence[dict[str, Any]]) -> go.Figure | None:
    """Render horizontal bar chart of factor exposures.

    Args:
        exposures: List of dicts with 'factor_name' and 'exposure' keys

    Returns:
        Plotly Figure or None if no data
    """
    if not exposures:
        st.info("No factor exposure data available.")
        return None

    # Color positive exposures green, negative red
    # Order by canonical factor order
    # Show exposure values as percentage annotations
```

### 3.5 Component: `var_chart.py`

VaR/CVaR visualization with risk budget monitoring:

```python
"""VaR/CVaR visualization component."""

from __future__ import annotations

from collections.abc import Sequence
from typing import Any

import plotly.graph_objects as go
import streamlit as st

from apps.web_console.config import RISK_BUDGET_VAR_LIMIT, RISK_BUDGET_WARNING_THRESHOLD


def render_var_metrics(
    risk_data: dict[str, Any],
    var_limit: float = RISK_BUDGET_VAR_LIMIT,
) -> None:
    """Render VaR/CVaR metrics with gauge and history.

    Displays:
    - Current VaR 95% and 99%
    - CVaR 95% (expected shortfall)
    - Risk budget utilization gauge
    """

def render_var_gauge(var_value: float, var_limit: float) -> go.Figure:
    """Render gauge chart for VaR utilization."""

def render_var_history(history: Sequence[dict[str, Any]]) -> go.Figure | None:
    """Render 30-day rolling VaR line chart."""
```

### 3.6 Component: `stress_test_results.py`

Stress test visualization:

```python
"""Stress test results visualization component."""

from __future__ import annotations

from collections.abc import Sequence
from typing import Any

import plotly.graph_objects as go
import streamlit as st

PREDEFINED_SCENARIOS = ["GFC_2008", "COVID_2020", "RATE_HIKE_2022", "RATE_SHOCK"]


def render_stress_tests(results: Sequence[dict[str, Any]]) -> None:
    """Render stress test results table and charts.

    Shows:
    - Summary table with scenario name, P&L impact
    - Factor contribution waterfall for selected scenario
    - Worst position details
    """

def render_scenario_table(results: Sequence[dict[str, Any]]) -> None:
    """Render stress test summary table."""

def render_factor_waterfall(scenario_result: dict[str, Any]) -> go.Figure | None:
    """Render factor contribution waterfall chart."""
```

### 3.7 Schema Validation (per Codex LOW)

**Validate required keys before rendering to prevent runtime errors:**

```python
"""Schema validation helpers for risk dashboard data."""

from typing import Any

RISK_METRICS_REQUIRED_KEYS = {"total_risk", "var_95", "var_99", "cvar_95"}
EXPOSURE_REQUIRED_KEYS = {"factor_name", "exposure"}
STRESS_TEST_REQUIRED_KEYS = {"scenario_name", "portfolio_pnl"}


def validate_risk_metrics(data: dict[str, Any]) -> bool:
    """Validate risk_metrics has required keys."""
    if not data:
        return False
    return RISK_METRICS_REQUIRED_KEYS.issubset(data.keys())


def validate_exposures(exposures: list[dict[str, Any]]) -> list[dict[str, Any]]:
    """Filter exposures to only valid entries."""
    return [e for e in exposures if EXPOSURE_REQUIRED_KEYS.issubset(e.keys())]


def validate_stress_tests(results: list[dict[str, Any]]) -> list[dict[str, Any]]:
    """Filter stress tests to only valid entries."""
    return [r for r in results if STRESS_TEST_REQUIRED_KEYS.issubset(r.keys())]
```

**Validation Pattern in Renderers:**
```python
def render_factor_exposure(exposures: Sequence[dict[str, Any]]) -> go.Figure | None:
    # Validate before rendering
    valid_exposures = validate_exposures(list(exposures))
    if not valid_exposures:
        st.info("No valid factor exposure data available.")
        return None
    # ... render logic
```

### 3.8 Config Updates (per Gemini LOW - Safe Parsing)

Add to `apps/web_console/config.py`:

```python
def _safe_float(env_var: str, default: float) -> float:
    """Safely parse float from environment variable (per Gemini LOW).

    Returns default if env var is missing or malformed.
    """
    value = os.getenv(env_var)
    if value is None:
        return default
    try:
        return float(value)
    except (ValueError, TypeError):
        import logging
        logging.getLogger(__name__).warning(
            f"Invalid float value for {env_var}: {value!r}, using default {default}"
        )
        return default


# Risk budget configuration with safe parsing
RISK_BUDGET_VAR_LIMIT = _safe_float("RISK_BUDGET_VAR_LIMIT", 0.05)  # 5% daily VaR limit
RISK_BUDGET_WARNING_THRESHOLD = _safe_float("RISK_BUDGET_WARNING_THRESHOLD", 0.8)  # 80%
```

---

## 4. Error Handling (per Codex v4 - Pure RiskService Path)

**NO HTTP/mock fallback** - aligned with unified RiskService data path:

```python
def render_risk_dashboard() -> None:
    """Render risk dashboard with RiskService error handling.

    Error handling for pure RiskService path (no HTTP/mock fallback).
    """
    try:
        data = fetch_risk_data(user_id, strategies)

        # Schema validation before rendering (per Codex LOW v3)
        if not validate_risk_metrics(data.risk_metrics):
            st.warning("Risk metrics incomplete. Some data may be unavailable.")

        render_risk_overview(data.risk_metrics)
        render_factor_section(data.factor_exposures)
        render_stress_section(data.stress_tests)
        render_var_history(data.var_history)

    except PermissionError as e:
        st.error(f"Access denied: {e}")
        st.stop()
    except RuntimeError as e:
        st.error(f"Configuration error: {e}")
        st.stop()
    except Exception as e:
        logger.exception("risk_dashboard_error")
        st.error("Failed to load risk data. Please try again later.")
```

**Error Handling Matrix (RiskService Path):**

| Error Type | Source | User Message | Action |
|------------|--------|--------------|--------|
| PermissionError | StrategyScopedDataAccess | "Access denied..." | st.error() + st.stop() |
| RuntimeError | Missing user_id/config | "Configuration error..." | st.error() + st.stop() |
| TimeoutError | run_async timeout | "Request timed out..." | st.error() |
| ValidationError | Schema validation | "Data incomplete..." | st.warning() + partial render |
| Empty data | No positions | "No risk data available..." | st.info() |
| Exception | Unexpected | "Failed to load..." | st.error() + log |

---

## 5. Testing Strategy (per Codex MEDIUM - Enhanced with Integration Tests)

### 5.1 Unit Tests

File: `tests/apps/web_console/test_risk_dashboard.py`

```python
"""Tests for risk analytics dashboard."""

import pytest
from unittest.mock import patch, MagicMock
import requests

class TestRiskDashboardPage:
    """Tests for risk.py page."""

    def test_permission_check_enforced(self):
        """Verify VIEW_PNL permission is required."""

    def test_strategy_scoping_applied(self):
        """Verify authorized_strategies passed to API."""

    def test_feature_flag_disabled(self):
        """Verify page shows disabled message when flag off."""

    def test_api_error_handling_403(self):
        """Verify 403 shows permission error and stops."""

    def test_api_error_handling_401(self):
        """Verify 401 shows session expired and stops."""

    def test_api_error_handling_5xx(self):
        """Verify 5xx falls back to mock data with warning."""

    def test_api_error_handling_network(self):
        """Verify network errors fall back to mock data."""

    def test_api_error_handling_json_decode(self):
        """Verify JSON decode errors fall back to mock data."""

    def test_empty_data_shows_info(self):
        """Verify empty response shows info message."""


class TestApiClient:
    """Tests for api_client.py shared utility."""

    def test_headers_include_role(self):
        """Verify X-User-Role header is set."""

    def test_headers_include_user_id(self):
        """Verify X-User-Id header is set."""

    def test_headers_include_sorted_strategies(self):
        """Verify X-User-Strategies header is sorted."""

    def test_fetch_raises_on_http_error(self):
        """Verify HTTPError is raised for 4xx/5xx."""


class TestCacheIsolation:
    """Tests for cache key isolation."""

    def test_cache_requires_user_id(self):
        """Verify RuntimeError raised if user_id missing."""

    def test_cache_key_includes_strategies(self):
        """Verify different strategies get different cache entries."""

    def test_cache_key_includes_user_id(self):
        """Verify different users get different cache entries."""


class TestFactorExposureChart:
    """Tests for factor_exposure_chart.py."""

    def test_render_with_valid_data(self):
        """Verify chart renders with valid exposures."""

    def test_render_empty_data(self):
        """Verify info message shown for empty data."""

    def test_factor_ordering(self):
        """Verify factors ordered canonically."""


class TestVarChart:
    """Tests for var_chart.py."""

    def test_var_gauge_renders(self):
        """Verify gauge chart renders correctly."""

    def test_var_gauge_shows_warning_at_threshold(self):
        """Verify warning indicator at 80% utilization."""

    def test_var_history_renders(self):
        """Verify history line chart renders."""


class TestStressTestResults:
    """Tests for stress_test_results.py."""

    def test_scenario_table_renders(self):
        """Verify scenario table renders."""

    def test_waterfall_chart_renders(self):
        """Verify factor waterfall chart renders."""
```

### 5.2 Integration Tests (per Codex MEDIUM v3 - End-to-End)

File: `tests/apps/web_console/test_risk_integration.py`

```python
"""Integration tests for risk dashboard with real libs/risk pipeline."""

import pytest
import numpy as np
from unittest.mock import AsyncMock, MagicMock, patch

class TestRiskServiceIntegration:
    """Integration tests for RiskService with StrategyScopedDataAccess."""

    @pytest.fixture
    def mock_scoped_access(self):
        """Create mock StrategyScopedDataAccess."""
        access = MagicMock()
        access.get_positions = AsyncMock(return_value=[
            {"symbol": "AAPL", "market_value": 10000},
            {"symbol": "GOOGL", "market_value": 15000},
        ])
        access.authorized_strategies = ["alpha_baseline"]
        access.user_id = "user_123"
        return access

    async def test_risk_service_uses_scoped_access(self, mock_scoped_access):
        """Verify RiskService fetches positions via StrategyScopedDataAccess."""
        from apps.web_console.services.risk_service import RiskService
        service = RiskService(mock_scoped_access)
        await service.get_risk_dashboard_data()
        mock_scoped_access.get_positions.assert_called_once()

    async def test_strategy_scoping_enforced(self, mock_scoped_access):
        """Verify only authorized strategies' positions are fetched."""
        mock_scoped_access.get_positions = AsyncMock(side_effect=PermissionError("No strategy access"))
        from apps.web_console.services.risk_service import RiskService
        service = RiskService(mock_scoped_access)
        with pytest.raises(PermissionError):
            await service.get_risk_dashboard_data()


class TestEndToEndRiskPipeline:
    """End-to-end tests covering StrategyScopedDataAccess → RiskService → render (per Codex v4)."""

    @pytest.fixture
    def mock_feature_store(self):
        """Mock feature store with realistic returns data (per Codex v4 - proper shape)."""
        import pandas as pd
        with patch("apps.web_console.services.risk_service.OnlineFeatureStore") as mock:
            instance = mock.return_value
            # 252 days of returns for AAPL, GOOGL - DataFrame with symbol columns
            returns_data = pd.DataFrame(
                np.random.randn(252, 2) * 0.02,
                columns=["AAPL", "GOOGL"],
                index=pd.date_range(end=pd.Timestamp.today(), periods=252, freq="B")
            )
            instance.get_returns = AsyncMock(return_value=returns_data)
            yield mock

    @pytest.fixture
    def mock_factor_model(self):
        """Mock factor model to avoid external I/O (per Codex v4)."""
        with patch("libs.risk.risk_decomposition.FactorModel") as mock:
            instance = mock.return_value
            # Return canonical 5-factor loadings
            instance.get_factor_loadings = MagicMock(return_value=np.random.randn(2, 5))
            yield mock

    async def test_full_pipeline_produces_valid_data(
        self, mock_scoped_access, mock_feature_store, mock_factor_model
    ):
        """Verify end-to-end pipeline produces validated RiskDashboardData."""
        from apps.web_console.services.risk_service import RiskService
        from apps.web_console.utils.validators import validate_risk_metrics

        service = RiskService(mock_scoped_access)
        result = await service.get_risk_dashboard_data()

        # Verify data passes schema validation
        assert validate_risk_metrics(result.risk_metrics)
        assert len(result.factor_exposures) > 0
        assert len(result.stress_tests) > 0
        # Verify VaR history is populated (per Codex v4)
        assert isinstance(result.var_history, list)

    async def test_empty_positions_returns_empty_data(self, mock_feature_store, mock_factor_model):
        """Verify empty positions produces empty (not error) result."""
        access = MagicMock()
        access.get_positions = AsyncMock(return_value=[])
        access.get_pnl_summary = AsyncMock(return_value=[])

        from apps.web_console.services.risk_service import RiskService
        service = RiskService(access)
        result = await service.get_risk_dashboard_data()

        assert result.risk_metrics == {}
        assert result.factor_exposures == []
        assert result.stress_tests == []
        assert result.var_history == []


class TestAsyncSyncBridge:
    """Tests for async/sync bridge pattern in Streamlit."""

    def test_run_async_executes_coroutine(self):
        """Verify run_async properly executes async functions."""
        from apps.web_console.utils.async_helpers import run_async

        async def sample_coro() -> str:
            return "test_result"

        result = run_async(sample_coro)
        assert result == "test_result"

    def test_run_async_handles_timeout(self):
        """Verify run_async respects timeout."""
        import asyncio
        from apps.web_console.utils.async_helpers import run_async

        async def slow_coro() -> str:
            await asyncio.sleep(60)
            return "never_returned"

        with pytest.raises(Exception):  # TimeoutError or concurrent.futures.TimeoutError
            run_async(slow_coro)


class TestUIEdgeCases:
    """Tests for UI edge cases: zero strategies, feature flag off (per Codex v4)."""

    @pytest.fixture
    def mock_streamlit(self):
        """Mock streamlit functions."""
        with patch("apps.web_console.pages.risk.st") as mock_st:
            mock_st.warning = MagicMock()
            mock_st.info = MagicMock()
            mock_st.error = MagicMock()
            mock_st.stop = MagicMock(side_effect=SystemExit)
            yield mock_st

    def test_zero_strategies_shows_warning_and_stops(self, mock_streamlit):
        """Verify users with zero strategies see warning and no RiskService call."""
        with patch("apps.web_console.pages.risk.get_authorized_strategies") as mock_auth:
            mock_auth.return_value = []
            with patch("apps.web_console.pages.risk.RiskService") as mock_service:
                with pytest.raises(SystemExit):
                    from apps.web_console.pages.risk import main
                    main()

                # Verify warning shown and st.stop called
                mock_streamlit.warning.assert_called_once()
                assert "no strategies" in mock_streamlit.warning.call_args[0][0].lower()
                mock_streamlit.stop.assert_called_once()
                # Verify RiskService was never instantiated
                mock_service.assert_not_called()

    def test_feature_flag_off_shows_disabled(self, mock_streamlit):
        """Verify feature flag off shows disabled message and no RiskService call."""
        with patch.dict("os.environ", {"FEATURE_RISK_DASHBOARD": "false"}):
            with patch("apps.web_console.pages.risk.RiskService") as mock_service:
                from importlib import reload
                import apps.web_console.pages.risk as risk_module
                reload(risk_module)  # Reload to pick up env var

                # Verify info message shown
                mock_streamlit.info.assert_called()
                assert "not available" in mock_streamlit.info.call_args[0][0].lower()
                # Verify RiskService was never instantiated
                mock_service.assert_not_called()


class TestSchemaValidation:
    """Contract tests for data schemas."""

    def test_risk_metrics_schema_validation(self):
        """Verify risk metrics validation catches missing keys."""
        from apps.web_console.utils.validators import validate_risk_metrics
        valid = {"total_risk": 0.15, "var_95": 0.025, "var_99": 0.035, "cvar_95": 0.032}
        invalid = {"total_risk": 0.15}  # Missing keys
        assert validate_risk_metrics(valid) is True
        assert validate_risk_metrics(invalid) is False

    def test_exposure_schema_filters_invalid(self):
        """Verify exposure validation filters invalid entries."""
        from apps.web_console.utils.validators import validate_exposures
        exposures = [
            {"factor_name": "momentum", "exposure": 0.5},
            {"factor_name": "invalid"},  # Missing exposure
            {"exposure": 0.3},  # Missing factor_name
        ]
        valid = validate_exposures(exposures)
        assert len(valid) == 1
        assert valid[0]["factor_name"] == "momentum"
```

### 5.3 Test Data Fixtures

```python
@pytest.fixture
def mock_user():
    return {
        "user_id": "user_123",
        "role": "viewer",
        "email": "test@example.com",
    }

@pytest.fixture
def mock_strategies():
    return ["alpha_baseline", "momentum"]

@pytest.fixture
def mock_risk_metrics():
    return {
        "risk_metrics": {
            "total_risk": 0.15,
            "factor_risk": 0.12,
            "specific_risk": 0.09,
            "var_95": 0.025,
            "var_99": 0.035,
            "cvar_95": 0.032,
        },
        "var_history": [
            {"date": "2024-01-01", "var_95": 0.024},
            {"date": "2024-01-02", "var_95": 0.025},
        ]
    }

@pytest.fixture
def mock_factor_exposures():
    return {
        "exposures": [
            {"factor_name": "momentum_12_1", "exposure": 0.45},
            {"factor_name": "book_to_market", "exposure": -0.23},
            {"factor_name": "roe", "exposure": 0.12},
            {"factor_name": "log_market_cap", "exposure": 0.67},
            {"factor_name": "realized_vol", "exposure": -0.15},
        ]
    }

@pytest.fixture
def mock_stress_results():
    return {
        "stress_tests": [
            {
                "scenario_name": "GFC_2008",
                "portfolio_pnl": -0.182,
                "factor_impacts": {"book_to_market": -0.08, "realized_vol": -0.05},
            },
            {
                "scenario_name": "COVID_2020",
                "portfolio_pnl": -0.145,
                "factor_impacts": {"momentum_12_1": -0.06, "realized_vol": -0.04},
            },
        ]
    }
```

---

## 6. Files to Create/Modify

### 6.1 New Files

| File | Purpose |
|------|---------|
| `apps/web_console/pages/risk.py` | Main risk dashboard page (NO fetch_api) |
| `apps/web_console/components/factor_exposure_chart.py` | Factor exposure bar chart |
| `apps/web_console/components/var_chart.py` | VaR/CVaR visualization |
| `apps/web_console/components/stress_test_results.py` | Stress test table + waterfall |
| `apps/web_console/utils/api_client.py` | Shared `safe_current_user()` + API helpers |
| `apps/web_console/utils/async_helpers.py` | Async/sync bridge for Streamlit (per Gemini MEDIUM v3) |
| `apps/web_console/utils/validators.py` | Schema validation helpers (per Codex LOW v3) |
| `apps/web_console/services/risk_service.py` | Risk service with concrete data sources (per Codex HIGH v3) |
| `tests/apps/web_console/test_risk_dashboard.py` | Unit tests |
| `tests/apps/web_console/test_risk_integration.py` | Integration tests with real libs/risk (per Codex MEDIUM v3) |
| `docs/CONCEPTS/risk-dashboard.md` | User documentation |

### 6.2 Files to Modify (per Gemini MEDIUM - Refactor for DRY)

| File | Change |
|------|--------|
| `apps/web_console/config.py` | Add risk budget config + safe float parsing (per Gemini LOW) |
| `apps/web_console/pages/performance.py` | Refactor to use shared `api_client.py` and `safe_current_user()` |

---

## 7. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Backend API not ready | High | Medium | Mock data with st.warning() |
| Permission creep | Low | Low | Confirmed: use VIEW_PNL |
| Data leakage | Low | High | Cache key includes user_id + strategies |
| Chart rendering errors | Low | Low | Empty state handling, error boundaries |
| Cross-user cache pollution | Low | High | Refuse to cache if user_id missing |

---

## 8. Implementation Order

1. **Shared utility** - Create `apps/web_console/utils/api_client.py`
2. **Config changes** - Add endpoints + risk budget to config.py
3. **Main page** - Create risk.py with auth/permission checks
4. **Factor chart** - Create factor_exposure_chart.py
5. **VaR chart** - Create var_chart.py with risk budget gauge
6. **Stress tests** - Create stress_test_results.py
7. **Tests** - Create test_risk_dashboard.py
8. **Documentation** - Create risk-dashboard.md

---

## 9. Acceptance Criteria

From P4T3_TASK.md T6.3 deliverables:

- [ ] Factor exposure display (uses T2.3 libs/risk/)
- [ ] VaR/CVaR visualization with risk budget gauge
- [ ] Stress test results display
- [ ] Risk budget monitoring (from config.py with safe parsing)
- [ ] Permission checks enforced (VIEW_PNL)
- [ ] Strategy scoping via StrategyScopedDataAccess (not just headers)
- [ ] Caching with user+strategy isolation
- [ ] Error handling for PermissionError/network/data errors
- [ ] Empty state handling (including zero-strategy users)
- [ ] Feature flag gated (FEATURE_RISK_DASHBOARD)
- [ ] Real data via RiskService + libs/risk/ (no mock fallback)
- [ ] Schema validation before rendering
- [ ] Unit tests with >80% coverage
- [ ] Integration tests for service layer and header construction
- [ ] performance.py refactored to use shared api_client.py

---

## 10. Resolved Questions

| Question | Resolution |
|----------|------------|
| Backend API scope | Frontend only - mock data until backend ready |
| Risk budget source | Static config in config.py (RISK_BUDGET_VAR_LIMIT) |
| Historical data range | 30 days for VaR history chart |
| Permission for risk data | Confirmed: VIEW_PNL (same as performance.py) |

---

## 11. Review Feedback Addressed

### Gemini Review (v1)

| Issue | Severity | Resolution |
|-------|----------|------------|
| Backend implementation gap | HIGH | Clarified: frontend-only scope with mock data |
| Risk budget source unresolved | MEDIUM | Added RISK_BUDGET_VAR_LIMIT to config.py |
| Code duplication in _fetch | LOW | Created shared api_client.py utility |

### Codex Review (v1)

| Issue | Severity | Resolution |
|-------|----------|------------|
| Permission model confirmation | MEDIUM | Confirmed VIEW_PNL is appropriate |
| Backend contract not documented | MEDIUM | Added full API contracts in Section 3.6 |
| Cache key missing strategies | LOW | Cache key now includes user_id + strategies tuple |
| Tests missing coverage | LOW | Added tests for headers, scoping, feature flag, errors |
| Error handling incomplete | LOW | Added HTTPError/JSON decode handling with matrix |

### Gemini Review (v2)

| Issue | Severity | Resolution |
|-------|----------|------------|
| performance.py refactor omitted | MEDIUM | Added to Files to Modify - will use api_client.py |
| _safe_current_user duplication | LOW | Moved to shared api_client.py utility |
| Config float parsing unsafe | LOW | Added _safe_float() helper with try-except |

### Codex Review (v2)

| Issue | Severity | Resolution |
|-------|----------|------------|
| Frontend-only fails requirements | HIGH | Changed to real data via libs/risk/ + RiskService |
| StrategyScopedDataAccess not used | MEDIUM | Added RiskService using StrategyScopedDataAccess |
| Missing integration tests | MEDIUM | Added test_risk_integration.py with contract tests |
| Zero-strategy handling missing | LOW | Added early exit with st.warning() |
| Data validation missing | LOW | Added schema validation helpers before rendering |

### Gemini Review (v3)

| Issue | Severity | Resolution |
|-------|----------|------------|
| Async/Sync bridge missing | MEDIUM | Added async_helpers.py with ThreadPoolExecutor pattern |
| Redundant fetch_api import | LOW | Removed from risk.py - uses RiskService only |

### Codex Review (v3)

| Issue | Severity | Resolution |
|-------|----------|------------|
| Data path inconsistent (HTTP vs libs/risk) | HIGH | Unified: risk.py → RiskService only, no HTTP/fetch_api |
| RiskService input contract undefined | HIGH | Added concrete data sources: feature store, factor model |
| Async + caching strategy unclear | MEDIUM | Added async_helpers.py with cache boundaries documented |
| Testing gaps (no e2e) | MEDIUM | Added TestEndToEndRiskPipeline, TestAsyncSyncBridge, TestUIEdgeCases |

### Codex Review (v4)

| Issue | Severity | Resolution |
|-------|----------|------------|
| Residual HTTP/mock in error handling | - | Removed: Section 4 now pure RiskService error handling |
| VaR history source undefined | - | Added _get_var_history() using get_pnl_summary() |
| UI edge-case tests placeholders | - | Filled in with real assertions and mocks |
| E2E test fixtures not realistic | - | Added DataFrame returns, mock_factor_model fixture |

---

**Plan Status:** APPROVED by Gemini (v4). Ready for Implementation.
