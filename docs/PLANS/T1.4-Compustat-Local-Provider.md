# T1.4 Compustat Local Provider - Implementation Plan

**Component:** T1.4-Compustat-Local-Provider
**Created:** 2025-12-04
**Status:** PLAN PHASE
**Revision:** v1.2 (Review 2 feedback: PIT inequality fix, Compustat filters, lag-adjusted universe)

---

## Overview

Implement a read-only Compustat Local Provider for querying fundamental data stored in Parquet files. This follows the same patterns established in T1.3 (CRSP Local Provider) but handles Compustat-specific requirements:

- **GVKEY** instead of PERMNO as primary identifier
- **Annual and Quarterly** data with different schemas
- **Point-in-time correctness** with configurable filing lags (prevents look-ahead bias)
- **GVKEY-to-ticker mapping** with historical awareness

---

## Key Differences from CRSP Provider

| Aspect | CRSP | Compustat |
|--------|------|-----------|
| Primary ID | PERMNO | GVKEY |
| Date Column | date | datadate |
| Data Type | Daily prices | Annual/Quarterly fundamentals |
| PTI Complexity | IPO/delist dates | Filing dates + configurable lag |
| Datasets | 1 (crsp_daily) | 2 (compustat_annual, compustat_quarterly) |

---

## Schema Definition

### Annual Data (compustat_annual)
**Note:** Schema extended to include `tic` (ticker) and `conm` (company name) for GVKEY↔ticker mapping.

```python
COMPUSTAT_ANNUAL_COLUMNS = ("datadate", "gvkey", "tic", "conm", "at", "lt", "sale", "ni", "ceq")

COMPUSTAT_ANNUAL_SCHEMA = {
    "datadate": pl.Date,      # Fiscal period end date
    "gvkey": pl.Utf8,         # GVKEY identifier (string in Compustat)
    "tic": pl.Utf8,           # Ticker symbol (for GVKEY↔ticker mapping)
    "conm": pl.Utf8,          # Company name
    "at": pl.Float64,         # Total Assets
    "lt": pl.Float64,         # Total Liabilities
    "sale": pl.Float64,       # Net Sales/Revenue
    "ni": pl.Float64,         # Net Income
    "ceq": pl.Float64,        # Common Equity - Total
}
```

### Quarterly Data (compustat_quarterly)
```python
COMPUSTAT_QUARTERLY_COLUMNS = ("datadate", "gvkey", "tic", "conm", "atq", "ltq", "saleq", "niq")

COMPUSTAT_QUARTERLY_SCHEMA = {
    "datadate": pl.Date,
    "gvkey": pl.Utf8,
    "tic": pl.Utf8,           # Ticker symbol (for GVKEY↔ticker mapping)
    "conm": pl.Utf8,          # Company name
    "atq": pl.Float64,        # Total Assets - Quarterly
    "ltq": pl.Float64,        # Total Liabilities - Quarterly
    "saleq": pl.Float64,      # Net Sales - Quarterly
    "niq": pl.Float64,        # Net Income - Quarterly
}
```

### SyncManager Query Update Required
The SyncManager `_build_query()` must be updated to include `tic` and `conm` columns AND standard Compustat filters to avoid duplicate records:

```sql
-- compustat_annual (MUST include standard filters to avoid duplicates)
SELECT datadate, gvkey, tic, conm, at, lt, sale, ni, ceq
FROM comp.funda
WHERE datadate >= '{start_date}' AND datadate <= '{end_date}'
  AND indfmt = 'INDL'   -- Industrial format (vs financial services)
  AND datafmt = 'STD'   -- Standardized format (vs restated)
  AND popsrc = 'D'      -- Domestic population
  AND consol = 'C'      -- Consolidated statements
ORDER BY datadate, gvkey

-- compustat_quarterly (same filters)
SELECT datadate, gvkey, tic, conm, atq, ltq, saleq, niq
FROM comp.fundq
WHERE datadate >= '{start_date}' AND datadate <= '{end_date}'
  AND indfmt = 'INDL'
  AND datafmt = 'STD'
  AND popsrc = 'D'
  AND consol = 'C'
ORDER BY datadate, gvkey
```

**Critical:** Without these filters, queries return duplicate rows for the same gvkey/datadate (Pre-FASB vs Post-FASB, restated vs original), breaking primary key uniqueness.

---

## Point-in-Time Correctness (Critical)

### Problem: Look-Ahead Bias
Using `datadate` (fiscal period end) as availability date is WRONG:
```
Fiscal Year End: 2023-12-31
Filing Date:     2024-02-15 (Form 10-K filed)
```
Using data "as of 2023-12-31" introduces 45+ days of look-ahead.

### Solution: Filing Lag Parameterization
```python
# Default lags per P4T1_TASK.md
ANNUAL_FILING_LAG_DAYS = 90   # 10-K typically filed within 90 days
QUARTERLY_FILING_LAG_DAYS = 45  # 10-Q typically filed within 45 days

def get_fundamentals(
    self,
    gvkeys: list[str],
    as_of_date: date,
    filing_lag_days: int | None = None,  # Override default
) -> pl.DataFrame:
    """
    Returns fundamentals AVAILABLE as of as_of_date.

    A record with datadate=2023-12-31 is only returned if:
    as_of_date >= datadate + filing_lag_days
    """
```

### Restatement Handling
Per P4T1_TASK.md: "Use original filing date, not restatement date."

For Phase 1 (without explicit filing_date column in data):
- Use conservative lag-based approach
- Document that true PTI accuracy requires filing_date column (Phase 2 enhancement)

### Default `as_of_date` Behavior (EXPLICIT)

**Rule:** `as_of_date` is **REQUIRED** for methods that involve point-in-time logic.

| Method | as_of_date Required? | Default Behavior |
|--------|---------------------|------------------|
| `get_annual_fundamentals()` | Optional | If None, returns all data in date range (NO PIT filtering) |
| `get_quarterly_fundamentals()` | Optional | If None, returns all data in date range (NO PIT filtering) |
| `gvkey_to_ticker()` | **REQUIRED** | Must specify date for mapping |
| `ticker_to_gvkey()` | **REQUIRED** | Must specify date for mapping |
| `get_security_universe()` | **REQUIRED** | Must specify date for universe construction |

**Warning:** When `as_of_date=None` for fundamentals queries, callers may accidentally introduce look-ahead bias. The method will log a warning:
```python
if as_of_date is None:
    logger.warning(
        "No as_of_date specified - returning all data without PIT filtering. "
        "This may introduce look-ahead bias in backtesting."
    )
```

---

## Point-in-Time Universe Rules (NEW)

### Problem: Determining Security Listing Windows

Unlike CRSP (which has explicit IPO/delist dates), Compustat fundamentals don't encode listing windows directly. We must derive them.

### Solution: Use LAG-ADJUSTED First/Last Dates

```python
# Derive AVAILABILITY windows from fundamentals data (WITH LAG)
# Raw dates:
first_datadate = MIN(datadate) for each GVKEY
last_datadate = MAX(datadate) for each GVKEY

# Lag-adjusted availability dates:
first_available = first_datadate + filing_lag  # When first record became KNOWN
last_available = last_datadate + filing_lag    # When last record became KNOWN
```

**Critical:** Without lag adjustment, GVKEYs appear in universe 45-90 days early (look-ahead bias).

### `get_security_universe()` PTI Filter

```python
def get_security_universe(
    self,
    as_of_date: date,  # REQUIRED
    include_inactive: bool = True,
    dataset: Literal["annual", "quarterly"] = "annual",
) -> pl.DataFrame:
    """
    Get universe of GVKEYs as of given date.

    Point-in-time logic (LAG-ADJUSTED):
    1. Compute first_datadate/last_datadate from fundamentals
    2. Apply filing lag: first_available = first_datadate + lag
    3. GVKEY included if: first_available <= as_of_date
    4. If include_inactive=False: also require last_available >= as_of_date
    5. Return point-in-time ticker/conm from most recent AVAILABLE filing

    Filing lag is determined by dataset parameter:
    - "annual": 90-day lag (10-K filing deadline)
    - "quarterly": 45-day lag (10-Q filing deadline)

    Args:
        as_of_date: Reference date for universe construction (REQUIRED).
        include_inactive: If True, include GVKEYs with stale filings.
        dataset: Which dataset to use ("annual" or "quarterly").

    Returns:
        DataFrame with: gvkey, tic, conm, first_available, last_available
    """
```

**Example:**
```
GVKEY 001234:
  first_datadate = 2020-03-31 (Q1 2020)
  last_datadate = 2024-09-30 (Q3 2024)

With quarterly lag (45 days):
  first_available = 2020-05-15  (NOT included in universe before this date)
  last_available = 2024-11-14   (last known filing as of this date)

Query as_of_date = 2020-05-01:
  → GVKEY 001234 NOT in universe (first_available > as_of_date)

Query as_of_date = 2020-05-16:
  → GVKEY 001234 IS in universe (first_available <= as_of_date)
```

### GVKEY↔Ticker Mapping PTI

Like CRSP's ticker_to_permno(), mappings query actual data for point-in-time correctness:

```python
def gvkey_to_ticker(
    self,
    gvkey: str,
    as_of_date: date,
    dataset: Literal["annual", "quarterly"] = "quarterly",
) -> str:
    """
    Map GVKEY to ticker at given date.

    Queries fundamentals for most recent AVAILABLE record where:
    datadate + filing_lag <= as_of_date  # Record is AVAILABLE (lag has elapsed)

    Then returns ticker from that record.

    Args:
        gvkey: GVKEY to look up.
        as_of_date: Date for the lookup (REQUIRED).
        dataset: Which dataset to query - determines filing lag.
                 "quarterly" uses 45-day lag, "annual" uses 90-day lag.

    Note: Ticker resolution is limited to filing frequency (quarterly/annual).
    Ticker changes between filings will be delayed until next filing.
    For higher resolution, consider using comp.names table (future enhancement).
    """
```

**Dataset-Specific Lag Selection:**
| dataset parameter | Filing Lag | Use Case |
|-------------------|------------|----------|
| "quarterly" (default) | 45 days | Higher resolution (4x/year updates) |
| "annual" | 90 days | Use when only annual data available |

---

## Manifest Separation (EXPLICIT)

### Distinct Manifests for Each Dataset

```
data/manifests/
├── compustat_annual.json    # Manifest for annual fundamentals
└── compustat_quarterly.json # Manifest for quarterly fundamentals
```

### Per-Query Consistency

Each query method pins and verifies its specific manifest:

```python
def get_annual_fundamentals(...) -> pl.DataFrame:
    # Pin ANNUAL manifest
    manifest = self._get_manifest(self.DATASET_ANNUAL)
    pinned_version = manifest.manifest_version
    ...
    # Verify ANNUAL manifest unchanged
    current = self._get_manifest(self.DATASET_ANNUAL)
    if current.manifest_version != pinned_version:
        raise ManifestVersionChangedError(...)

def get_quarterly_fundamentals(...) -> pl.DataFrame:
    # Pin QUARTERLY manifest
    manifest = self._get_manifest(self.DATASET_QUARTERLY)
    ...
```

### Cross-Dataset Queries

For `get_security_universe()` and mapping methods, the `dataset` parameter determines which manifest to use. No cross-manifest atomicity is provided (each dataset is independent).

---

## File Structure

```
libs/data_providers/
├── compustat_local_provider.py   # NEW
└── __init__.py                   # Update exports

tests/libs/data_providers/
└── test_compustat_local_provider.py  # NEW

docs/CONCEPTS/
└── fundamental-data.md           # NEW
```

---

## Implementation Details

### 1. CompustatLocalProvider Class

```python
class CompustatLocalProvider:
    """Read-only provider for Compustat fundamental data.

    Supports both annual (funda) and quarterly (fundq) datasets.
    Implements point-in-time correctness with configurable filing lags.

    Storage Layout:
        data/wrds/compustat/
        ├── annual/
        │   ├── 2020.parquet
        │   └── 2024.parquet
        └── quarterly/
            ├── 2020.parquet
            └── 2024.parquet

    Example:
        provider = CompustatLocalProvider(
            storage_path=Path("data/wrds/compustat"),
            manifest_manager=manifest_mgr,
        )

        # Get annual fundamentals with 90-day filing lag
        df = provider.get_annual_fundamentals(
            start_date=date(2023, 1, 1),
            end_date=date(2023, 12, 31),
            as_of_date=date(2024, 4, 1),  # Data available as of this date
        )
    """

    DATASET_ANNUAL = "compustat_annual"
    DATASET_QUARTERLY = "compustat_quarterly"
    DATA_ROOT = Path("data")

    # Default filing lags (can be overridden per query)
    DEFAULT_ANNUAL_FILING_LAG_DAYS = 90
    DEFAULT_QUARTERLY_FILING_LAG_DAYS = 45
```

### 2. Core Methods

```python
# Annual fundamentals query
def get_annual_fundamentals(
    self,
    start_date: date,
    end_date: date,
    gvkeys: list[str] | None = None,
    as_of_date: date | None = None,
    filing_lag_days: int | None = None,  # Override default 90 days
    columns: list[str] | None = None,
) -> pl.DataFrame

# Quarterly fundamentals query
def get_quarterly_fundamentals(
    self,
    start_date: date,
    end_date: date,
    gvkeys: list[str] | None = None,
    as_of_date: date | None = None,
    filing_lag_days: int | None = None,  # Override default 45 days
    columns: list[str] | None = None,
) -> pl.DataFrame

# GVKEY-ticker mapping
def gvkey_to_ticker(self, gvkey: str, as_of_date: date) -> str
def ticker_to_gvkey(self, ticker: str, as_of_date: date) -> str

# Security metadata
def get_security_universe(
    self,
    as_of_date: date,
    include_inactive: bool = True,
) -> pl.DataFrame
```

### 3. Manifest-Aware Snapshot Consistency

Same pattern as CRSP:
```python
def get_annual_fundamentals(...) -> pl.DataFrame:
    # Pin manifest version
    manifest = self._get_manifest(self.DATASET_ANNUAL)
    pinned_version = manifest.manifest_version

    # Execute query
    result = self._execute_query(...)

    # Verify manifest unchanged
    current = self._get_manifest(self.DATASET_ANNUAL)
    if current.manifest_version != pinned_version:
        raise ManifestVersionChangedError(...)

    return result
```

### 4. Storage Path Validation

Same security pattern as CRSP:
```python
def __init__(self, storage_path: Path, ...):
    self.storage_path = Path(storage_path).resolve()
    if not self.storage_path.is_relative_to(self.data_root):
        raise ValueError("storage_path must be within data_root")
```

---

## Test Cases (from P4T1_TASK.md)

1. **Annual fundamentals query** - Basic query returns correct schema
2. **Quarterly fundamentals query** - Quarterly data with correct columns
3. **Point-in-time lag handling** - 90-day lag for 10-K, 45-day for 10-Q
4. **GVKEY-to-ticker mapping accuracy** - Historical mapping works correctly
5. **Atomic write: interrupted write leaves no partial files** - (covered by SyncManager)
6. **Checksum mismatch triggers quarantine** - (covered by SyncManager)
7. **GVKEY changes: historical lookups use correct mapping** - Like PERMNO, GVKEY can map to different companies
8. **Filing lag parameterization** - Override default lags per query
9. **Restatements: use original filing date, not restatement date** - Conservative lag approach

### Additional Test Cases (following CRSP patterns)

10. **Schema validation** - Invalid columns raise ValueError
11. **Manifest version change detection** - ManifestVersionChangedError on mid-query change
12. **No manifest raises DataNotFoundError** - Run sync first
13. **Path traversal protection** - Paths outside data_root rejected
14. **Context manager cleanup** - Connection closed on exit
15. **Metadata cache tied to manifest version** - Auto-invalidation
16. **Partition pruning** - Only read needed year files

### Codex Review: Additional Required Test Cases (v1.1)

17. **Missing ticker field validation** - Data without `tic` column raises schema validation error
18. **PIT mapping returns correct ticker when GVKEY changes tickers** - Historical ticker lookup works
19. **PIT universe returns correct ticker when GVKEY changes tickers** - Universe shows PIT ticker, not future
20. **Boundary dates: datadate + lag - 1** - Record NOT available day before lag expires
21. **Boundary dates: datadate + lag + 0** - Record IS available on exact lag expiry
22. **as_of_date omitted logs warning** - Warning logged when PIT filtering skipped
23. **Empty gvkey list returns empty DataFrame** - Edge case: no GVKEYs specified
24. **Invalid storage path rejected** - Path outside data_root raises ValueError
25. **Manifest change during mapping query** - ManifestVersionChangedError raised
26. **Manifest change during universe query** - ManifestVersionChangedError raised
27. **Annual and quarterly use separate manifests** - Verify independent consistency
28. **get_security_universe requires as_of_date** - Raises error if as_of_date=None
29. **gvkey_to_ticker requires as_of_date** - Raises error if as_of_date=None
30. **ticker_to_gvkey requires as_of_date** - Raises error if as_of_date=None

### Review 2: Universe PIT Boundary Tests (v1.2)

31. **Universe: GVKEY excluded on first_datadate + lag - 1** - Not yet available
32. **Universe: GVKEY included on first_datadate + lag** - Just became available
33. **Universe: GVKEY excluded from active when as_of_date > last_available** - Stale filing
34. **Universe: lag-adjusted dates differ by dataset** - Annual (90d) vs Quarterly (45d)
35. **Mapping: correct lag applied based on dataset parameter** - quarterly=45, annual=90

---

## Documentation: fundamental-data.md

Topics to cover:
1. Plain English explanation of Compustat data
2. GVKEY identifier (vs ticker)
3. Point-in-time correctness for backtesting
4. Filing lag and look-ahead bias
5. Annual vs Quarterly data
6. Common pitfalls
7. Code examples

---

## Implementation Order

1. **Update SyncManager queries** (required for tic/conm columns):
   - Modify `sync_manager.py` `_build_query()` to add `tic`, `conm` columns
   - Add corresponding columns to primary key deduplication if needed

2. Create `compustat_local_provider.py` with:
   - Schema definitions (including `tic`, `conm`)
   - CompustatLocalProvider class
   - `get_annual_fundamentals()` method
   - `get_quarterly_fundamentals()` method
   - `gvkey_to_ticker()` / `ticker_to_gvkey()` mapping methods
   - `get_security_universe()` with PTI filtering
   - Point-in-time filtering with filing lag
   - Manifest-aware consistency (separate for annual/quarterly)
   - Path validation

3. Create comprehensive test suite in `test_compustat_local_provider.py` (30 test cases)

4. Update `libs/data_providers/__init__.py` exports

5. Create `docs/CONCEPTS/fundamental-data.md`

6. Update `docs/INDEX.md`

---

## Dependencies

- T1.1: DataValidator, ManifestManager (DONE)
- T1.2: SyncManager with compustat queries (DONE)
- Pattern: Follow CRSP Local Provider structure (T1.3 DONE)

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Look-ahead bias from using datadate | Conservative filing lag defaults (90/45 days) |
| GVKEY mapping complexity | Query actual data for point-in-time accuracy (same as CRSP ticker) |
| Two datasets (annual/quarterly) | Separate manifests, separate storage paths |
| Schema differences annual vs quarterly | Separate schema definitions, clear column names |

---

## Estimated Effort

- Implementation: 3-4 hours
- Tests: 2-3 hours
- Documentation: 1-2 hours
- Review + fixes: 1-2 hours

**Total:** 7-11 hours (per P4T1_TASK.md: 3-4 days)

---

## Checklist

- [ ] CompustatLocalProvider implementation
- [ ] Annual fundamentals query with PTI
- [ ] Quarterly fundamentals query with PTI
- [ ] GVKEY-to-ticker mapping
- [ ] Manifest-aware consistency
- [ ] Path validation (security)
- [ ] Comprehensive test suite
- [ ] fundamental-data.md documentation
- [ ] Update __init__.py exports
- [ ] Update INDEX.md
- [ ] Code review (Gemini + Codex)
- [ ] CI passes
- [ ] Commit with proper trailers

---

## Review Log

### Review 1 (2025-12-04)

**Gemini (planner):**
- Status: APPROVED
- Notes: Plan correctly extends CRSP pattern to Compustat. Lag-based PTI acceptable for Phase 1.

**Codex (planner):**
- Status: CHANGES_REQUESTED
- Findings addressed in v1.1:
  1. **GVKEY↔ticker mapping not backed by schema** → Added `tic`, `conm` columns to schemas
  2. **Point-in-time universe rules undefined** → Added PTI Universe Rules section
  3. **Default PIT behavior ambiguous** → Added explicit table of as_of_date requirements
  4. **Manifest separation needs to be explicit** → Added Manifest Separation section
  5. **Test coverage gaps** → Added 14 additional test cases (17-30)

### Review 2 (2025-12-04)

**Gemini (planner):**
- Status: CHANGES_REQUESTED
- Findings addressed in v1.2:
  1. **CRITICAL: PIT inequality wrong** → Fixed `datadate + lag >= as_of_date` to `datadate + lag <= as_of_date`
  2. **CRITICAL: Missing Compustat filters** → Added `indfmt='INDL'`, `datafmt='STD'`, `popsrc='D'`, `consol='C'`
  3. **MEDIUM: Ticker mapping resolution limits** → Added documentation note about quarterly/annual resolution

**Codex (planner):**
- Status: CHANGES_REQUESTED
- Findings addressed in v1.2:
  1. **Bug: PIT inequality** → Same fix as Gemini
  2. **Bug: Universe ignores filing lag** → Added lag-adjusted first_available/last_available
  3. **Gap: Dataset-specific lag selection** → Added `dataset` parameter to mapping/universe with lag table
  4. **Test gap: Universe PIT boundaries** → Added 5 new test cases (31-35)
