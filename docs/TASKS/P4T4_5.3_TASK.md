# P4T4-T5.3: Backtest Web UI

**Parent Task:** [P4T4_TASK.md](./P4T4_TASK.md)
**Task ID:** P4T4-T5.3

### T5.3: Backtest Web UI

**Effort:** 4-5 days | **PR:** `feat(p4): backtest web ui`
**Status:** ⏳ Pending
**Dependencies:** T5.1, T5.2, T6.1 (Auth)

**Auth Dependency Strategy:**
- **If T6.1 complete:** Use production OAuth2 auth via `@requires_auth`
- **If T6.1 pending:** Use dev-mode auth stub with `BACKTEST_DEV_AUTH=true` env var
- **Dev-mode stub:** Returns fixed user `{"username": "dev_user", "role": "operator"}`
- **CI enforcement:** Test `test_no_dev_auth_in_prod` fails if `BACKTEST_DEV_AUTH` is set in production config

**Auth Stub Rollback Path (when T6.1 ships):**
1. Remove `BACKTEST_DEV_AUTH=true` from all non-local env files (`.env.prod`, `docker-compose.prod.yml`, Helm/infra values if present)
2. Replace `@backtest_requires_auth` with standard `@requires_auth` **and update imports explicitly:** replace `from apps.web_console.auth.backtest_auth import backtest_requires_auth` with `from apps.web_console.auth.streamlit_helpers import requires_auth` in both `apps/web_console/pages/backtest.py` and `apps/web_console/app.py` (no wrapper re-exports)
3. Delete `apps/web_console/auth/backtest_auth.py`
4. Update `test_auth_governance.py` to verify no `BACKTEST_DEV_AUTH` references remain
5. Add a CI governance check that fails if `backtest_requires_auth` is referenced after T6.1 ships (guards manual import regressions)
6. CI will auto-fail if any stub references persist
7. If Helm/Kubernetes deployment is used (e.g., `helm/values.yaml`, `k8s/*.yaml`), also verify those files don't contain `BACKTEST_DEV_AUTH=true`

**Auth Stub Governance:**
```python
# tests/apps/web_console/test_auth_governance.py
import os
from pathlib import Path
import pytest

def load_environment_from_files(env_file: str, compose_file: str) -> dict[str, str]:
    """Load environment variables from env file and docker-compose."""
    env_vars = {}
    # Check .env file if exists
    env_path = Path(env_file)
    if env_path.exists():
        for line in env_path.read_text().splitlines():
            if "=" in line and not line.startswith("#"):
                key, value = line.split("=", 1)
                env_vars[key.strip()] = value.strip().strip('"')
    # Also check docker-compose environment section (in project root)
    compose_path = Path(compose_file)
    if compose_path.exists():
        import yaml
        with open(compose_path) as f:
            config = yaml.safe_load(f)
        for service in config.get("services", {}).values():
            for env_entry in service.get("environment", []):
                if isinstance(env_entry, str) and "=" in env_entry:
                    key, value = env_entry.split("=", 1)
                    env_vars[key] = value
    return env_vars


def _check_no_dev_auth(env_vars: dict[str, str], env_name: str) -> None:
    """Assert BACKTEST_DEV_AUTH is not enabled."""
    assert env_vars.get("BACKTEST_DEV_AUTH", "false").lower() != "true", (
        f"BACKTEST_DEV_AUTH=true is set in {env_name} config! "
        "This must be removed before T5.3 goes to prod/staging."
    )


def test_no_dev_auth_in_prod():
    """CI guard: dev auth stub must not be enabled in production."""
    prod_env = load_environment_from_files(".env.prod", "docker-compose.prod.yml")
    _check_no_dev_auth(prod_env, "production")


def test_no_dev_auth_in_staging():
    """CI guard: dev auth stub must not be enabled in staging."""
    staging_env = load_environment_from_files(".env.staging", "docker-compose.staging.yml")
    _check_no_dev_auth(staging_env, "staging")


def test_no_auth_stub_references_after_t61():
    """
    CI guard: After T6.1 ships, no code should reference backtest_requires_auth.

    This test detects manual import regressions where developers accidentally
    import the stub decorator instead of the real @requires_auth after T6.1.
    """
    import subprocess

    # Check if T6.1 has shipped (streamlit_helpers.py exists with full auth)
    t61_marker = Path("apps/web_console/auth/streamlit_helpers.py")
    if not t61_marker.exists():
        pytest.skip("T6.1 not yet shipped; auth stub is expected")

    # grep for any references to backtest_requires_auth
    result = subprocess.run(
        ["grep", "-r", "backtest_requires_auth", "apps/"],
        capture_output=True,
        text=True,
    )

    # grep returns 0 if matches found, 1 if no matches, 2+ on error
    if result.returncode == 0:
        pytest.fail(
            f"Found backtest_requires_auth references after T6.1 shipped! "
            f"These must be replaced with @requires_auth:\n{result.stdout}"
        )
    # returncode 1 = no matches = test passes
```

```python
# apps/web_console/auth/backtest_auth.py
import os
from apps.web_console.auth.streamlit_helpers import requires_auth

def backtest_requires_auth(func):
    """Auth decorator with dev-mode fallback for T5.3."""
    if os.getenv("BACKTEST_DEV_AUTH", "false").lower() == "true":
        # Dev mode: return stub user
        def wrapper(*args, **kwargs):
            import streamlit as st
            st.session_state["user"] = {"username": "dev_user", "role": "operator"}
            return func(*args, **kwargs)
        return wrapper
    else:
        # Production: use real auth
        return requires_auth(func)
```

**Deliverables:**
- Backtest configuration form (alpha selection, date range, weight method)
- Job status polling with progress bar
- Job status polling with progress bar **using progressive backoff** (e.g., 2s → 5s → 10s while pending/running; 30s after terminal)
- Results visualization (equity curve, drawdown, IC time series)
- Strategy comparison view (side-by-side metrics)
- Export functionality (CSV, JSON)

**Implementation:**
```python
# apps/web_console/pages/backtest.py
import os
import json
from contextlib import contextmanager

import streamlit as st
from streamlit_autorefresh import st_autorefresh
from redis import Redis
from psycopg.rows import dict_row
from psycopg_pool import ConnectionPool

from apps.web_console.auth.backtest_auth import backtest_requires_auth
from libs.backtest.job_queue import BacktestJobQueue, BacktestJobConfig, JobPriority
from libs.backtest.result_storage import BacktestResultStorage
from libs.alpha.registry import get_registered_alphas  # Alpha registry

# DB pool initialization (singleton per process - thread-safe)
@st.cache_resource
def get_db_pool() -> ConnectionPool:
    """Get psycopg connection pool (thread-safe)."""
    pool = ConnectionPool(conninfo=os.getenv("DATABASE_URL"), min_size=1, max_size=10)
    pool.open()
    return pool

@st.cache_resource
def get_redis_client() -> Redis:
    """Get Redis client (thread-safe)."""
    return Redis.from_url(os.getenv("REDIS_URL", "redis://localhost:6379"))

@contextmanager
def get_job_queue() -> BacktestJobQueue:
    """
    Get job queue with pooled psycopg connection.
    """
    redis = get_redis_client()
    pool = get_db_pool()
    queue = BacktestJobQueue(redis, pool)
    try:
        yield queue
    finally:
        # Do not close the cached pool; Streamlit pages reuse this singleton across requests
        pass

def get_available_alphas() -> list[str]:
    """Get list of registered alpha names from alpha registry."""
    return get_registered_alphas()

VALID_STATUSES = {"pending", "running", "completed", "failed", "cancelled"}


def get_poll_interval_ms(elapsed_seconds: float) -> int:
    """Progressive polling: start fast, then back off for long/terminal jobs."""
    if elapsed_seconds < 30:
        return 2000
    if elapsed_seconds < 60:
        return 5000
    if elapsed_seconds < 300:
        return 10_000
    return 30_000

def get_user_jobs(created_by: str, status: list[str]) -> list[dict]:
    """
    Query jobs for a user with given statuses.

    Uses sync query against Postgres backtest_jobs table.

    CRITICAL: Use DB status vocabulary (pending, running, completed, failed, cancelled),
    NOT RQ vocabulary (queued, started, finished).
    """
    invalid = set(status) - VALID_STATUSES
    if invalid:
        raise ValueError(f"Invalid statuses: {invalid}. Valid: {VALID_STATUSES}")

    pool = get_db_pool()
    sql = """
        SELECT job_id, alpha_name, start_date, end_date, status, created_at
        FROM backtest_jobs
        WHERE created_by = %s AND status = ANY(%s)
        ORDER BY created_at DESC
        LIMIT 50
    """
    with pool.connection() as conn, conn.cursor(row_factory=dict_row) as cur:
        cur.execute(sql, (created_by, status))
        jobs = cur.fetchall()

    # Fetch progress from Redis for each job (reuse cached client)
    redis = get_redis_client()
    result = []
    for job in jobs:
        progress_raw = redis.get(f"backtest:progress:{job['job_id']}")
        progress = json.loads(progress_raw) if progress_raw else {"pct": 0}
        result.append({
            "job_id": job["job_id"],
            "alpha_name": job["alpha_name"],
            "start_date": str(job["start_date"]),
            "end_date": str(job["end_date"]),
            "progress_pct": progress.get("pct", 0),
            "status": job["status"],
            "created_at": job["created_at"].isoformat() if job.get("created_at") else None,
        })
    return result

def get_current_username() -> str:
    """Get username from session, with fallback for dev mode."""
    user = st.session_state.get("user")
    if not user:
        st.info("No authenticated user in session; using anonymous fallback")
        return "anonymous"
    return user.get("username", "anonymous")

@backtest_requires_auth
def render_backtest_page():
    """Backtest configuration and results page."""
    st.header("Backtest Runner")

    tab1, tab2, tab3 = st.tabs(["New Backtest", "Running Jobs", "Results"])

    with tab1:
        render_backtest_form()

    with tab2:
        render_running_jobs()

    with tab3:
        render_backtest_results()

def render_backtest_form():
    """Render backtest configuration form."""
    with st.form("backtest_config"):
        col1, col2 = st.columns(2)

        with col1:
            alpha_name = st.selectbox(
                "Alpha Signal",
                options=get_available_alphas(),
                help="Select the alpha signal to backtest"
            )
            start_date = st.date_input("Start Date")
            end_date = st.date_input("End Date")

        with col2:
            weight_method = st.selectbox(
                "Weight Method",
                options=["zscore", "rank", "equal"],
                help="How to convert signals to portfolio weights"
            )
            priority_str = st.selectbox(
                "Priority",
                options=["normal", "high", "low"],
            )

        submitted = st.form_submit_button("Run Backtest", type="primary")

        if submitted:
            # Validate date range
            if end_date <= start_date:
                st.error("End date must be after start date")
                return

            # Validate priority enum
            try:
                priority = JobPriority(priority_str)
            except ValueError:
                st.error(f"Invalid priority: {priority_str}")
                return

            config = BacktestJobConfig(
                alpha_name=alpha_name,
                start_date=start_date,
                end_date=end_date,
                weight_method=weight_method,
            )

            # Pass created_by from authenticated session
            created_by = get_current_username()
            with get_job_queue() as queue:
                job = queue.enqueue(config, priority=priority, created_by=created_by)
            st.success(f"Backtest queued! Job ID: {job.id}")
            st.rerun()

def render_running_jobs():
    """Render list of running/queued jobs with status."""
    created_by = get_current_username()

    # Progressive polling with st_autorefresh
    elapsed = st.session_state.get("backtest_poll_elapsed", 0.0)
    interval_ms = get_poll_interval_ms(elapsed)
    st_autorefresh(interval=interval_ms, key="backtest_poll")
    st.session_state["backtest_poll_elapsed"] = elapsed + interval_ms / 1000

    # Fetch jobs for current user only (use DB statuses, not RQ)
    # Progressive polling: refresh every 2s initially, back off to 5s after 30s, 10s after 60s.
    jobs = get_user_jobs(created_by=created_by, status=["pending", "running"])

    if not jobs:
        st.session_state["backtest_poll_elapsed"] = 0

    for job in jobs:
        with st.container():
            col1, col2, col3 = st.columns([3, 1, 1])
            with col1:
                st.write(f"**{job['alpha_name']}** ({job['start_date']} to {job['end_date']})")
            with col2:
                st.progress(job['progress_pct'] / 100)
            with col3:
                if st.button("Cancel", key=f"cancel_{job['job_id']}"):
                    with get_job_queue() as queue:
                        queue.cancel_job(job['job_id'])
                    st.rerun()

def render_backtest_results():
    """Render completed backtest results with visualization."""
    # Result selection, metrics display, charts
    ...
```

**Files to Create:**
- `apps/web_console/pages/backtest.py`
- `apps/web_console/auth/backtest_auth.py`
- `apps/web_console/components/backtest_form.py`
- `apps/web_console/components/backtest_results.py`
- `apps/web_console/components/equity_curve_chart.py`
- `apps/web_console/components/ic_timeseries_chart.py`
- `tests/apps/web_console/test_backtest_page.py`
- `tests/apps/web_console/test_backtest_job_status.py`
- `tests/apps/web_console/test_auth_governance.py` (CI guard for dev auth)
- `docs/CONCEPTS/backtest-web-ui.md`
- `docs/ADRs/ADR-0025-backtest-ui-worker-contract.md`

---
---
## Acceptance Criteria
### T5.3 Web UI
- [ ] Form validation prevents invalid date ranges (end < start)
- [ ] UI uses progressive polling (2s→5s→10s→30s as job runs longer); progress reflects worker updates (≤30s emit cadence)
- [ ] Equity curve renders for backtests with 1000+ daily points
- [ ] Side-by-side comparison shows ≥5 metrics for 2+ backtests
- [ ] Failed/expired jobs display error message clearly
- [ ] **Auth Stub Security:** CI fails if `BACKTEST_DEV_AUTH=true` in prod/staging configs (`test_no_dev_auth_in_prod`, `test_no_dev_auth_in_staging`)
- [ ] **Auth Stub Cleanup:** After T6.1 ships, CI fails if `backtest_requires_auth` references exist (`test_no_auth_stub_references_after_t61`)
- [ ] **Auth Enforcement:** Web UI requires real OAuth2 auth in non-dev environments (verified by integration test)

