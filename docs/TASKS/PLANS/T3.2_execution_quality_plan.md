# T3.2 Execution Quality Analysis - Implementation Plan

**Task:** T3.2 from P4T2_TASK.md
**Status:** Planning (v7 - Revised after v6 rejection)
**Dependencies:** T3.1 (Microstructure Analytics) - COMPLETE, T1.8 (TAQ Query Interface) - COMPLETE
**Estimated Effort:** 3-4 days

**Review History:**
- v1 (2024-12-08): Initial plan - Gemini APPROVED, Codex REJECTED
- v2 (2024-12-08): Revised with Codex feedback - Gemini REJECTED, Codex REJECTED
- v3 (2024-12-08): Fixed IS fee formula, mid-price sourcing, cost decomposition - Gemini APPROVED, Codex REJECTED
- v4 (2024-12-08): Fixed rebate handling, naming consistency - Gemini APPROVED, Codex REJECTED (fresh review)
- v5 (2024-12-08): Fill chronology validation, side mismatch handling, ExtendedFill UTC - Gemini APPROVED, Codex REJECTED
- v6 (2024-12-08): IS naming clarity, consistent side-mismatch handling, batch UTC validation - Gemini APPROVED, Codex REJECTED
- v7 (2024-12-08): Opportunity cost for unfilled qty, fee currency validation, pre-decision exclusion (see Section 9)

---

## 1. Requirement Summary

Build an `ExecutionQualityAnalyzer` to measure trade execution quality against standard benchmarks (VWAP, TWAP, arrival price) with implementation shortfall calculation and market impact estimation.

**Primary Objective:** Provide execution quality analytics that integrate with execution_gateway fills and TAQ market data.

**Acceptance Criteria (from P4T2_TASK.md):**
- [ ] VWAP and TWAP benchmark computation
- [ ] Implementation shortfall calculation
- [ ] Market impact estimation
- [ ] Integration with execution_gateway order data
- [ ] Fill and FillBatch Pydantic models defined
- [ ] Handle partial fills, cancelled orders, amended fills
- [ ] Clock drift detection and warning
- [ ] Symbol mapping validation
- [ ] Timezone enforcement (UTC)
- [ ] Join with T3.1 microstructure spreads for realistic IS calculation
- [ ] >90% test coverage

---

## 2. Impacted Components

### Files to Create:
1. `libs/analytics/execution_quality.py` - Main analyzer module
2. `tests/libs/analytics/test_execution_quality.py` - Comprehensive tests
3. `docs/CONCEPTS/execution-analysis.md` - Concept documentation

### Dependencies (Read-Only):
- `libs/analytics/microstructure.py` - T3.1 for spread data integration
- `libs/data_providers/taq_query_provider.py` - TAQ data access
- `apps/execution_gateway/schemas.py` - Existing order schemas (reference only)

### Existing Patterns to Follow:
- `MicrostructureResult` base class pattern from T3.1
- `CompositeVersionInfo` for multi-dataset operations
- PIT support via `as_of` parameter
- Structured logging with extra context
- Pydantic models for data contracts

---

## 3. Implementation Design

### 3.1 Data Models (Pydantic)

**REVISED per Codex review:** Added fill_id, symbol, side at fill level; improved fee handling.

```python
# Core fill schema - contract with execution_gateway
class Fill(BaseModel):
    """Single fill record.

    Each fill is self-contained with symbol/side for standalone use,
    dedupe via fill_id, and explicit fee handling.
    """
    # Identity (REQUIRED for idempotency/dedupe)
    fill_id: str  # Broker-assigned unique fill ID
    order_id: str  # Parent order ID
    client_order_id: str  # Idempotent client order ID

    # Core fields
    timestamp: datetime  # UTC, validated
    symbol: str  # Symbol at fill level (not just batch)
    side: Literal["buy", "sell"]  # Side at fill level
    price: float  # gt=0, fill price per share
    quantity: int  # gt=0, shares filled

    # Venue details
    exchange: str | None = None
    liquidity_flag: Literal["add", "remove"] | None = None

    # Fee handling (REQUIRED for accurate IS)
    fee_amount: float = 0.0  # Total fee (positive) or rebate (negative)
    fee_currency: str = "USD"

    @field_validator("timestamp")
    def validate_utc(cls, v: datetime) -> datetime:
        if v.tzinfo is None:
            raise ValueError("timestamp must be timezone-aware UTC")
        if v.utcoffset() is not None and v.utcoffset().total_seconds() != 0:
            raise ValueError("timestamp must be UTC (offset must be 0)")
        return v

    @field_validator("symbol")
    def validate_symbol(cls, v: str) -> str:
        return v.upper().strip()


# Batch of fills for analysis
class FillBatch(BaseModel):
    """Batch of fills for execution quality analysis.

    Includes chronological validation and aggregate properties.
    v6: All timestamps UTC-validated, side-mismatch consistently handled.
    """
    symbol: str  # Primary symbol (fills may have different symbols for multi-leg)
    side: Literal["buy", "sell"]  # Primary side
    fills: list[Fill]
    decision_time: datetime  # When signal was generated (arrival price source)
    submission_time: datetime  # When order was submitted to broker
    total_target_qty: int  # Total quantity intended to fill

    @field_validator("decision_time", "submission_time")
    @classmethod
    def validate_utc_timestamps(cls, v: datetime) -> datetime:
        """Validate batch timestamps are UTC (v6)."""
        if v.tzinfo is None:
            raise ValueError("timestamp must be timezone-aware UTC")
        if v.utcoffset() is not None and v.utcoffset().total_seconds() != 0:
            raise ValueError("timestamp must be UTC (offset must be 0)")
        return v

    @model_validator(mode="after")
    def validate_chronology_and_sides(self) -> "FillBatch":
        """Validate chronology and fill side consistency.

        Chronology validation (v6):
        - STRICT: decision_time <= submission_time (raises ValueError)
        - WARNING: fills before decision_time flagged (data quality error)
        - WARNING: submission_time > first_fill by >100ms (clock sync issue)

        Side validation (v6):
        - WARNING: fills with side != batch.side flagged
        - CONSISTENT: mismatched fills excluded from ALL metrics (qty, price, fees)
        """
        # STRICT: decision_time <= submission_time
        if self.decision_time > self.submission_time:
            raise ValueError(
                f"decision_time ({self.decision_time}) must be <= submission_time ({self.submission_time})"
            )
        return self

    @property
    def matching_fills(self) -> list["Fill"]:
        """Fills with side == batch.side (used for filtering, v6)."""
        return [f for f in self.fills if f.side == self.side]

    @property
    def valid_fills(self) -> list["Fill"]:
        """Fills valid for IS calculation: matching side AND after decision_time (v7).

        Excludes:
        - Fills with side != batch.side (potential errors)
        - Fills with timestamp < decision_time (pre-signal, invalid)
        """
        return [
            f for f in self.fills
            if f.side == self.side and f.timestamp >= self.decision_time
        ]

    @property
    def fills_before_decision(self) -> list["Fill"]:
        """Fills timestamped before decision_time (excluded from IS, v7)."""
        return [f for f in self.fills if f.timestamp < self.decision_time]

    @property
    def has_fills_before_decision(self) -> bool:
        """True if any fill timestamp < decision_time (Edge Case #9)."""
        return len(self.fills_before_decision) > 0

    @property
    def mismatched_side_fills(self) -> list["Fill"]:
        """Fills with side != batch.side (potential crossed/error fills)."""
        return [f for f in self.fills if f.side != self.side]

    @property
    def has_side_mismatch(self) -> bool:
        """True if any fill has side != batch.side."""
        return len(self.mismatched_side_fills) > 0

    @property
    def clock_drift_detected(self) -> bool:
        """Check if submission_time > first_fill by >100ms (v6 threshold)."""
        drift = self.clock_drift_ms
        if drift is None:
            return False
        return drift > 100  # >100ms threshold per v6

    @property
    def clock_drift_ms(self) -> float | None:
        """Clock drift in milliseconds (submission to first fill)."""
        if not self.valid_fills:
            return None
        first_fill = min(f.timestamp for f in self.valid_fills)
        delta = (self.submission_time - first_fill).total_seconds() * 1000
        return delta  # Positive = submission after fill (bad)

    @property
    def total_filled_qty(self) -> int:
        """Total quantity from valid fills only (v7: excludes pre-decision)."""
        return sum(f.quantity for f in self.valid_fills)

    @property
    def unfilled_qty(self) -> int:
        """Unfilled quantity for opportunity cost calculation (v7)."""
        return max(0, self.total_target_qty - self.total_filled_qty)

    @property
    def avg_fill_price(self) -> float:
        """Avg fill price from valid fills only (v7)."""
        fills = self.valid_fills
        if not fills:
            return 0.0
        total_value = sum(f.price * f.quantity for f in fills)
        total_qty = sum(f.quantity for f in fills)
        return total_value / total_qty if total_qty > 0 else 0.0

    @property
    def total_fees(self) -> float:
        """Total fees from valid fills only (v7)."""
        return sum(f.fee_amount for f in self.valid_fills)

    @property
    def has_mixed_currencies(self) -> bool:
        """True if fills have different fee_currency values (v7)."""
        currencies = {f.fee_currency for f in self.valid_fills}
        return len(currencies) > 1

    @property
    def fee_currency(self) -> str:
        """Fee currency (all fills must match, v7)."""
        currencies = {f.fee_currency for f in self.valid_fills}
        if len(currencies) == 1:
            return currencies.pop()
        return "MIXED"  # Warning: mixed currencies detected


# Extended fill with lifecycle (for complex scenarios)
class FillStatus(str, Enum):
    FILLED = "filled"
    PARTIAL = "partial"
    CANCELLED = "cancelled"
    AMENDED = "amended"


class ExtendedFill(Fill):
    """Extended fill with lifecycle tracking for complex order handling."""
    status: FillStatus = FillStatus.FILLED
    amends_fill_id: str | None = None  # ID of fill being amended
    cancel_reason: str | None = None

    # Timing for latency analysis (all UTC-validated per v5)
    broker_received_at: datetime | None = None
    exchange_ack_at: datetime | None = None
    fill_reported_at: datetime | None = None

    @field_validator("broker_received_at", "exchange_ack_at", "fill_reported_at", mode="before")
    @classmethod
    def validate_optional_utc(cls, v: datetime | None) -> datetime | None:
        """Validate optional timestamps are UTC if provided."""
        if v is None:
            return None
        if v.tzinfo is None:
            raise ValueError("timestamp must be timezone-aware UTC")
        if v.utcoffset() is not None and v.utcoffset().total_seconds() != 0:
            raise ValueError("timestamp must be UTC (offset must be 0)")
        return v
```

### 3.2 Result Dataclass

**REVISED per Codex review:** Explicitly includes MicrostructureResult base fields; added fee_cost_bps.

```python
@dataclass
class ExecutionAnalysisResult:
    """Result of execution quality analysis.

    Inherits versioning pattern from MicrostructureResult for PIT support.
    All cost metrics are in basis points (bps) and sign-adjusted so
    positive = worse execution (cost), negative = price improvement.
    """
    # === MicrostructureResult base fields (REQUIRED for PIT parity) ===
    dataset_version_id: str  # Composite version from TAQ + spread datasets
    dataset_versions: dict[str, str] | None  # Individual dataset versions
    computation_timestamp: datetime  # When analysis was computed (UTC)
    as_of_date: date | None  # PIT date if used

    # === Execution identification ===
    symbol: str
    side: Literal["buy", "sell"]
    execution_date: date

    # === Core prices ===
    arrival_price: float  # Price at decision_time
    execution_price: float  # Volume-weighted avg fill price
    vwap_benchmark: float  # Market VWAP over execution window
    twap_benchmark: float  # Market TWAP over execution window
    mid_price_at_arrival: float | None  # Mid from T3.1 spread stats

    # === Cost decomposition (bps, sign-adjusted) - v7 OPPORTUNITY COST ADDED ===
    # Positive = cost/worse execution, Negative = price improvement
    # Formula: price_shortfall = side_sign * (exec_price - arrival_price) / arrival_price * 10000
    price_shortfall_bps: float  # Price-only component on filled qty
    vwap_slippage_bps: float  # (exec - vwap) / vwap * 10000 * side_sign
    fee_cost_bps: float  # fee_per_share / arrival * 10000 (SIGNED: positive=fee, negative=rebate)
    opportunity_cost_bps: float  # Unfilled qty cost: (close - arrival) / arrival * 10000 * side_sign * (unfilled/target) (v7)
    total_cost_bps: float  # price_shortfall_bps + fee_cost_bps + opportunity_cost_bps (v7: true IS)

    # === Impact decomposition ===
    market_impact_bps: float  # Estimated permanent impact
    timing_cost_bps: float  # price_shortfall_bps - market_impact_bps (delay cost)

    # === Fill statistics (v7: added unfilled_qty) ===
    fill_rate: float  # filled_qty / target_qty (0-1)
    total_filled_qty: int
    unfilled_qty: int  # target - filled (v7)
    total_target_qty: int
    total_notional: float  # execution_price * total_filled_qty
    total_fees: float
    close_price: float | None  # Close price for opportunity cost (v7)
    execution_duration_seconds: float
    num_fills: int

    # === Data quality (v7: added mixed_currency_warning) ===
    warnings: list[str]
    arrival_source: Literal["decision_time", "submission_time"]
    clock_drift_warning: bool  # True if submission > first_fill by >100ms
    fills_before_decision_warning: bool  # True if any fill.timestamp < decision_time (excluded from IS)
    side_mismatch_warning: bool  # True if any fill.side != batch.side (excluded from IS)
    mixed_currency_warning: bool  # True if fills have different fee_currency (v7)
    vwap_coverage_pct: float  # % of execution window with TAQ data
```

### 3.3 Core Analyzer Class

```python
class ExecutionQualityAnalyzer:
    """Analyze execution quality against market benchmarks.

    Uses TAQLocalProvider for benchmark data and MicrostructureAnalyzer
    for spread statistics integration.
    """

    def __init__(
        self,
        taq_provider: TAQLocalProvider,
        microstructure_analyzer: MicrostructureAnalyzer | None = None,
    ) -> None:
        self.taq = taq_provider
        self.micro = microstructure_analyzer

    def analyze_execution(
        self,
        fill_batch: FillBatch,
        as_of: date | None = None,
    ) -> ExecutionAnalysisResult:
        """Full execution quality analysis."""

    def compute_vwap(
        self,
        symbol: str,
        start_time: datetime,
        end_time: datetime,
        as_of: date | None = None,
    ) -> float:
        """Compute VWAP over time window from TAQ data."""

    def compute_twap(
        self,
        symbol: str,
        start_time: datetime,
        end_time: datetime,
        as_of: date | None = None,
    ) -> float:
        """Compute TWAP over time window from TAQ data."""

    def estimate_market_impact(
        self,
        fill_batch: FillBatch,
        spread_stats: SpreadDepthResult | None = None,
    ) -> float:
        """Estimate permanent market impact using spread data."""

    def recommend_execution_window(
        self,
        symbol: str,
        target_date: date,
        order_size_shares: int,
        as_of: date | None = None,
    ) -> ExecutionWindowRecommendation:
        """Recommend optimal execution timing based on liquidity patterns."""
```

### 3.4 Key Implementation Details

**REVISED per Codex review:** Side-adjusted IS, fee inclusion, improved VWAP, no brittle fallback.

**Implementation Shortfall Calculation (Side-Adjusted) - v7 WITH OPPORTUNITY COST:**
```python
# Side sign: Buy = +1 (want lower price), Sell = -1 (want higher price)
side_sign = 1 if side == "buy" else -1

# Price shortfall from price difference on FILLED qty (positive = cost)
price_shortfall_bps = side_sign * (execution_price - arrival_price) / arrival_price * 10000

# Fee cost - SIGNED to allow rebates to reduce cost
fee_per_share = total_fees / total_filled_qty if total_filled_qty > 0 else 0.0
fee_cost_bps = fee_per_share / arrival_price * 10000  # NO abs() - rebates are negative

# Opportunity cost for UNFILLED qty (v7 - critical for partial fills)
# Uses close price as proxy for where we'd have to fill unfilled shares
# Weighted by unfilled fraction of target
if unfilled_qty > 0 and close_price is not None:
    unfilled_fraction = unfilled_qty / total_target_qty
    opportunity_cost_bps = (
        side_sign * (close_price - arrival_price) / arrival_price * 10000 * unfilled_fraction
    )
else:
    opportunity_cost_bps = 0.0  # Fully filled or no close price

# Total cost = price shortfall + fees + opportunity cost (v7: true IS)
total_cost_bps = price_shortfall_bps + fee_cost_bps + opportunity_cost_bps

# Cost decomposition relationships (v7):
# - price_shortfall_bps = price-only component on filled qty
# - fee_cost_bps = fee component (positive=cost, negative=rebate)
# - opportunity_cost_bps = cost of unfilled qty (weighted by unfilled fraction)
# - total_cost_bps = price_shortfall + fees + opportunity (true IS)
# - market_impact_bps = estimated permanent price impact
# - timing_cost_bps = price_shortfall_bps - market_impact_bps (delay cost)
```

**Cost Decomposition Math (v4 update - includes rebate examples):**
```
For BUY @ arrival=$100, exec=$101, fee=$0.50:
  price_shortfall_bps = +1 * (101 - 100) / 100 * 10000 = +100 bps (cost)
  fee_cost_bps = 0.50 / 100 * 10000 = +50 bps (cost)
  total_cost_bps = 100 + 50 = +150 bps

For SELL @ arrival=$100, exec=$99, fee=$0.50:
  price_shortfall_bps = -1 * (99 - 100) / 100 * 10000 = +100 bps (cost)
  fee_cost_bps = 0.50 / 100 * 10000 = +50 bps (cost)
  total_cost_bps = 100 + 50 = +150 bps

For SELL @ arrival=$100, exec=$101 (price improvement), fee=$0.50:
  price_shortfall_bps = -1 * (101 - 100) / 100 * 10000 = -100 bps (improvement)
  fee_cost_bps = 0.50 / 100 * 10000 = +50 bps (cost)
  total_cost_bps = -100 + 50 = -50 bps (net improvement)

--- v4 REBATE EXAMPLES (fee_amount negative) ---

For BUY @ arrival=$100, exec=$100.50, rebate=-$0.30 (maker):
  price_shortfall_bps = +1 * (100.50 - 100) / 100 * 10000 = +50 bps (cost)
  fee_cost_bps = -0.30 / 100 * 10000 = -30 bps (rebate reduces cost!)
  total_cost_bps = 50 + (-30) = +20 bps (net cost after rebate)

For SELL @ arrival=$100, exec=$99.50, rebate=-$0.30 (maker):
  price_shortfall_bps = -1 * (99.50 - 100) / 100 * 10000 = +50 bps (cost)
  fee_cost_bps = -0.30 / 100 * 10000 = -30 bps (rebate reduces cost!)
  total_cost_bps = 50 + (-30) = +20 bps (net cost after rebate)

For BUY @ arrival=$100, exec=$99.80 (improvement), rebate=-$0.30:
  price_shortfall_bps = +1 * (99.80 - 100) / 100 * 10000 = -20 bps (improvement)
  fee_cost_bps = -0.30 / 100 * 10000 = -30 bps (rebate)
  total_cost_bps = -20 + (-30) = -50 bps (price improvement + rebate!)
```

**Arrival Price Source (NO brittle 50ms offset):**
- Primary: `decision_time` from FillBatch → use TAQ bar close at that minute
- Fallback: `submission_time` if decision_time unavailable → document with warning
- Validate: `decision_time <= submission_time <= first_fill`
- Clock drift: warn if `submission_time > first_fill` or any pair >100ms apart

**VWAP Calculation (Improved):**
```python
def compute_vwap(bars: pl.DataFrame) -> tuple[float, float]:
    """Compute VWAP from 1-minute bars.

    Returns (vwap, coverage_pct) where coverage_pct is % of window with data.
    """
    # Filter out zero-volume bars to avoid divide-by-zero
    valid_bars = bars.filter(pl.col("volume") > 0)

    if valid_bars.is_empty():
        return float("nan"), 0.0

    # Prefer bar's vwap field if available (more accurate)
    if "vwap" in valid_bars.columns:
        total_value = (valid_bars["vwap"] * valid_bars["volume"]).sum()
    else:
        # Fallback: use typical price = (high + low + close) / 3
        typical_price = (valid_bars["high"] + valid_bars["low"] + valid_bars["close"]) / 3
        total_value = (typical_price * valid_bars["volume"]).sum()

    total_volume = valid_bars["volume"].sum()
    vwap = total_value / total_volume

    # Coverage: valid bars / expected bars in window
    coverage_pct = valid_bars.height / bars.height if bars.height > 0 else 0.0

    return float(vwap), coverage_pct
```

**TWAP Calculation:**
```python
def compute_twap(bars: pl.DataFrame) -> float:
    """Compute TWAP (simple average of close prices)."""
    if bars.is_empty():
        return float("nan")
    return float(bars["close"].mean())
```

**Market Impact Estimation (FIXED in v3 - proper mid-price derivation):**

**Critical Fix:** qwap_spread is a spread WIDTH (in price units), NOT a price!
Mid-price must be derived from arrival_price and spread, or from TAQ bid/ask data.

```python
def estimate_market_impact(
    fill_batch: FillBatch,
    arrival_price: float,
    execution_price: float,
    spread_stats: SpreadDepthResult | None = None,
) -> tuple[float, float | None]:
    """Estimate permanent market impact.

    Returns: (market_impact_bps, mid_price_at_arrival)

    Mid-price derivation (in priority order):
    1. If spread_stats available: mid = arrival_price (assuming arrival is mid)
       Then verify: spread_stats.qwap_spread / arrival_price should be reasonable (<5%)
    2. If no spread_stats: mid = arrival_price (best proxy)

    Note: For more accurate mid, would need TAQ quote data at arrival time.
    This is a known limitation documented in warnings.
    """
    side_sign = 1 if fill_batch.side == "buy" else -1
    warnings: list[str] = []

    # Derive mid-price
    if spread_stats is not None and not spread_stats.depth_is_estimated:
        # qwap_spread is spread WIDTH in price units (ask - bid)
        # Assume arrival_price ≈ mid (typical for decision-time price)
        spread_width = spread_stats.qwap_spread
        spread_pct = spread_width / arrival_price if arrival_price > 0 else 0

        if spread_pct > 0.05:  # >5% spread is suspicious
            warnings.append(f"Unusually wide spread ({spread_pct:.1%})")

        # Mid = arrival_price (best approximation without tick-level bid/ask)
        mid_price = arrival_price
    else:
        # No spread data: arrival_price is best proxy for mid
        mid_price = arrival_price
        warnings.append("No spread data - using arrival_price as mid proxy")

    # Market impact = how much exec price moved from mid
    # Positive = adverse (paid more than mid for buy, received less for sell)
    if mid_price > 0:
        impact_bps = side_sign * (execution_price - mid_price) / mid_price * 10000
    else:
        impact_bps = float("nan")

    return impact_bps, mid_price


def get_mid_price_from_taq(
    taq_provider: TAQLocalProvider,
    symbol: str,
    at_time: datetime,
    as_of: date | None = None,
) -> float | None:
    """Get mid-price from TAQ quote data at specific time.

    Future enhancement: fetch quote at arrival time for precise mid.
    Currently returns None as fetch_ticks doesn't support as_of for PIT.
    """
    # TODO: Implement once TAQLocalProvider.fetch_ticks supports as_of
    # bars = taq_provider.fetch_minute_bars(...)
    # mid = (bar.high + bar.low) / 2  # Approximation from bar
    return None
```

**Mid-Price Sourcing Strategy (v3):**
| Source | Availability | Accuracy | Used When |
|--------|--------------|----------|-----------|
| TAQ bid/ask at arrival | Requires tick data | High | Future enhancement |
| Bar (H+L)/2 at arrival | Available via fetch_minute_bars | Medium | Default |
| arrival_price | Always available | Low (assumes mid) | Fallback |

**PIT Versioning (Using CompositeVersionInfo):**
```python
# Use same pattern as T3.1 MicrostructureAnalyzer
version_info = self._get_multi_version_id(
    datasets=["taq_1min_bars", "taq_spread_stats"],
    as_of=as_of,
)
# Result includes:
# - dataset_version_id = version_info.composite_version_id
# - dataset_versions = version_info.versions
```

---

## 4. Test Plan

**REVISED per Codex review:** Added sell-side IS, fee handling, version propagation, dedupe tests.

### Unit Tests - Schemas:
1. `test_fill_schema_validation` - UTC enforcement, field validation
2. `test_fill_schema_symbol_normalization` - uppercase, strip whitespace
3. `test_fill_batch_chronology_valid` - decision <= submission <= first_fill
4. `test_fill_batch_chronology_invalid` - decision > submission raises error
5. `test_fill_batch_properties` - avg_fill_price, total_filled_qty, total_fees
6. `test_fill_dedupe_by_fill_id` - duplicate fill_ids handled correctly

### Unit Tests - Schemas (v5 + v6 additions):
7. `test_fill_batch_fills_before_decision` - has_fills_before_decision flag
8. `test_fill_batch_side_mismatch` - has_side_mismatch flag when fill.side != batch.side
9. `test_fill_batch_mismatched_fills_excluded_from_qty` - total_filled_qty excludes mismatched sides
10. `test_fill_batch_mismatched_fills_excluded_from_price` - avg_fill_price uses matching_fills only (v6)
11. `test_fill_batch_mismatched_fills_excluded_from_fees` - total_fees uses matching_fills only (v6)
12. `test_extended_fill_utc_validation` - broker_received_at/exchange_ack_at/fill_reported_at UTC
13. `test_extended_fill_optional_timestamps_null_ok` - None values pass validation
14. `test_fill_batch_decision_time_utc_required` - non-UTC decision_time rejected (v6)
15. `test_fill_batch_submission_time_utc_required` - non-UTC submission_time rejected (v6)
16. `test_clock_drift_100ms_threshold` - clock_drift_detected=True only if >100ms (v6)

### Unit Tests - Benchmarks:
17. `test_vwap_computation_with_vwap_field` - uses bar vwap if available
18. `test_vwap_computation_typical_price` - uses (H+L+C)/3 fallback
19. `test_vwap_zero_volume_bars_skipped` - no divide-by-zero
20. `test_vwap_empty_window_returns_nan` - graceful handling
21. `test_vwap_coverage_percentage` - correct calculation
22. `test_twap_computation` - simple average of close prices

### Unit Tests - Implementation Shortfall:
23. `test_is_buy_side_positive_for_slippage` - buy higher = cost
24. `test_is_buy_side_negative_for_improvement` - buy lower = improvement
25. `test_is_sell_side_positive_for_slippage` - sell lower = cost
26. `test_is_sell_side_negative_for_improvement` - sell higher = improvement
27. `test_is_with_fees_included` - fees add to cost
28. `test_is_with_rebates_included` - rebates reduce cost (negative fee_amount)
29. `test_is_within_10bps_of_manual` - accuracy requirement

### Unit Tests - Data Quality:
30. `test_clock_drift_warning_submission_after_fill` - submission > first_fill >100ms
31. `test_fills_before_decision_warning` - fill.timestamp < decision_time flagged
32. `test_side_mismatch_warning` - fill.side != batch.side flagged in result
33. `test_arrival_price_uses_decision_time` - primary source
34. `test_arrival_price_fallback_submission_time` - with warning documented
35. `test_arrival_source_documented_in_result` - auditability

### Unit Tests - Market Impact:
36. `test_market_impact_with_spread_stats` - uses T3.1 data
37. `test_market_impact_without_spread_stats` - returns arrival_price as mid with warning
38. `test_market_impact_side_adjusted` - correct sign for buy/sell
39. `test_market_impact_wide_spread_warning` - >5% spread flagged
40. `test_market_impact_mid_derivation` - mid = arrival_price (documented limitation)
41. `test_market_impact_missing_spread_data_warning` - warning in result

### Unit Tests - Version Propagation:
42. `test_result_has_dataset_version_id` - from CompositeVersionInfo
43. `test_result_has_dataset_versions_dict` - individual versions
44. `test_result_has_computation_timestamp` - UTC
45. `test_pit_version_propagation` - as_of flows through correctly

### Unit Tests - Cost Decomposition:
46. `test_cost_decomposition_buy_slippage` - price_shortfall + fees + opp = total_cost for buy higher
47. `test_cost_decomposition_sell_slippage` - price_shortfall + fees + opp = total_cost for sell lower
48. `test_cost_decomposition_buy_improvement` - negative price_shortfall + fees for buy lower
49. `test_cost_decomposition_sell_improvement` - negative price_shortfall + fees for sell higher
50. `test_timing_cost_equals_price_shortfall_minus_impact` - timing = price_shortfall - market_impact
51. `test_zero_fees_simplifies_formula` - price_shortfall + opp = total_cost when no fees

### Unit Tests - Opportunity Cost (v7):
52. `test_opportunity_cost_partial_fill_buy` - unfilled qty cost for buy when close > arrival
53. `test_opportunity_cost_partial_fill_sell` - unfilled qty cost for sell when close < arrival
54. `test_opportunity_cost_full_fill_zero` - opportunity_cost_bps = 0 when fully filled
55. `test_opportunity_cost_no_close_price_zero` - opportunity_cost_bps = 0 when close_price=None
56. `test_opportunity_cost_weighted_by_unfilled_fraction` - cost scaled by unfilled/target

### Unit Tests - Currency Validation (v7):
57. `test_mixed_currency_warning_set` - mixed_currency_warning=True when fills have different currencies
58. `test_single_currency_no_warning` - mixed_currency_warning=False when all USD
59. `test_valid_fills_excludes_pre_decision` - valid_fills excludes fills before decision_time

### Integration Tests:
1. `test_analyze_execution_with_taq_data` - full pipeline
2. `test_spread_integration` - join with T3.1 SpreadDepthResult
3. `test_pit_query_support` - as_of parameter works correctly
4. `test_version_metadata_matches_taq_snapshot` - PIT parity with T3.1

### Edge Cases:
1. Empty fills list - returns error or NaN metrics
2. Single fill - duration = 0, no VWAP range
3. All fills cancelled - no valid fills to analyze
4. Clock drift >100ms - warning flag set
5. Missing TAQ data for window - NaN VWAP with coverage = 0
6. Symbol not in TAQ - clear error message
7. Partial window coverage <80% - warning in result
8. Fills across session boundaries - handle overnight
9. decision_time > first_fill - data quality error flag

---

## 5. Success Metrics (from P4T2_TASK.md)

| Metric | Target |
|--------|--------|
| Implementation shortfall accuracy | ±10 bps vs manual |
| VWAP benchmark accuracy | ±1 bps vs TAQ-derived |
| Analysis latency | <5s for single-day execution |
| Test coverage | >90% |

---

## 6. Implementation Steps (6-Step Pattern)

### Component 1: Fill Schemas & Base Classes
1. Plan: Define Fill, FillBatch, ExtendedFill schemas
2. Plan Review: Request zen-mcp review (FRESH)
3. Implement: Create schemas with validators
4. Test: Schema validation tests
5. Code Review: Request zen-mcp review (FRESH)
6. Commit: After CI passes

### Component 2: VWAP/TWAP Benchmark Computation
1. Plan: VWAP/TWAP from TAQ minute bars
2. Plan Review: Request zen-mcp review (FRESH)
3. Implement: compute_vwap, compute_twap methods
4. Test: Benchmark accuracy tests
5. Code Review: Request zen-mcp review (FRESH)
6. Commit: After CI passes

### Component 3: Implementation Shortfall & Market Impact
1. Plan: IS calculation, market impact estimation
2. Plan Review: Request zen-mcp review (FRESH)
3. Implement: analyze_execution main method
4. Test: IS accuracy, edge case handling
5. Code Review: Request zen-mcp review (FRESH)
6. Commit: After CI passes

### Component 4: T3.1 Integration & Window Recommendations
1. Plan: Spread integration, execution window recommendations
2. Plan Review: Request zen-mcp review (FRESH)
3. Implement: recommend_execution_window, spread integration
4. Test: Integration tests
5. Code Review: Request zen-mcp review (FRESH)
6. Commit: After CI passes

---

## 7. Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| TAQ data gaps during execution window | Return NaN with warning, document in result |
| Symbol mapping differences | Add symbol_mapping parameter, validate at analysis start |
| Clock drift between systems | Detect and warn >100ms, document in result |
| PIT tick loading not fully supported | Use version_id from manifest, document limitation |

---

## 8. Review Requirements

**CRITICAL:** All reviews MUST be FRESH (no continuation-id reuse):
- Plan reviews: Gemini + Codex planners
- Code reviews: Gemini + Codex code reviewers
- NO bias from previous fixes - each review is independent

---

## 9. Review Feedback Log

### v1 Review (2024-12-08)

**Gemini (Planner):** APPROVED with suggestions
- Critical fix: IS formula needs side adjustment (Buy=+1, Sell=-1)
- Add test case for fill timestamps predating decision timestamps

**Codex (Planner):** REJECTED with issues:
1. **IS formula** - Missing side handling; needs direction*(exec-arrival)/arrival*10000 + fees
2. **Result schema** - Missing MicrostructureResult base fields for PIT parity
3. **Fill schema** - Lacks fill_id for dedupe, symbol/side at fill level, fee currency
4. **Arrival price** - 50ms fallback is brittle; use submission_time with warning
5. **Clock drift** - Unclear which clocks compared; need sources and tolerance
6. **VWAP** - Should use bar vwap if available; handle zero-volume bars
7. **Market impact** - Mid_price source unclear; need CompositeVersionInfo
8. **Test gaps** - Missing sell-side IS, fee/rebate, version propagation tests

### v2 Review (2024-12-08)

**Gemini (Planner):** REJECTED
- Critical: IS fee formula wrong for sells - `side_sign * (exec + fee - arrival)` negates fees
- Fix: Decouple fees: `(side_sign * (exec - arrival) + fee) / arrival * 10000`

**Codex (Planner):** REJECTED with issues:
1. **Market impact** - qwap_spread is spread WIDTH, not price; mid derivation wrong
2. **Chronology** - Claims strict enforcement but only warns on submission > first_fill
3. **Cost decomposition** - Unclear how IS + fees + impact + timing relate
4. **Test gaps** - Missing mid-price sourcing tests, cost relationship tests

### v3 Changes Made:
- [x] **Fixed IS fee formula**: Decoupled - `price_shortfall + fee_cost` (fees always additive)
- [x] **Added cost decomposition math**: Clear examples for buy/sell slippage/improvement
- [x] **Fixed mid-price derivation**: Document that mid = arrival_price (limitation)
- [x] **Fixed qwap_spread usage**: It's spread WIDTH, not price - clarified in code
- [x] **Clarified chronology**: STRICT for decision<=submission, WARNING-ONLY for submission<=fill
- [x] **Added clock_drift_detected property**: FillBatch now has explicit drift detection
- [x] **Added 6 cost decomposition tests**: Verify IS + fees = total_cost for all scenarios
- [x] **Added 3 mid-price tests**: Wide spread warning, missing data handling
- [x] **Total: 41 unit tests + 9 edge cases**

### v3 Review (2024-12-08)

**Gemini (Planner):** APPROVED
- All issues from v2 addressed

**Codex (Planner):** REJECTED with issues:
1. **Critical: Fee sign handling** - `abs(fee_per_share)` prevents rebates from reducing cost
   - Test #18 "rebates reduce cost" will fail with abs()
   - Fix: Use signed `fee_cost_bps = fee_per_share / arrival_price * 10000`
2. **Minor: Naming inconsistency** - `implementation_shortfall_bps` vs `price_shortfall_bps`
   - Clarified with alias in comment

### v4 Changes Made:
- [x] **Removed abs() from fee calculation**: `fee_cost_bps = fee_per_share / arrival_price * 10000`
   - Now rebates (negative fee_amount) result in negative fee_cost_bps, reducing total_cost
- [x] **Added rebate examples**: 3 new math examples showing rebate scenarios
- [x] **Clarified naming**: Added `(alias: price_shortfall_bps)` comment to field
- [x] **Updated Result dataclass comments**: fee_cost_bps documented as SIGNED

### v4 Review (2024-12-08) - BIASED (invalidated)

*Note: Initial v4 reviews were biased (context about previous fixes provided).*
*Fresh re-review requested:*

**Gemini (Planner):** APPROVED (fresh)
- No issues

**Codex (Planner):** REJECTED (fresh) with issues:
1. **Major: data-quality-fill-before-decision** - No check for fills before decision_time
   - Edge Case #9 expects this but no validation/warning exists
2. **Major: schema-fill-side-mismatch** - FillBatch silently excludes fills with side != batch.side
   - Can mask crossed/erroneous fills and break IS math
3. **Minor: extendedfill-timezone-validation** - ExtendedFill timestamps lack UTC validation
   - Data quality goal (UTC enforcement) should apply to all timestamps

### v5 Changes Made:
- [x] **Added fills_before_decision validation**: `has_fills_before_decision` property + `fills_before_decision` list
- [x] **Added side mismatch detection**: `has_side_mismatch` property + `mismatched_side_fills` list
- [x] **Added ExtendedFill UTC validation**: `validate_optional_utc` for all optional timestamps
- [x] **Added Result dataclass flags**: `fills_before_decision_warning`, `side_mismatch_warning`
- [x] **Added 5 new test cases**: Schema tests 7-11 for new validations
- [x] **Updated data quality tests**: Tests 27-28 for fills_before_decision and side_mismatch warnings

### v5 Review (2024-12-08)

**Gemini (Planner):** APPROVED (fresh)
- No issues

**Codex (Planner):** REJECTED (fresh) with issues:
1. **Major: is-definition-mismatch** - `implementation_shortfall_bps` called price-only but math uses total
   - `total_cost_bps = implementation_shortfall_bps + fee_cost_bps` may double-count or under-count
2. **Major: side-mismatch-metric-inconsistency** - Mismatched fills excluded from qty but included in avg_fill_price/fees
   - Distorts IS and fee bps calculations
3. **Major: batch-timestamps-utc-validation-missing** - decision_time/submission_time lack UTC validators
   - Non-UTC times can slip through
4. **Minor: clock-drift-threshold-gap** - No 100ms threshold enforcement
5. **Minor: test-coverage-holes** - Missing tests for batch UTC validation and side-mismatch cost path

### v6 Changes Made:
- [x] **Renamed IS field**: `implementation_shortfall_bps` → `price_shortfall_bps` (price-only)
- [x] **Added `matching_fills` property**: Used by all metrics (qty, price, fees)
- [x] **Fixed side-mismatch consistency**: All metrics now use `matching_fills` only
- [x] **Added FillBatch UTC validation**: `validate_utc_timestamps` for decision_time/submission_time
- [x] **Added 100ms clock drift threshold**: `clock_drift_detected` returns True only if >100ms
- [x] **Added 5 new tests**: Tests 10-11 for side-mismatch metrics, 14-16 for UTC and threshold
- [x] **Updated cost decomposition naming**: Uses `price_shortfall_bps` consistently

### v6 Review (2024-12-08)

**Gemini (Planner):** APPROVED (fresh)
- No issues

**Codex (Planner):** REJECTED (fresh) with issues:
1. **Critical: is-missing-opportunity-cost** - IS ignores unfilled qty for partial fills
   - total_cost_bps only uses filled qty, understating cost when target > filled
2. **Major: fee-currency-handling** - fee_currency exists but no FX validation
   - Mixed currencies will produce incorrect fee_cost_bps
3. **Major: pre-decision-fills-included** - Fills before decision_time only warned, still in IS
   - Should exclude from calculations, not just warn
4. **Major: test-gap-opportunity-cost** - Missing tests for partial-fill opportunity cost

### v7 Changes Made:
- [x] **Added `valid_fills` property**: Excludes BOTH pre-decision AND mismatched-side fills
- [x] **Added `opportunity_cost_bps`**: Unfilled qty cost using close price, weighted by unfilled fraction
- [x] **Added `unfilled_qty` property**: target_qty - filled_qty for opportunity cost
- [x] **Added `close_price` to Result**: For opportunity cost calculation
- [x] **Added `has_mixed_currencies` property**: Detects mixed fee_currency values
- [x] **Added `mixed_currency_warning` flag**: Set when fills have different currencies
- [x] **Updated `total_cost_bps`**: Now includes opportunity_cost_bps
- [x] **All metrics now use `valid_fills`**: Pre-decision fills excluded from IS, not just warned
- [x] **Added 8 new tests**: Tests 52-59 for opportunity cost and currency validation
- [x] **Total: 59 unit tests + 4 integration tests + 9 edge cases**

---

### v7 Review (2024-12-08)

**Codex (Planner):** APPROVED (fresh) with minor suggestions:
1. **Minor: fee-currency-validation** - Should warn for non-USD, not just mixed
2. **Minor: clock-drift-coverage** - Use raw fills for drift when all valid_fills excluded

*Note: Minor suggestions accepted, will address during implementation.*

---

**Plan Created:** 2024-12-08
**Author:** Claude Code
**Status:** APPROVED (v7) - Ready for Implementation
