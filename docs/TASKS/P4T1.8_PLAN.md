# P4T1.8 Implementation Plan: Unified Data Fetcher Protocol

**Component:** P4T1.8-Unified-Data-Fetcher-Protocol
**Task:** P4T1 (Phase 1 Foundation - Data Infrastructure)
**Status:** Plan Review
**Created:** 2025-12-05
**Version:** 2.1 (Addresses Gemini + Codex Review 2)

---

## Overview

This component implements the Unified Data Fetcher with a common DataProvider protocol, enabling seamless switching between data sources (yfinance for development, CRSP for production) via configuration.

**Deliverables:**
1. `DataProvider` protocol interface (`libs/data_providers/protocols.py`)
2. `UnifiedDataFetcher` with provider factory (`libs/data_providers/unified_fetcher.py`)
3. CLI script (`scripts/fetch_data.py`)
4. Comprehensive tests
5. Documentation (concept doc + ADR)

---

## Review 1 Issues Addressed

| Severity | Issue | Resolution |
|----------|-------|------------|
| HIGH | Schema mismatch (OHLC vs prc) | Unified schema uses common columns; OHLC optional (null for CRSP) |
| HIGH | Provider selection contradictory | Explicit rules: fallback DISABLED in production |
| HIGH | Schema normalization unspecified | Full normalization spec added (Section 1.3) |
| HIGH | CRSP adj_close incorrect (R2) | CRSP prc is NOT split-adjusted; set adj_close to null |
| MEDIUM | get_universe with yfinance crashes | Guard added: require production provider for universe |
| MEDIUM | Error handling underspecified | Custom exceptions defined (Section 2.3) |
| MEDIUM | Test plan missing cases | Additional test cases added (Section 4) |
| MEDIUM | CRSP volume ambiguous (R2) | Explicit rule: CRSP daily vol is raw shares (no conversion) |
| LOW | Volume unit consistency | Normalization to raw shares specified |
| LOW | CLI behavior unclear | Exit codes, formats, status content specified |
| LOW | Config path validation (R2) | Explicit validation rules added (Section 2.1) |

---

## 1. DataProvider Protocol Design

### 1.1 Unified Schema (CRITICAL - addresses schema mismatch)

The unified schema reflects the **intersection** of available data, with optional OHLC columns:

```python
# Core columns (required - both providers have these)
REQUIRED_COLUMNS = {
    "date": pl.Date,         # Trading date
    "symbol": str,           # Ticker symbol (normalized uppercase)
    "close": pl.Float64,     # Closing price (absolute, not negative bid/ask)
    "volume": pl.Float64,    # Volume in raw shares (not hundreds)
    "ret": pl.Float64,       # Holding period return (may be null)
}

# Optional columns (may be null depending on provider)
OPTIONAL_COLUMNS = {
    "open": pl.Float64,      # Opening price (yfinance only, null for CRSP)
    "high": pl.Float64,      # High price (yfinance only, null for CRSP)
    "low": pl.Float64,       # Low price (yfinance only, null for CRSP)
    "adj_close": pl.Float64, # Adjusted close (yfinance has, CRSP uses prc)
}
```

**Rationale:** CRSP daily data from WRDS provides `prc`, `ret`, `vol`, `shrout` but NOT open/high/low. Rather than require WRDS schema changes, we make OHLC optional with nulls.

### 1.2 Protocol Interface

```python
# libs/data_providers/protocols.py
from typing import Protocol, runtime_checkable
from datetime import date
import polars as pl

class ProviderUnavailableError(Exception):
    """Raised when a requested provider is not available."""
    pass

class ProviderNotSupportedError(Exception):
    """Raised when operation not supported by provider (e.g., universe on yfinance)."""
    pass

class ProductionProviderRequiredError(Exception):
    """Raised when production env requires production-ready provider."""
    pass

@runtime_checkable
class DataProvider(Protocol):
    """Common interface for all data providers.

    Enables switching between yfinance (dev) and CRSP (prod)
    transparently via configuration.

    Thread Safety: Implementations must be thread-safe for concurrent reads.
    """

    @property
    def name(self) -> str:
        """Provider identifier (e.g., 'yfinance', 'crsp')."""
        ...

    @property
    def is_production_ready(self) -> bool:
        """Whether provider is suitable for production backtests.

        Returns:
            True for CRSP (survivorship-bias-free)
            False for yfinance (lacks survivorship handling)
        """
        ...

    @property
    def supports_universe(self) -> bool:
        """Whether provider supports get_universe operation.

        Returns:
            True for CRSP (has point-in-time universe)
            False for yfinance (no universe concept)
        """
        ...

    def get_daily_prices(
        self,
        symbols: list[str],
        start_date: date,
        end_date: date,
    ) -> pl.DataFrame:
        """Fetch daily price data.

        Returns DataFrame with unified schema:
        - date: Date (required)
        - symbol: str (required, uppercase)
        - close: Float64 (required, absolute price)
        - volume: Float64 (required, raw shares)
        - ret: Float64 (required, may be null)
        - open, high, low, adj_close: Float64 (optional, may be null)

        Raises:
            ValueError: If symbols list is empty.
        """
        ...

    def get_universe(self, as_of_date: date) -> list[str]:
        """Get tradeable universe as of date.

        Returns list of ticker symbols available on the given date.

        Raises:
            ProviderNotSupportedError: If provider doesn't support universe.
        """
        ...
```

### 1.3 Schema Normalization Rules (CRITICAL - addresses normalization gaps)

```python
# Column mapping and normalization for each provider

YFINANCE_NORMALIZATION = {
    # Column renames
    "renames": {},  # yfinance columns already match

    # Computed columns
    "computed": {
        "ret": None,  # yfinance doesn't provide returns, set null
    },

    # Volume normalization
    "volume_multiplier": 1.0,  # Already in raw shares

    # Price handling
    "price_column": "close",  # Use as-is
}

CRSP_NORMALIZATION = {
    # Column renames
    "renames": {
        "ticker": "symbol",
        "prc": "close",
        "vol": "volume",
    },

    # Missing columns (set to null)
    # CRITICAL: adj_close is NULL because CRSP prc is NOT split-adjusted
    # (prc is raw daily close or bid/ask avg, not back-adjusted for splits)
    "nulls": ["open", "high", "low", "adj_close"],

    # Volume normalization
    # CRSP daily vol is already in raw shares (NOT hundreds)
    # Note: TAQ data uses hundreds, but daily CRSP is raw shares
    "volume_multiplier": 1.0,  # No conversion needed

    # Price handling
    "price_absolute": True,  # Use abs(prc) - negative means bid/ask avg

    # Performance calculations note:
    # Use `ret` column for returns (it IS split-adjusted in CRSP)
    # Do NOT use adj_close for CRSP - it's null
}
```

### 1.4 Adapter Implementation

```python
class YFinanceDataProviderAdapter:
    """Adapter to make YFinanceProvider conform to DataProvider protocol."""

    def __init__(self, provider: YFinanceProvider) -> None:
        self._provider = provider

    @property
    def name(self) -> str:
        return "yfinance"

    @property
    def is_production_ready(self) -> bool:
        return False  # yfinance lacks survivorship handling

    @property
    def supports_universe(self) -> bool:
        return False  # yfinance has no universe concept

    def get_daily_prices(
        self,
        symbols: list[str],
        start_date: date,
        end_date: date,
    ) -> pl.DataFrame:
        if not symbols:
            raise ValueError("symbols list cannot be empty")

        df = self._provider.get_daily_prices(
            symbols=symbols,
            start_date=start_date,
            end_date=end_date,
        )
        return self._normalize_schema(df)

    def _normalize_schema(self, df: pl.DataFrame) -> pl.DataFrame:
        """Normalize yfinance output to unified schema."""
        # Ensure uppercase symbols
        if "symbol" in df.columns:
            df = df.with_columns(pl.col("symbol").str.to_uppercase())

        # Add null ret column (yfinance doesn't provide returns)
        if "ret" not in df.columns:
            df = df.with_columns(pl.lit(None).cast(pl.Float64).alias("ret"))

        # Ensure all optional columns exist (may already be present)
        for col in ["open", "high", "low", "adj_close"]:
            if col not in df.columns:
                df = df.with_columns(pl.lit(None).cast(pl.Float64).alias(col))

        # Select columns in canonical order
        return df.select([
            "date", "symbol", "close", "volume", "ret",
            "open", "high", "low", "adj_close"
        ])

    def get_universe(self, as_of_date: date) -> list[str]:
        raise ProviderNotSupportedError(
            "yfinance does not support universe queries. "
            "Use CRSP provider for production universe operations."
        )


class CRSPDataProviderAdapter:
    """Adapter to make CRSPLocalProvider conform to DataProvider protocol."""

    def __init__(self, provider: CRSPLocalProvider) -> None:
        self._provider = provider

    @property
    def name(self) -> str:
        return "crsp"

    @property
    def is_production_ready(self) -> bool:
        return True

    @property
    def supports_universe(self) -> bool:
        return True

    def get_daily_prices(
        self,
        symbols: list[str],
        start_date: date,
        end_date: date,
    ) -> pl.DataFrame:
        if not symbols:
            raise ValueError("symbols list cannot be empty")

        df = self._provider.get_daily_prices(
            start_date=start_date,
            end_date=end_date,
            symbols=symbols,
            adjust_prices=True,  # Use abs(prc)
        )
        return self._normalize_schema(df)

    def _normalize_schema(self, df: pl.DataFrame) -> pl.DataFrame:
        """Normalize CRSP output to unified schema."""
        # Rename columns
        df = df.rename({
            "ticker": "symbol",
            "prc": "close",
            "vol": "volume",
        })

        # Ensure uppercase symbols
        df = df.with_columns(pl.col("symbol").str.to_uppercase())

        # Add null columns for OHLC and adj_close
        # CRITICAL: adj_close is NULL because CRSP prc is NOT split-adjusted
        # Use `ret` column for performance calculations (ret IS split-adjusted)
        for col in ["open", "high", "low", "adj_close"]:
            df = df.with_columns(pl.lit(None).cast(pl.Float64).alias(col))

        # Select columns in canonical order
        return df.select([
            "date", "symbol", "close", "volume", "ret",
            "open", "high", "low", "adj_close"
        ])

    def get_universe(self, as_of_date: date) -> list[str]:
        universe_df = self._provider.get_universe(as_of_date=as_of_date)
        # Return uppercase symbols for consistency
        return [s.upper() for s in universe_df["ticker"].to_list()]
```

---

## 2. UnifiedDataFetcher Implementation

### 2.1 Configuration

```python
# libs/data_providers/unified_fetcher.py
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
import os

class ProviderType(str, Enum):
    YFINANCE = "yfinance"
    CRSP = "crsp"
    AUTO = "auto"  # Auto-select based on environment

@dataclass
class FetcherConfig:
    """Configuration for UnifiedDataFetcher."""

    provider: ProviderType = ProviderType.AUTO
    environment: str = "development"

    # Provider-specific paths
    yfinance_storage_path: Path | None = None
    crsp_storage_path: Path | None = None
    manifest_path: Path | None = None

    # Fallback behavior (CRITICAL: forced False in production)
    fallback_enabled: bool = True

    def __post_init__(self) -> None:
        """Enforce production safety rules."""
        # Normalize environment to lowercase
        self.environment = self.environment.lower()

        # CRITICAL: Fallback ALWAYS disabled in production
        if self.environment == "production":
            self.fallback_enabled = False

    def validate_paths(self) -> None:
        """Validate configured storage paths exist and are readable.

        Raises:
            ConfigurationError: If any configured path is invalid.

        Validation Rules:
        1. If yfinance_storage_path is set, it must exist and be a directory
        2. If crsp_storage_path is set, it must exist and be a directory
        3. If manifest_path is set, it must exist and be a directory
        4. Paths are only validated if they are configured (None = skip)
        """
        paths_to_check = [
            ("yfinance_storage_path", self.yfinance_storage_path),
            ("crsp_storage_path", self.crsp_storage_path),
            ("manifest_path", self.manifest_path),
        ]

        for name, path in paths_to_check:
            if path is not None:
                if not path.exists():
                    raise ConfigurationError(
                        f"{name} does not exist: {path}"
                    )
                if not path.is_dir():
                    raise ConfigurationError(
                        f"{name} is not a directory: {path}"
                    )

    @classmethod
    def from_env(cls) -> "FetcherConfig":
        """Load config from environment variables.

        Environment variables:
            DATA_PROVIDER: auto|yfinance|crsp (default: auto)
            ENVIRONMENT: development|test|staging|production (default: development)
            YFINANCE_STORAGE_PATH: Path to yfinance cache
            CRSP_STORAGE_PATH: Path to CRSP data
            MANIFEST_PATH: Path to data manifests
            FALLBACK_ENABLED: true|false (ignored in production)

        Note: Paths are validated lazily when validate_paths() is called,
        not during config construction.
        """
        env = os.getenv("ENVIRONMENT", "development").lower()

        # Parse fallback, but will be overridden in __post_init__ for prod
        fallback_str = os.getenv("FALLBACK_ENABLED", "true").lower()
        fallback = fallback_str in ("true", "1", "yes")

        return cls(
            provider=ProviderType(os.getenv("DATA_PROVIDER", "auto").lower()),
            environment=env,
            yfinance_storage_path=Path(p) if (p := os.getenv("YFINANCE_STORAGE_PATH")) else None,
            crsp_storage_path=Path(p) if (p := os.getenv("CRSP_STORAGE_PATH")) else None,
            manifest_path=Path(p) if (p := os.getenv("MANIFEST_PATH")) else None,
            fallback_enabled=fallback,
        )
```

### 2.2 Provider Selection Logic (CRITICAL - addresses contradictory rules)

```python
class UnifiedDataFetcher:
    """Unified interface for fetching market data.

    Provider Selection Rules (EXPLICIT):

    1. AUTO mode:
       - Production: CRSP required, NO fallback, error if unavailable
       - Development/Test: CRSP preferred, fallback to yfinance if enabled

    2. Explicit mode (YFINANCE or CRSP):
       - Use specified provider
       - Error if unavailable (no fallback)

    3. Universe operations:
       - ALWAYS require supports_universe=True provider
       - yfinance cannot serve universe (raises ProviderNotSupportedError)
    """

    def __init__(
        self,
        config: FetcherConfig,
        yfinance_provider: YFinanceProvider | None = None,
        crsp_provider: CRSPLocalProvider | None = None,
    ) -> None:
        self._config = config
        self._adapters: dict[ProviderType, DataProvider] = {}

        # Initialize available adapters
        if yfinance_provider is not None:
            self._adapters[ProviderType.YFINANCE] = YFinanceDataProviderAdapter(yfinance_provider)
        if crsp_provider is not None:
            self._adapters[ProviderType.CRSP] = CRSPDataProviderAdapter(crsp_provider)

        logger.info(
            "UnifiedDataFetcher initialized",
            extra={
                "available_providers": list(self._adapters.keys()),
                "config_provider": config.provider.value,
                "environment": config.environment,
                "fallback_enabled": config.fallback_enabled,
            },
        )

    def _select_provider(self, require_universe: bool = False) -> DataProvider:
        """Select provider based on config and availability.

        Args:
            require_universe: If True, only return providers supporting universe.

        Raises:
            ProviderUnavailableError: If requested provider not available.
            ProductionProviderRequiredError: If production requires CRSP but unavailable.
            ProviderNotSupportedError: If require_universe but no provider supports it.
        """
        # Handle explicit provider selection
        if self._config.provider != ProviderType.AUTO:
            provider = self._adapters.get(self._config.provider)
            if provider is None:
                raise ProviderUnavailableError(
                    f"Requested provider '{self._config.provider.value}' is not available. "
                    f"Available: {[p.value for p in self._adapters.keys()]}"
                )
            if require_universe and not provider.supports_universe:
                raise ProviderNotSupportedError(
                    f"Provider '{provider.name}' does not support universe queries."
                )
            return provider

        # AUTO mode selection
        is_production = self._config.environment == "production"

        # Production: CRSP required, NO fallback
        if is_production:
            crsp = self._adapters.get(ProviderType.CRSP)
            if crsp is None:
                raise ProductionProviderRequiredError(
                    "Production environment requires CRSP provider but it is not available. "
                    "Configure CRSP data source or change environment."
                )
            return crsp

        # Development/Test: prefer CRSP, fallback to yfinance if enabled
        if ProviderType.CRSP in self._adapters:
            return self._adapters[ProviderType.CRSP]

        if self._config.fallback_enabled and ProviderType.YFINANCE in self._adapters:
            yf = self._adapters[ProviderType.YFINANCE]
            if require_universe:
                raise ProviderNotSupportedError(
                    "Universe queries require CRSP provider. "
                    "yfinance does not support universe operations."
                )
            logger.warning(
                "Using yfinance fallback - NOT suitable for production",
                extra={"environment": self._config.environment},
            )
            return yf

        raise ProviderUnavailableError(
            "No data provider available. Configure CRSP or enable yfinance fallback."
        )

    def get_daily_prices(
        self,
        symbols: list[str],
        start_date: date,
        end_date: date,
    ) -> pl.DataFrame:
        """Fetch daily prices using selected provider."""
        provider = self._select_provider(require_universe=False)

        self._log_usage(provider.name, "get_daily_prices", len(symbols))

        return provider.get_daily_prices(symbols, start_date, end_date)

    def get_universe(self, as_of_date: date) -> list[str]:
        """Get tradeable universe using selected provider.

        Note: This operation requires a production-ready provider (CRSP).
        yfinance cannot serve universe queries.
        """
        provider = self._select_provider(require_universe=True)

        self._log_usage(provider.name, "get_universe", 0)

        return provider.get_universe(as_of_date)

    def get_active_provider(self) -> str:
        """Return name of currently active provider."""
        return self._select_provider().name

    def is_available(self, provider_type: ProviderType) -> bool:
        """Check if a specific provider is available."""
        return provider_type in self._adapters

    def _log_usage(
        self,
        provider: str,
        operation: str,
        count: int,
    ) -> None:
        """Log usage metrics for monitoring."""
        logger.info(
            "Data fetch operation",
            extra={
                "provider": provider,
                "operation": operation,
                "symbol_count": count,
                "environment": self._config.environment,
            },
        )
```

### 2.3 Custom Exceptions (CRITICAL - addresses error handling gaps)

```python
# libs/data_providers/protocols.py (exceptions section)

class DataProviderError(Exception):
    """Base exception for data provider errors."""
    pass

class ProviderUnavailableError(DataProviderError):
    """Raised when a requested provider is not available.

    Attributes:
        provider_name: Name of the unavailable provider.
        available_providers: List of available provider names.
    """
    def __init__(
        self,
        message: str,
        provider_name: str | None = None,
        available_providers: list[str] | None = None,
    ) -> None:
        super().__init__(message)
        self.provider_name = provider_name
        self.available_providers = available_providers or []

class ProviderNotSupportedError(DataProviderError):
    """Raised when operation not supported by provider.

    Example: get_universe() on yfinance.

    Attributes:
        provider_name: Provider that doesn't support the operation.
        operation: The unsupported operation name.
    """
    def __init__(
        self,
        message: str,
        provider_name: str | None = None,
        operation: str | None = None,
    ) -> None:
        super().__init__(message)
        self.provider_name = provider_name
        self.operation = operation

class ProductionProviderRequiredError(DataProviderError):
    """Raised when production env requires production-ready provider.

    This occurs when:
    - environment=production AND
    - AUTO mode selected AND
    - CRSP provider not available
    """
    pass

class ConfigurationError(DataProviderError):
    """Raised when fetcher configuration is invalid.

    Examples:
    - Invalid storage paths
    - Missing required config
    """
    pass
```

---

## 3. CLI Script

```python
# scripts/fetch_data.py
"""CLI for fetching market data via UnifiedDataFetcher.

Exit Codes:
    0: Success
    1: Provider error (unavailable, not supported)
    2: Configuration error (invalid paths, missing config)
    3: Data error (empty result, invalid symbols)

Output Formats:
    --output file.parquet: Write Parquet file
    --output file.csv: Write CSV file
    (no --output): Print to stdout as table

Usage:
    python scripts/fetch_data.py prices --symbols AAPL,MSFT --start 2024-01-01 --end 2024-12-31
    python scripts/fetch_data.py prices --symbols AAPL --start 2024-01-01 --end 2024-12-31 --output prices.parquet
    python scripts/fetch_data.py universe --date 2024-01-15
    python scripts/fetch_data.py status  # Show active provider and config
"""

import argparse
import sys
from datetime import date, datetime
from pathlib import Path

EXIT_SUCCESS = 0
EXIT_PROVIDER_ERROR = 1
EXIT_CONFIG_ERROR = 2
EXIT_DATA_ERROR = 3

def main() -> int:
    parser = argparse.ArgumentParser(description="Fetch market data")
    subparsers = parser.add_subparsers(dest="command", required=True)

    # prices command
    prices_parser = subparsers.add_parser("prices", help="Fetch daily prices")
    prices_parser.add_argument("--symbols", required=True, help="Comma-separated symbols")
    prices_parser.add_argument("--start", required=True, help="Start date (YYYY-MM-DD)")
    prices_parser.add_argument("--end", required=True, help="End date (YYYY-MM-DD)")
    prices_parser.add_argument(
        "--provider",
        choices=["auto", "yfinance", "crsp"],
        default="auto",
        help="Data provider (default: auto)"
    )
    prices_parser.add_argument(
        "--output",
        help="Output file (.parquet or .csv). Omit for stdout."
    )

    # universe command
    universe_parser = subparsers.add_parser("universe", help="Get tradeable universe")
    universe_parser.add_argument("--date", required=True, help="As-of date (YYYY-MM-DD)")
    universe_parser.add_argument(
        "--output",
        help="Output file (.txt, one symbol per line). Omit for stdout."
    )

    # status command
    status_parser = subparsers.add_parser("status", help="Show provider status")

    args = parser.parse_args()

    try:
        if args.command == "prices":
            return handle_prices(args)
        elif args.command == "universe":
            return handle_universe(args)
        elif args.command == "status":
            return handle_status(args)
    except (ProviderUnavailableError, ProviderNotSupportedError, ProductionProviderRequiredError) as e:
        print(f"Provider error: {e}", file=sys.stderr)
        return EXIT_PROVIDER_ERROR
    except ConfigurationError as e:
        print(f"Configuration error: {e}", file=sys.stderr)
        return EXIT_CONFIG_ERROR
    except ValueError as e:
        print(f"Data error: {e}", file=sys.stderr)
        return EXIT_DATA_ERROR

    return EXIT_SUCCESS

def handle_prices(args) -> int:
    """Handle prices subcommand."""
    # Parse arguments
    symbols = [s.strip().upper() for s in args.symbols.split(",")]
    start = datetime.strptime(args.start, "%Y-%m-%d").date()
    end = datetime.strptime(args.end, "%Y-%m-%d").date()

    # Create fetcher
    config = FetcherConfig.from_env()
    config.provider = ProviderType(args.provider)
    fetcher = create_fetcher(config)

    # Fetch data
    df = fetcher.get_daily_prices(symbols, start, end)

    if df.is_empty():
        print("No data returned", file=sys.stderr)
        return EXIT_DATA_ERROR

    # Output
    if args.output:
        output_path = Path(args.output)
        if output_path.suffix == ".parquet":
            df.write_parquet(output_path)
        elif output_path.suffix == ".csv":
            df.write_csv(output_path)
        else:
            print(f"Unknown output format: {output_path.suffix}", file=sys.stderr)
            return EXIT_CONFIG_ERROR
        print(f"Wrote {df.height} rows to {output_path}")
    else:
        print(df)

    return EXIT_SUCCESS

def handle_status(args) -> int:
    """Handle status subcommand.

    Output format:
        Environment: development
        Configured Provider: auto
        Active Provider: crsp
        Available Providers: crsp, yfinance
        Fallback Enabled: true
        CRSP Available: true
        yfinance Available: true
    """
    config = FetcherConfig.from_env()
    fetcher = create_fetcher(config)

    print(f"Environment: {config.environment}")
    print(f"Configured Provider: {config.provider.value}")

    try:
        active = fetcher.get_active_provider()
        print(f"Active Provider: {active}")
    except DataProviderError as e:
        print(f"Active Provider: ERROR - {e}")

    available = []
    if fetcher.is_available(ProviderType.CRSP):
        available.append("crsp")
    if fetcher.is_available(ProviderType.YFINANCE):
        available.append("yfinance")

    print(f"Available Providers: {', '.join(available) or 'none'}")
    print(f"Fallback Enabled: {str(config.fallback_enabled).lower()}")
    print(f"CRSP Available: {str(fetcher.is_available(ProviderType.CRSP)).lower()}")
    print(f"yfinance Available: {str(fetcher.is_available(ProviderType.YFINANCE)).lower()}")

    return EXIT_SUCCESS
```

---

## 4. Test Cases (EXPANDED - addresses test coverage gaps)

### 4.1 Protocol Compliance Tests

```python
# tests/libs/data_providers/test_protocols.py

def test_yfinance_adapter_protocol_compliance():
    """YFinanceDataProviderAdapter implements DataProvider protocol."""

def test_crsp_adapter_protocol_compliance():
    """CRSPDataProviderAdapter implements DataProvider protocol."""

def test_provider_name_property():
    """Each adapter returns correct provider name."""

def test_provider_production_ready_flag():
    """yfinance returns False, CRSP returns True for is_production_ready."""

def test_provider_supports_universe_flag():
    """yfinance returns False, CRSP returns True for supports_universe."""
```

### 4.2 Schema Normalization Tests (NEW)

```python
def test_yfinance_schema_normalization():
    """yfinance output normalized to unified schema with null ret."""

def test_crsp_schema_normalization():
    """CRSP output normalized with ticker->symbol, null OHLC."""

def test_schema_column_order_consistent():
    """Both adapters return columns in same canonical order."""

def test_symbols_normalized_to_uppercase():
    """Both adapters normalize symbols to uppercase."""

def test_crsp_null_ohlc_columns():
    """CRSP adapter sets open/high/low to null."""

def test_crsp_adj_close_is_null():
    """CRSP adapter sets adj_close to null (prc is NOT split-adjusted)."""

def test_crsp_ret_column_preserved():
    """CRSP adapter preserves ret column for performance calculations."""

def test_volume_units_raw_shares():
    """Volume is in raw shares, not hundreds."""
```

### 4.3 Provider Factory Tests (EXPANDED)

```python
def test_auto_returns_crsp_in_production():
    """In production with AUTO, CRSP is required."""

def test_auto_error_when_crsp_missing_in_production():
    """In production with AUTO and no CRSP, raises ProductionProviderRequiredError."""

def test_auto_fallback_to_yfinance_in_development():
    """In development with AUTO, falls back to yfinance if CRSP unavailable."""

def test_fallback_disabled_in_production():
    """Fallback is forced False in production regardless of config."""

def test_fallback_disabled_raises_when_primary_unavailable():
    """With fallback=False, error if primary provider unavailable."""

def test_explicit_provider_no_fallback():
    """Explicit provider selection doesn't fallback."""

def test_explicit_provider_unavailable_error():
    """Explicit provider not available raises ProviderUnavailableError."""
```

### 4.4 Universe Operation Tests (NEW)

```python
def test_get_universe_with_crsp():
    """get_universe works with CRSP provider."""

def test_get_universe_with_yfinance_raises():
    """get_universe with yfinance raises ProviderNotSupportedError."""

def test_auto_mode_universe_requires_crsp():
    """In AUTO mode, universe operation requires CRSP even if yfinance available."""

def test_universe_explicit_yfinance_raises():
    """Explicit yfinance selection for universe raises ProviderNotSupportedError."""
```

### 4.5 Error Handling Tests (NEW)

```python
def test_provider_unavailable_error_attributes():
    """ProviderUnavailableError includes provider name and available list."""

def test_provider_not_supported_error_attributes():
    """ProviderNotSupportedError includes provider name and operation."""

def test_empty_symbols_raises_value_error():
    """Empty symbols list raises ValueError."""

def test_invalid_storage_path_raises_config_error():
    """Invalid storage path raises ConfigurationError."""
```

### 4.6 Config Loading Tests (NEW)

```python
def test_config_from_env_defaults():
    """Default config values when no env vars set."""

def test_config_from_env_all_vars():
    """Config loads all environment variables."""

def test_config_environment_case_insensitive():
    """Environment is normalized to lowercase."""

def test_config_fallback_forced_false_in_production():
    """fallback_enabled forced to False when environment=production."""

def test_config_validate_paths_success():
    """validate_paths succeeds when all configured paths exist."""

def test_config_validate_paths_missing_dir():
    """validate_paths raises ConfigurationError for missing directory."""

def test_config_validate_paths_not_directory():
    """validate_paths raises ConfigurationError when path is not a directory."""

def test_config_validate_paths_skips_none():
    """validate_paths skips validation for None paths."""
```

### 4.7 Usage Metrics Tests

```python
def test_usage_metrics_logged():
    """Each operation logs provider, operation, and count."""

def test_get_active_provider_returns_current():
    """get_active_provider returns name of selected provider."""

def test_is_available_returns_correct_status():
    """is_available returns True/False correctly for each provider."""
```

### 4.8 CLI Tests (EXPANDED)

```python
def test_cli_prices_stdout():
    """CLI prices command outputs to stdout when no --output."""

def test_cli_prices_parquet_output():
    """CLI prices with --output file.parquet writes Parquet."""

def test_cli_prices_csv_output():
    """CLI prices with --output file.csv writes CSV."""

def test_cli_prices_invalid_format():
    """CLI prices with unknown format returns EXIT_CONFIG_ERROR."""

def test_cli_universe_stdout():
    """CLI universe command outputs symbols to stdout."""

def test_cli_universe_with_yfinance_error():
    """CLI universe with --provider yfinance returns EXIT_PROVIDER_ERROR."""

def test_cli_status_output_format():
    """CLI status outputs expected fields."""

def test_cli_exit_codes():
    """Verify correct exit codes for each error type."""
```

---

## 5. Documentation

### 5.1 Concept Doc: `docs/CONCEPTS/unified-data-fetcher.md`

Content:
- Purpose and motivation
- Unified schema definition (required vs optional columns)
- Provider selection logic (AUTO vs explicit)
- Production safety (fallback disabled)
- Usage examples (Python API and CLI)
- Configuration options (env vars)
- Limitations (yfinance vs CRSP capabilities)
- Error handling (exception types)

### 5.2 ADR: `docs/ADRs/ADR-016-data-provider-protocol.md`

Content:
- Context: Multiple data sources with different schemas/APIs
- Decision: Protocol-based abstraction with adapter pattern
- Schema decision: Common columns required, OHLC optional
- Consequences: Easy provider switching, consistent API, null handling
- Alternatives considered: Inheritance, direct integration, OHLC requirement

---

## 6. Files to Create/Modify

### New Files:
1. `libs/data_providers/protocols.py` - DataProvider protocol, adapters, exceptions
2. `libs/data_providers/unified_fetcher.py` - UnifiedDataFetcher, FetcherConfig
3. `scripts/fetch_data.py` - CLI script
4. `tests/libs/data_providers/test_protocols.py` - Protocol and adapter tests
5. `tests/libs/data_providers/test_unified_fetcher.py` - Fetcher tests
6. `docs/CONCEPTS/unified-data-fetcher.md` - Concept documentation
7. `docs/ADRs/ADR-016-data-provider-protocol.md` - Architecture decision record

### Modified Files:
1. `libs/data_providers/__init__.py` - Export new classes and exceptions

---

## 7. Dependencies

- **Depends on:** T4.1 (yfinance provider) - COMPLETED
- **Blocked by:** None
- **Blocks:** P4T1.8b (CRSP integration into unified fetcher - if split)

---

## 8. Acceptance Criteria

- [ ] DataProvider protocol defined with get_daily_prices, get_universe, supports_universe
- [ ] YFinanceDataProviderAdapter passes protocol compliance
- [ ] CRSPDataProviderAdapter passes protocol compliance
- [ ] Schema normalization produces consistent output from both providers
- [ ] UnifiedDataFetcher correctly selects provider based on config
- [ ] Fallback chain works in development, disabled in production
- [ ] Universe operations require CRSP (yfinance raises ProviderNotSupportedError)
- [ ] Custom exceptions have appropriate attributes
- [ ] Usage metrics logged for all operations
- [ ] CLI script functional with correct exit codes
- [ ] All tests pass with >85% coverage
- [ ] Documentation complete (concept doc + ADR)

---

## 9. Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Schema differences between providers | Unified schema with optional columns; null for missing |
| Universe not supported by yfinance | supports_universe flag; clear exception; require CRSP for universe |
| Production use of yfinance | is_production_ready check; fallback forced off in prod |
| Volume unit inconsistency | Normalize to raw shares in adapters |
| Config loading errors | ConfigurationError with clear message; validate paths |

---

## 10. Review Log

### Review 1: Gemini + Codex (2025-12-05)

**Gemini Review:**
- Status: CHANGES_REQUESTED
- Issues:
  1. HIGH: Schema mismatch (OHLC vs prc) → Fixed: unified schema with optional OHLC
  2. MEDIUM: Fallback logic ambiguous → Fixed: explicit production rules
  3. LOW: Volume unit consistency → Fixed: normalization spec added

**Codex Review:**
- Status: CHANGES_REQUESTED
- Issues:
  1. HIGH: Provider selection contradictory → Fixed: explicit rules documented
  2. HIGH: Schema normalization unspecified → Fixed: full spec in Section 1.3
  3. MEDIUM: get_universe crashes on yfinance → Fixed: supports_universe + guard
  4. MEDIUM: Error handling underspecified → Fixed: custom exceptions in Section 2.3
  5. MEDIUM: Test plan missing cases → Fixed: expanded test cases in Section 4
  6. LOW: CLI behavior unclear → Fixed: exit codes, formats in Section 3

### Review 2: Gemini + Codex (2025-12-05)

**Gemini Review:**
- Status: CHANGES_REQUESTED
- Issues:
  1. HIGH: CRSP adj_close incorrect - prc is NOT split-adjusted → Fixed: adj_close set to null
  2. MEDIUM: CRSP volume ambiguous → Fixed: explicit rule (CRSP daily vol is raw shares)

**Codex Review:**
- Status: APPROVED (with LOW notes)
- Issues:
  1. LOW: CRSP volume still "Verify" → Fixed: explicit rule added
  2. LOW: Config path validation unstated → Fixed: validate_paths() method added

---

**Plan Version:** 2.1
**Author:** Claude Code
