# T4.1 yfinance Integration - Implementation Plan

**Component:** P4T1 Component 7 (T4.1)
**Status:** APPROVED_WITH_SUGGESTIONS (Gemini + Codex)
**Created:** 2025-12-05
**Author:** Claude Code

---

## Overview

yfinance provides free market data for development/testing purposes. This component implements a yfinance data provider with production gating to ensure CRSP is used for production backtests.

**Key Constraints:**
- yfinance lacks survivorship handling and corporate actions
- NOT suitable for production backtests - use CRSP instead
- Dev-only gate enforced by default

---

## Requirements (from P4T1_TASK.md)

### Deliverables
1. yfinance data fetcher with rate limiting
2. Local caching to Parquet
3. Clear dev-only warnings in logs
4. Drift detection against baseline/CRSP when available
5. Config flag to enforce CRSP-only in production

### Production Gating Rules
```python
YFINANCE GATING RULES:
1. Config flag: USE_YFINANCE_IN_PROD = False (default)
2. If CRSP available AND env=production: block yfinance usage
3. Fallback chain: CRSP → (yfinance only if USE_YFINANCE_IN_PROD=True)
4. Log warning if yfinance used in non-dev environment
5. Test: fallback chain cannot silently prioritize yfinance in prod
```

### Drift Detection Baseline
```
data/baseline/
├── spy_60d.parquet      # Last 60 trading days for SPY
├── qqq_60d.parquet      # Last 60 trading days for QQQ
└── baseline_manifest.json  # Source, date range, checksums
```
- Drift check: if |yfinance - baseline| > 1% for price, alert
- Missing baseline: skip drift check with warning (not error)

---

## Review Summary

### Gemini Review: APPROVED_WITH_SUGGESTIONS
**Key Feedback:**
1. **Simplify Storage Layout** - Use flat structure `data/yfinance/daily/{SYMBOL}.parquet`
2. **Dependencies** - Add `yfinance` to requirements.txt
3. **Atomic Writes** - Copy pattern from FamaFrenchLocalProvider
4. **Manifest** - Simple tracking: symbol, last_updated, start_date, end_date, checksum
5. **Drift Detection** - Automatic on download, not on every cache read

### Codex Review: APPROVED_WITH_SUGGESTIONS
**Key Feedback:**
1. **Reuse atomic patterns** - temp→checksum→rename→manifest fsync + quarantine
2. **Exhaustive prod gating tests** - Matrix tests for env × CRSP presence × flag
3. **CRSP availability probe** - Define manifest existence check contract
4. **ENOSPC handling** - Add disk-space guardrails
5. **Split-brain lock recovery** - Add concurrency tests

---

## Implementation Plan

### Phase 1: Storage Layout (Simplified per Gemini feedback)
```
data/yfinance/
├── daily/
│   ├── SPY.parquet
│   ├── AAPL.parquet
│   └── ...
├── quarantine/           # Failed/corrupted files
├── locks/                # Lock files
└── yfinance_manifest.json
```

### Phase 2: YFinanceProvider Class

```python
class YFinanceProvider:
    """Free data provider for development/testing only.

    WARNING: yfinance lacks survivorship handling and corporate actions.
    NOT suitable for production backtests - use CRSP instead.

    Features:
    - Rate-limited downloads with retries
    - Local Parquet caching with atomic writes
    - Production gating (blocks yfinance when CRSP available in prod)
    - Drift detection against baseline data
    - Quarantine for failed/corrupted files
    """

    DATASET_NAME = "yfinance"

    # Rate limiting
    MAX_RETRIES = 3
    RETRY_DELAY_SECONDS = 2.0
    REQUEST_DELAY_SECONDS = 0.5  # Between symbols

    # Drift tolerance
    DEFAULT_DRIFT_TOLERANCE = 0.01  # 1%

    def __init__(
        self,
        storage_path: Path,
        baseline_path: Path | None = None,
        lock_dir: Path | None = None,
        environment: str = "development",
        use_yfinance_in_prod: bool = False,
        crsp_available: bool = False,
    ) -> None:
        """Initialize provider with production gating.

        Args:
            storage_path: Base path for cache storage.
            baseline_path: Path to baseline data for drift detection.
            lock_dir: Directory for lock files.
            environment: Current environment (development/test/production).
            use_yfinance_in_prod: Override to allow yfinance in production.
            crsp_available: Whether CRSP data is available.
        """

    def get_daily_prices(
        self,
        symbols: list[str],
        start_date: date,
        end_date: date,
        use_cache: bool = True,
    ) -> pl.DataFrame:
        """Fetch daily OHLCV data with caching.

        Args:
            symbols: List of ticker symbols.
            start_date: Start of date range.
            end_date: End of date range.
            use_cache: Whether to use cached data if available.

        Returns:
            DataFrame with columns: date, symbol, open, high, low, close, volume, adj_close

        Raises:
            RuntimeError: If yfinance blocked in current environment.
        """

    def fetch_and_cache(
        self,
        symbols: list[str],
        start_date: date | None = None,
        end_date: date | None = None,
    ) -> dict[str, Any]:
        """Download from yfinance and cache locally with drift detection.

        Drift detection runs automatically after download (per Gemini feedback).

        Returns:
            Dict with sync results: files, failed_symbols, drift_warnings
        """

    def verify_data(self) -> dict[str, bool]:
        """Verify checksums of cached files."""

    def check_drift(
        self,
        symbol: str,
        tolerance: float = DEFAULT_DRIFT_TOLERANCE,
    ) -> tuple[bool, float | None]:
        """Check price drift against baseline.

        Returns:
            Tuple of (passed, max_drift). max_drift is None if baseline missing.
        """

    def invalidate_cache(self, symbols: list[str] | None = None) -> None:
        """Invalidate cache for specified symbols (or all if None)."""
```

### Phase 3: Production Gating Implementation

```python
def _check_production_gate(self) -> None:
    """Block yfinance in production when CRSP is available.

    Matrix of conditions (per Codex feedback):
    - env=production, CRSP=available, flag=False → BLOCK
    - env=production, CRSP=available, flag=True → BLOCK (CRSP takes priority)
    - env=production, CRSP=unavailable, flag=False → BLOCK
    - env=production, CRSP=unavailable, flag=True → WARN + ALLOW
    - env=development/test → ALLOW (always)
    - env=staging → WARN + ALLOW

    Raises:
        RuntimeError: If yfinance blocked in current environment.
    """
    if self.environment in ("development", "test"):
        return  # Always allowed

    if self.environment == "production":
        if self.crsp_available:
            raise RuntimeError(
                "yfinance blocked: CRSP data is available. "
                "Use CRSP for production backtests."
            )

        if not self.use_yfinance_in_prod:
            raise RuntimeError(
                "yfinance blocked in production. "
                "Set USE_YFINANCE_IN_PROD=true to override (NOT recommended)."
            )

        logger.warning(
            "yfinance used in production without CRSP",
            extra={"use_yfinance_in_prod": True, "crsp_available": False},
        )
    else:
        # staging or other environments
        logger.warning(
            "yfinance used in non-development environment",
            extra={"environment": self.environment},
        )
```

### Phase 4: Drift Detection Implementation

```python
def check_drift(
    self,
    symbol: str,
    yfinance_data: pl.DataFrame,
    tolerance: float = 0.01,
) -> tuple[bool, float | None]:
    """Check price drift against baseline data.

    Compares closing prices between yfinance and baseline data.
    Only compares dates that exist in both datasets.

    Args:
        symbol: Symbol to check (e.g., "SPY").
        yfinance_data: DataFrame from yfinance.
        tolerance: Maximum allowed drift (default 1%).

    Returns:
        Tuple of (passed, max_drift). max_drift is None if baseline missing.
    """
    if self.baseline_path is None:
        logger.debug("No baseline path configured - skipping drift check")
        return True, None

    baseline_file = self.baseline_path / f"{symbol.lower()}_60d.parquet"

    if not baseline_file.exists():
        logger.warning(
            "Baseline missing for drift check - skipping",
            extra={"symbol": symbol, "path": str(baseline_file)},
        )
        return True, None  # Pass with warning (per requirements)

    # Load baseline and join on date
    baseline_df = pl.read_parquet(baseline_file)

    # Align data by date (inner join)
    joined = yfinance_data.join(
        baseline_df.select(["date", "close"]).rename({"close": "baseline_close"}),
        on="date",
        how="inner",
    )

    if joined.is_empty():
        logger.warning(
            "No overlapping dates for drift check",
            extra={"symbol": symbol},
        )
        return True, None

    # Calculate drift: |yfinance - baseline| / baseline
    drift = (
        (joined["close"] - joined["baseline_close"]).abs()
        / joined["baseline_close"]
    )
    max_drift = float(drift.max())

    if max_drift > tolerance:
        logger.warning(
            "Price drift detected",
            extra={
                "symbol": symbol,
                "max_drift": f"{max_drift:.4f}",
                "tolerance": tolerance,
            },
        )
        return False, max_drift

    return True, max_drift
```

### Phase 5: Atomic Write Pattern (from FamaFrenchLocalProvider)

```python
def _atomic_write_parquet(
    self,
    df: pl.DataFrame,
    target_path: Path,
) -> str:
    """Write Parquet atomically using temp file + rename + quarantine.

    Pattern (per repo standards):
    1. Check disk space (ENOSPC handling per Codex)
    2. Write to temp path: target.parquet.tmp
    3. Compute checksum of temp file
    4. Validate: row count > 0
    5. On validation failure: move to quarantine
    6. Atomic rename: temp -> target
    7. fsync directory for crash safety
    8. Return checksum
    """
    # Check disk space before write
    self._check_disk_space(target_path.parent)

    target_path.parent.mkdir(parents=True, exist_ok=True)
    temp_path = target_path.with_suffix(".parquet.tmp")

    try:
        df.write_parquet(temp_path)
        actual_checksum = self._compute_checksum(temp_path)

        if df.height == 0:
            self._quarantine_file(temp_path, "empty_dataframe")
            raise ValueError("Empty DataFrame, file quarantined")

        # Atomic rename
        temp_path.rename(target_path)

        # fsync directory for crash safety
        self._fsync_directory(target_path.parent)

        return actual_checksum

    except Exception:
        if temp_path.exists():
            temp_path.unlink(missing_ok=True)
        raise
```

---

## Test Cases

### Basic Functionality
1. Single symbol fetch
2. Bulk symbol fetch with rate limiting (verify delays)
3. Local cache hit behavior
4. Local cache miss triggers download
5. Empty symbol list handling

### Production Gating (Matrix Tests per Codex)
6. env=development → allowed
7. env=test → allowed
8. env=production, CRSP=available → blocked
9. env=production, CRSP=unavailable, flag=False → blocked
10. env=production, CRSP=unavailable, flag=True → warned + allowed
11. env=staging → warned + allowed

### Drift Detection
12. Drift within tolerance → passes
13. Drift exceeds tolerance → warns + fails
14. Missing baseline → passes with warning
15. No overlapping dates → passes with warning
16. Baseline manifest validation

### Atomic Writes & Integrity
17. Atomic write prevents partial reads (.tmp not visible)
18. Checksum mismatch triggers quarantine
19. Empty DataFrame triggers quarantine
20. ENOSPC handling (disk-full test)
21. Split-brain lock recovery

### Logging
22. Dev-only warning in non-dev environments
23. Structured logging with symbol/drift info

---

## Files to Create

| File | Description | Est. Lines |
|------|-------------|------------|
| `libs/data_providers/yfinance_provider.py` | Provider implementation | ~450 |
| `tests/libs/data_providers/test_yfinance_provider.py` | Test suite | ~600 |
| `docs/CONCEPTS/yfinance-limitations.md` | Limitations documentation | ~60 |

---

## Dependencies

Add to `requirements.txt`:
```
yfinance>=0.2.0
```

Existing dependencies used:
- polars
- duckdb
- AtomicFileLock (from libs/data_providers/locking.py)

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Locking/manifest divergence | Use shared atomic patterns + fsync; regression tests |
| Prod gate bypass via config misread | Centralize env detection; default False; matrix tests |
| yfinance schema drift | Normalize columns; document limitations; drift tolerances |
| Rate limiting issues | Exponential backoff with jitter; configurable delays |

---

## Next Steps

1. Add `yfinance` to requirements.txt
2. Implement `YFinanceProvider` class
3. Implement production gating logic
4. Implement drift detection
5. Create test suite with matrix tests
6. Create limitations documentation
7. Request code review (fresh Gemini + Codex)
8. Run `make ci-local`
9. Commit

---

**Last Updated:** 2025-12-05
**Review Status:** Plan approved by Gemini + Codex
