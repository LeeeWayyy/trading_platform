"""Integration tests for web_console_auth library.

Tests cover:
- Full token lifecycle (create → validate → refresh → revoke)
- Multi-session concurrency with session limits
- Real JWT keys from Component 1 certificate infrastructure
"""

import time
from pathlib import Path

import pytest
from fakeredis import FakeRedis

from libs.web_console_auth.config import AuthConfig
from libs.web_console_auth.exceptions import TokenRevokedError
from libs.web_console_auth.jwt_manager import JWTManager
from libs.web_console_auth.session import SessionManager


class TestFullTokenLifecycle:
    """Test complete token lifecycle from creation to revocation."""

    def test_full_lifecycle(self, session_manager):
        """Test: create → validate → refresh → revoke → validate (rejected)."""
        # 1. Create session
        access_token1, refresh_token = session_manager.create_session(
            user_id="integration_user",
            client_ip="192.168.1.100",
            user_agent="Mozilla/5.0 Integration Test",
        )

        # 2. Validate access token
        payload1 = session_manager.validate_session(access_token1, "192.168.1.100", "Mozilla/5.0 Integration Test")
        assert payload1["sub"] == "integration_user"
        session_id = payload1["session_id"]
        access_jti1 = payload1["jti"]

        # 3. Refresh session (get new access + refresh tokens)
        access_token2, refresh_token2 = session_manager.refresh_session(
            refresh_token, "192.168.1.100", "Mozilla/5.0 Integration Test"
        )
        payload2 = session_manager.validate_session(access_token2, "192.168.1.100", "Mozilla/5.0 Integration Test")
        assert payload2["session_id"] == session_id  # Same session
        assert payload2["jti"] != access_jti1  # Different access token

        # 4. Revoke session (blacklist all tokens)
        session_manager.terminate_session(session_id)

        # 5. Validate should fail (tokens revoked)
        with pytest.raises(TokenRevokedError):
            session_manager.validate_session(access_token1, "192.168.1.100", "Mozilla/5.0 Integration Test")

        with pytest.raises(TokenRevokedError):
            session_manager.validate_session(access_token2, "192.168.1.100", "Mozilla/5.0 Integration Test")


class TestConcurrentSessions:
    """Test concurrent session handling and limits."""

    def test_concurrent_sessions_with_limit(self, session_manager):
        """Test creating 4 sessions verifies 1st is evicted (max 3)."""
        user_id = "multi_session_user"
        client_ip = "192.168.1.100"
        user_agent = "Mozilla/5.0"

        session_ids = []

        # Create 4 sessions
        for _ in range(4):
            access_token, _ = session_manager.create_session(user_id, client_ip, user_agent)
            payload = session_manager.jwt.decode_token(access_token)
            session_ids.append(payload["session_id"])
            time.sleep(0.01)  # Ensure different timestamps

        # Verify first session was evicted
        first_session_key = f"{session_manager.config.redis_session_prefix}{session_ids[0]}"
        assert not session_manager.redis.exists(first_session_key)

        # Verify last 3 sessions exist and are valid
        for session_id in session_ids[1:]:
            session_key = f"{session_manager.config.redis_session_prefix}{session_id}"
            assert session_manager.redis.exists(session_key)

    def test_session_limit_per_user_isolated(self, session_manager):
        """Test session limits are per-user (different users don't affect each other)."""
        # User 1 creates 3 sessions
        for _ in range(3):
            session_manager.create_session("user1", "192.168.1.100", "Mozilla/5.0")

        # User 2 creates 3 sessions
        for _ in range(3):
            session_manager.create_session("user2", "192.168.1.101", "Mozilla/5.0")

        # Both users should have 3 sessions each (not evicted)
        user1_index = f"{session_manager.config.redis_session_index_prefix}user1"
        user2_index = f"{session_manager.config.redis_session_index_prefix}user2"

        assert session_manager.redis.zcard(user1_index) == 3
        assert session_manager.redis.zcard(user2_index) == 3


class TestRealJWTKeys:
    """Test integration with real JWT keys from Component 1."""

    def test_real_jwt_keys_from_certs(self):
        """Test loading actual JWT keys from apps/web_console/certs/."""
        # Path to real JWT keys generated by Component 1
        private_key_path = Path("apps/web_console/certs/jwt_private.key")
        public_key_path = Path("apps/web_console/certs/jwt_public.pem")

        # Skip test if keys don't exist (CI environment, or certs not generated yet)
        if not private_key_path.exists() or not public_key_path.exists():
            pytest.skip("JWT keys from Component 1 not found (run scripts/generate_certs.py)")

        # Load keys
        config = AuthConfig(
            jwt_private_key_path=private_key_path,
            jwt_public_key_path=public_key_path,
        )
        redis_client = FakeRedis()
        jwt_manager = JWTManager(config, redis_client)

        # Generate and validate token
        token = jwt_manager.generate_access_token("test_user", "session_123", "127.0.0.1", "Test UA")
        payload = jwt_manager.validate_token(token, "access")

        assert payload["sub"] == "test_user"
        assert payload["type"] == "access"

    def test_full_integration_with_real_keys(self):
        """Test full session workflow with real JWT keys."""
        private_key_path = Path("apps/web_console/certs/jwt_private.key")
        public_key_path = Path("apps/web_console/certs/jwt_public.pem")

        if not private_key_path.exists() or not public_key_path.exists():
            pytest.skip("JWT keys from Component 1 not found")

        # Create managers with real keys
        config = AuthConfig(
            jwt_private_key_path=private_key_path,
            jwt_public_key_path=public_key_path,
        )
        redis_client = FakeRedis()
        jwt_manager = JWTManager(config, redis_client)
        session_manager = SessionManager(redis_client, jwt_manager, config)

        # Full workflow
        access_token, refresh_token = session_manager.create_session("real_user", "127.0.0.1", "Real UA")
        payload = session_manager.validate_session(access_token, "127.0.0.1", "Real UA")
        assert payload["sub"] == "real_user"

        # Refresh
        new_access_token, new_refresh_token = session_manager.refresh_session(
            refresh_token, "127.0.0.1", "Real UA"
        )
        new_payload = session_manager.validate_session(new_access_token, "127.0.0.1", "Real UA")
        assert new_payload["sub"] == "real_user"


# Fixtures


@pytest.fixture()
def jwt_keys(tmp_path):
    """Generate temporary JWT RSA key pair for testing."""
    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.primitives.asymmetric import rsa

    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    public_key = private_key.public_key()

    private_key_path = tmp_path / "jwt_private.key"
    with private_key_path.open("wb") as f:
        f.write(
            private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption(),
            )
        )

    public_key_path = tmp_path / "jwt_public.pem"
    with public_key_path.open("wb") as f:
        f.write(
            public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo,
            )
        )

    return private_key_path, public_key_path


@pytest.fixture()
def jwt_manager(jwt_keys):
    """Create JWTManager with temporary keys and fake Redis."""
    private_key_path, public_key_path = jwt_keys
    config = AuthConfig(
        jwt_private_key_path=private_key_path,
        jwt_public_key_path=public_key_path,
    )
    return JWTManager(config, FakeRedis())


@pytest.fixture()
def session_manager(jwt_manager):
    """Create SessionManager with fake Redis and JWTManager."""
    config = AuthConfig()
    return SessionManager(FakeRedis(), jwt_manager, config)
