"""
Deterministic client_order_id generation for idempotent order submission.

The client_order_id is generated using a SHA256 hash of the order parameters
plus the current date. This ensures that:
1. The same order submitted multiple times on the same day gets the same ID
2. Orders can be safely retried without creating duplicates
3. Alpaca API enforces uniqueness of client_order_id

Key Properties:
- Same parameters + same date = same ID (idempotency)
- Different dates = different IDs (allows resubmission on new days)
- 24-character hex string (sufficient entropy, Alpaca-compatible)

See ADR-0005 for design rationale.
"""

import hashlib
from datetime import date, datetime
from decimal import Decimal

from apps.execution_gateway.schemas import OrderRequest


def generate_client_order_id(
    order: OrderRequest, strategy_id: str, as_of_date: date | None = None
) -> str:
    """
    Generate deterministic client_order_id for an order.

    The ID is generated by hashing the order parameters along with the date
    and strategy_id. This ensures idempotency - the same order submitted
    multiple times will have the same ID and won't create duplicates.

    Args:
        order: Order request containing symbol, side, qty, etc.
        strategy_id: Strategy identifier (e.g., 'alpha_baseline')
        as_of_date: Date to use for ID generation (defaults to today)

    Returns:
        24-character deterministic client_order_id

    Examples:
        >>> order = OrderRequest(
        ...     symbol="AAPL",
        ...     side="buy",
        ...     qty=10,
        ...     order_type="market"
        ... )
        >>> id1 = generate_client_order_id(order, "alpha_baseline")
        >>> id2 = generate_client_order_id(order, "alpha_baseline")
        >>> id1 == id2  # Same order -> same ID
        True

        >>> order2 = OrderRequest(
        ...     symbol="AAPL",
        ...     side="buy",
        ...     qty=11,  # Different quantity
        ...     order_type="market"
        ... )
        >>> id3 = generate_client_order_id(order2, "alpha_baseline")
        >>> id1 == id3  # Different order -> different ID
        False

    Implementation Details:
        The raw string format is:
            {symbol}|{side}|{qty}|{limit_price}|{stop_price}|{strategy_id}|{date}

        For example:
            AAPL|buy|10|None|None|alpha_baseline|2024-10-17

        This is then hashed with SHA256 and truncated to 24 characters.

    Notes:
        - limit_price and stop_price are included to differentiate orders
          with different prices
        - order_type and time_in_force are NOT included because they don't
          affect order uniqueness for our use case
        - Date component ensures orders can be resubmitted on different days
    """
    # Use provided date or default to today
    order_date = as_of_date or date.today()

    # Convert prices to strings (using "None" for null values)
    limit_price_str = str(order.limit_price) if order.limit_price is not None else "None"
    stop_price_str = str(order.stop_price) if order.stop_price is not None else "None"

    # Build raw string with all order parameters
    raw = (
        f"{order.symbol}|"
        f"{order.side}|"
        f"{order.qty}|"
        f"{limit_price_str}|"
        f"{stop_price_str}|"
        f"{strategy_id}|"
        f"{order_date.isoformat()}"
    )

    # Hash with SHA256 and take first 24 characters
    hash_obj = hashlib.sha256(raw.encode("utf-8"))
    client_order_id = hash_obj.hexdigest()[:24]

    return client_order_id


def validate_client_order_id(client_order_id: str) -> bool:
    """
    Validate that a client_order_id has the correct format.

    Args:
        client_order_id: The ID to validate

    Returns:
        True if valid, False otherwise

    Examples:
        >>> validate_client_order_id("a1b2c3d4e5f6g7h8i9j0k1l2")
        True
        >>> validate_client_order_id("invalid")
        False
        >>> validate_client_order_id("a1b2c3d4e5f6g7h8i9j0k1l2z3y4")  # Too long
        False
    """
    if not isinstance(client_order_id, str):
        return False

    if len(client_order_id) != 24:
        return False

    # Check if it's a valid hex string
    try:
        int(client_order_id, 16)
        return True
    except ValueError:
        return False


def reconstruct_order_params_hash(
    symbol: str,
    side: str,
    qty: int,
    limit_price: Decimal | None,
    stop_price: Decimal | None,
    strategy_id: str,
    order_date: date,
) -> str:
    """
    Reconstruct client_order_id from raw parameters.

    This is useful for debugging or verifying that an order matches
    its expected ID.

    Args:
        symbol: Stock symbol
        side: Order side (buy/sell)
        qty: Order quantity
        limit_price: Limit price (if applicable)
        stop_price: Stop price (if applicable)
        strategy_id: Strategy identifier
        order_date: Order date

    Returns:
        24-character client_order_id

    Examples:
        >>> from datetime import date
        >>> from decimal import Decimal
        >>> id1 = reconstruct_order_params_hash(
        ...     symbol="AAPL",
        ...     side="buy",
        ...     qty=10,
        ...     limit_price=None,
        ...     stop_price=None,
        ...     strategy_id="alpha_baseline",
        ...     order_date=date(2024, 10, 17)
        ... )
        >>> len(id1)
        24
    """
    # Convert prices to strings
    limit_price_str = str(limit_price) if limit_price is not None else "None"
    stop_price_str = str(stop_price) if stop_price is not None else "None"

    # Build raw string
    raw = (
        f"{symbol}|"
        f"{side}|"
        f"{qty}|"
        f"{limit_price_str}|"
        f"{stop_price_str}|"
        f"{strategy_id}|"
        f"{order_date.isoformat()}"
    )

    # Hash and truncate
    hash_obj = hashlib.sha256(raw.encode("utf-8"))
    return hash_obj.hexdigest()[:24]


def parse_order_date_from_timestamp(timestamp: datetime) -> date:
    """
    Extract date from timestamp for ID generation.

    Args:
        timestamp: Timestamp to extract date from

    Returns:
        Date object

    Examples:
        >>> from datetime import datetime
        >>> ts = datetime(2024, 10, 17, 16, 30, 0)
        >>> parse_order_date_from_timestamp(ts)
        datetime.date(2024, 10, 17)
    """
    return timestamp.date()
