"""
Deterministic client_order_id generation for idempotent order submission.

The client_order_id is generated using a SHA256 hash of the order parameters
plus the current date. This ensures that:
1. The same order submitted multiple times on the same day gets the same ID
2. Orders can be safely retried without creating duplicates
3. Alpaca API enforces uniqueness of client_order_id

Key Properties:
- Same parameters + same date = same ID (idempotency)
- Different dates = different IDs (allows resubmission on new days)
- 24-character hex string (sufficient entropy, Alpaca-compatible)

See ADR-0014 for design rationale.
"""

import hashlib
from datetime import UTC, date, datetime
from decimal import ROUND_HALF_UP, Decimal

from apps.execution_gateway.schemas import OrderRequest

# Price precision for ID generation (2 decimal places for USD stocks)
# This ensures Decimal("150.00") and Decimal("150.0") produce same ID
# while maintaining backwards compatibility (no scientific notation)
PRICE_PRECISION = Decimal("0.01")

# Maximum length of client order ID (Alpaca compatibility)
# SHA256 hex digest truncated to this length provides sufficient entropy
# while meeting Alpaca's client_order_id requirements
ORDER_ID_MAX_LENGTH = 24


def _format_price_for_id(price: Decimal | None) -> str:
    """
    Format price for client_order_id generation.

    Normalizes Decimal precision to ensure idempotency.

    Args:
        price: Price to format (None for market orders)

    Returns:
        Normalized price string or "None"

    Examples:
        >>> _format_price_for_id(Decimal("150.00"))
        '150.00'
        >>> _format_price_for_id(Decimal("150.0"))
        '150.00'
        >>> _format_price_for_id(None)
        'None'

    Notes:
        Uses quantize() instead of normalize() to avoid scientific notation.
    """
    if price is None:
        return "None"
    return str(price.quantize(PRICE_PRECISION, rounding=ROUND_HALF_UP))


def generate_client_order_id(
    order: OrderRequest, strategy_id: str, as_of_date: date | None = None
) -> str:
    """
    Generate deterministic client_order_id for an order.

    The ID is generated by hashing the order parameters along with the date
    and strategy_id. This ensures idempotency - the same order submitted
    multiple times will have the same ID and won't create duplicates.

    Args:
        order: Order request containing symbol, side, qty, etc.
        strategy_id: Strategy identifier (e.g., 'alpha_baseline')
        as_of_date: Date to use for ID generation (defaults to today)

    Returns:
        24-character deterministic client_order_id

    Examples:
        >>> order = OrderRequest(
        ...     symbol="AAPL",
        ...     side="buy",
        ...     qty=10,
        ...     order_type="market"
        ... )
        >>> id1 = generate_client_order_id(order, "alpha_baseline")
        >>> id2 = generate_client_order_id(order, "alpha_baseline")
        >>> id1 == id2  # Same order -> same ID
        True

        >>> order2 = OrderRequest(
        ...     symbol="AAPL",
        ...     side="buy",
        ...     qty=11,  # Different quantity
        ...     order_type="market"
        ... )
        >>> id3 = generate_client_order_id(order2, "alpha_baseline")
        >>> id1 == id3  # Different order -> different ID
        False

    Implementation Details:
        The raw string format is:
            {symbol}|{side}|{qty}|{limit_price}|{stop_price}|{order_type}|{time_in_force}|{strategy_id}|{date}

        For example:
            AAPL|buy|10|None|None|market|day|alpha_baseline|2024-10-17

        This is then hashed with SHA256 and truncated to 24 characters.

    Notes:
        - limit_price and stop_price are included to differentiate orders
          with different prices
        - order_type and time_in_force are included to differentiate orders
          with different execution semantics (e.g., DAY vs GTC)
        - Date component ensures orders can be resubmitted on different days
        - Date uses UTC timezone (not local time) for consistency across servers
    """
    # Use provided date or default to today's UTC date
    # NOTE: Using UTC ensures consistent IDs across servers in different timezones
    order_date = as_of_date or datetime.now(UTC).date()

    # Convert prices to strings (quantize to fixed precision for idempotency)
    limit_price_str = _format_price_for_id(order.limit_price)
    stop_price_str = _format_price_for_id(order.stop_price)

    # Build raw string with all order parameters
    # order_type and time_in_force included to prevent collisions between orders
    # with same symbol/side/qty but different execution semantics
    raw = (
        f"{order.symbol}|"
        f"{order.side}|"
        f"{order.qty}|"
        f"{limit_price_str}|"
        f"{stop_price_str}|"
        f"{order.order_type}|"
        f"{order.time_in_force}|"
        f"{strategy_id}|"
        f"{order_date.isoformat()}"
    )

    # Hash with SHA256 and take first ORDER_ID_MAX_LENGTH characters
    hash_obj = hashlib.sha256(raw.encode("utf-8"))
    client_order_id = hash_obj.hexdigest()[:ORDER_ID_MAX_LENGTH]

    return client_order_id


def validate_client_order_id(client_order_id: str) -> bool:
    """
    Validate that a client_order_id has the correct format.

    Args:
        client_order_id: The ID to validate

    Returns:
        True if valid, False otherwise

    Examples:
        >>> validate_client_order_id("a1b2c3d4e5f6g7h8i9j0k1l2")
        True
        >>> validate_client_order_id("invalid")
        False
        >>> validate_client_order_id("a1b2c3d4e5f6g7h8i9j0k1l2z3y4")  # Too long
        False
    """
    if not isinstance(client_order_id, str):
        return False

    if len(client_order_id) != ORDER_ID_MAX_LENGTH:
        return False

    # Check if it's a valid hex string
    try:
        int(client_order_id, 16)
        return True
    except ValueError:
        return False


def reconstruct_order_params_hash(
    symbol: str,
    side: str,
    qty: int,
    limit_price: Decimal | None,
    stop_price: Decimal | None,
    order_type: str,
    time_in_force: str,
    strategy_id: str,
    order_date: date,
) -> str:
    """
    Reconstruct client_order_id from raw parameters.

    This is useful for debugging or verifying that an order matches
    its expected ID.

    Args:
        symbol: Stock symbol
        side: Order side (buy/sell)
        qty: Order quantity
        limit_price: Limit price (if applicable)
        stop_price: Stop price (if applicable)
        order_type: Order type (market/limit/stop/stop_limit)
        time_in_force: Time in force (day/gtc/ioc/fok)
        strategy_id: Strategy identifier
        order_date: Order date

    Returns:
        24-character client_order_id

    Examples:
        >>> from datetime import date
        >>> from decimal import Decimal
        >>> id1 = reconstruct_order_params_hash(
        ...     symbol="AAPL",
        ...     side="buy",
        ...     qty=10,
        ...     limit_price=None,
        ...     stop_price=None,
        ...     order_type="market",
        ...     time_in_force="day",
        ...     strategy_id="alpha_baseline",
        ...     order_date=date(2024, 10, 17)
        ... )
        >>> len(id1)
        24
    """
    # Convert prices to strings (quantize to fixed precision for idempotency)
    limit_price_str = _format_price_for_id(limit_price)
    stop_price_str = _format_price_for_id(stop_price)

    # Build raw string (must match generate_client_order_id format)
    raw = (
        f"{symbol}|"
        f"{side}|"
        f"{qty}|"
        f"{limit_price_str}|"
        f"{stop_price_str}|"
        f"{order_type}|"
        f"{time_in_force}|"
        f"{strategy_id}|"
        f"{order_date.isoformat()}"
    )

    # Hash and truncate
    hash_obj = hashlib.sha256(raw.encode("utf-8"))
    return hash_obj.hexdigest()[:ORDER_ID_MAX_LENGTH]


def parse_order_date_from_timestamp(timestamp: datetime) -> date:
    """
    Extract date from timestamp for ID generation.

    Args:
        timestamp: Timestamp to extract date from

    Returns:
        Date object

    Examples:
        >>> from datetime import datetime
        >>> ts = datetime(2024, 10, 17, 16, 30, 0)
        >>> parse_order_date_from_timestamp(ts)
        datetime.date(2024, 10, 17)
    """
    return timestamp.date()
